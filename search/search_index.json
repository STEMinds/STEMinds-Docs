{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"STEMinds official documentation In this docs platform you'll find all the tools, tutorials and guides you need to get started with STEMinds official products and kits. In the wiki we offer detailed explanations and code samples in an easy to read format. Official Github repositories We upload all of our code and repositories to our official Github account. Although we do offer code examples here in the wiki, we suggest that users access the official Github repositories in order to open issue tickets (We hope you don't have any issues yet!) and read more detailed technical instructions. Our Github account can be accessed here: github.com/STEMinds Contact us Having trouble? want to ask a question? We are here. Feel free to contact us at: contact@steminds.com . We'll do our best to answer within 24 hours. Alternatively, you can message us directly on our STEMinds Facebook Page .","title":"Welcome"},{"location":"#steminds-official-documentation","text":"In this docs platform you'll find all the tools, tutorials and guides you need to get started with STEMinds official products and kits. In the wiki we offer detailed explanations and code samples in an easy to read format.","title":"STEMinds official documentation"},{"location":"#official-github-repositories","text":"We upload all of our code and repositories to our official Github account. Although we do offer code examples here in the wiki, we suggest that users access the official Github repositories in order to open issue tickets (We hope you don't have any issues yet!) and read more detailed technical instructions. Our Github account can be accessed here: github.com/STEMinds","title":"Official Github repositories"},{"location":"#contact-us","text":"Having trouble? want to ask a question? We are here. Feel free to contact us at: contact@steminds.com . We'll do our best to answer within 24 hours. Alternatively, you can message us directly on our STEMinds Facebook Page .","title":"Contact us"},{"location":"kits/eduponics_mini/advance_tools/","text":"Advanced programming tools Previously we've discussed how to get started with Eduponics mini IDE, if you consider yourself an advanced programmer, you might want to take things one step further. We'd like to introduce some advanced tools such as detecting the UART manually and operating the ESP32 with Ampy (an Adafruit Tool) something that can be useful if you want to work outside of the Thonny IDE environment. Manual work from now on We strongly suggest you to start with Thonny IDE if you are a complete beginner the following steps will explain about Ampy, Putty and some other tools that can help you install and run scripts manually on your Eduponics kit this might be very useful for advanced users but not so friendly for new users without previous experience. Connecting to the kit through UART Once we have the necessary drivers installed, it's time to connect to our board through UART for the first time. Firstly, we'll need to find the UART port. Baud rate also stands for bits per second and is a number related to the speed of data transmission in a system. The rate indicates the number of electrical oscillations per second that occurs within a data transmission. The higher the baud rate - the higher the transfer rate of bits per second. In our Eduponics mini kit, the UART baud rate is 115200 which we will use by default to communicate with our ESP32 microcontroller. If we use a different baud rate we might get nonsense or \"spaghetti\" feedback instead of what we expect the board to print back to us in response. in Mac OSX and Linux: Run the following command in terminal to find connected UART devices to make the process easier, make sure only the Eduponics Mini kit is connected to your computer by USB. Else, you might see other unrelated devices that might confuse you. ls /dev/*usb* the results should look similar to this: /dev/cu.usbserial-14310 /dev/tty.usbserial-14310 In our example the UART name will be \"tty.usbserial-14310\" which we will use to connect to the Eduponics mini. Now when we have the right UART name, we can easily run the following command in terminal to connect to the ESP32 MicroPython command-line interface: screen tty.usbserial-14310 115200 Of course, you will need to change the number \"14310\" to the one that shows up on your machine - it might look different. \"115200\" stands for the communication baud rate we use. Small tip for alternatives to screen On Linux, \"picocom\" or \"minicom\" may be used instead of \"screen\". The USB serial address might also be listed as /dev/ttyUSB01 or a higher increment for ttyUSB. Additionally, the elevated permissions to access the device (e.g. group uucp/dialout or use sudo) may be required. This can be done by typing the following commands sudo usermod -a -G dialout $user sudo chmod a+rw /dev/ttyUSB0 In Windows In Windows it's a little different, let's follow the steps below: Open Device Manager. Click on View in the menu bar and select Show hidden devices. Locate Ports (COM & LPT) in the list. Check for the com ports by expanding the COM menu option. Once you've located the right COM port, it's time to download putty to connect to the UART port. PuTTY is an SSH and telnet client, developed originally by Simon Tatham for the Windows platform. PuTTY is an open-source software that is available with source code and is developed and supported by a group of volunteers. We use PuTTY to communicate through UART with the Eduponics Mini, in OSX or Linux operation systems - a small piece of software called \"screen\" is already included, that allows us to communicate through UART without the need of external software You can download Putty from here: Putty official website Once you have Putty installed, you can proceed to entering the COM port that we found earlier in the device manager (it may not necessarily be COM4, it could be a different number) also make sure to set the baud rate as 115200 as we mentioned earlier. Tick the connection type checkbox as \"Serial\" once you are ready click the \"Open\" button to intialize the connection. Thonny IDE detects the UART name automatically If you use the Thonny IDE for your programming needs, in the interpeter it will already show you the port name and device information without needing to look for it manually. Adafruit MicroPython Tool Adafruit MicroPython Tool (ampy) - Utility helps you to interact with a MicroPython board over a serial connection. This appreciable utility can be useful to send, read, and run files on our Eduponics mini board with ease. Ampy is meant to be a simple command line tool to manipulate files and run code on a MicroPython board over its serial connection. With ampy you can send files from your computer to the board's file system, download files from a board to your computer, and even send a Python script to a board to be executed. We can find the ampy github repository here: https://github.com/scientifichackers/ampy The installation is very straight forward, let's make sure we have all the pre-requisites such as pyhon-pip, pyserial and python3. on MacOS or Linux in a terminal run the following command: pip3 install --user adafruit-ampy Note on some Linux and Mac OSX systems you might need to run as root with sudo: sudo pip3 install adafruit-ampy On Windows: do the following pip3 install adafruit-ampy Installing from source If you'd like to install from the Github source then use the standard Python setup.py install: git clone https://github.com/scientifichackers/ampy.git cd ampy python3 setup.py install Ampy Usage information Once installed verify you can run the ampy program and get help output: ampy --help You should see usage information displayed like below: Usage: ampy [OPTIONS] COMMAND [ARGS]... ampy - Adafruit MicroPython Tool Ampy is a tool to control MicroPython boards over a serial connection. Using ampy you can manipulate files on the board's internal filesystem and even run scripts. Options: -p, --port PORT Name of serial port for connected board. [required] -b, --baud BAUD Baud rate for the serial connection. (default 115200) -d, --delay DELAY Delay in seconds before entering RAW MODE (default 0) --help Show this message and exit. Commands: get Retrieve a file from the board. ls List contents of a directory on the board. put Put a file on the board. rm Remove a file from the board. run Run a script and print its output. Running files To run files with ampy we first need to make a file. let's make a python script and call it test.py this file can be created in text editor or your IDE / Code editor. inside the python script let's write the following: print ( \"hello world\" ) Make sure to save it. Once we have test.py file with the print hello world command inside of it, we can run it on our microcontroller using ampy by running the following commands: Serial port name You will need to change the USB Serial port name as it shows on your computer In Mac OSX / Linux: ampy --port /dev/tty.usbserial-<NUMBER_GOES_HERE> run test.py In Windows: ampy --port <COM_PORT_NAME_GOES_HERE> run test.py Once you'll run the code a response should come back with the text \"hello world\" Running doesn't mean save the code Running the code on your ESP32 Eduponics Mini board doesn't save the code inside the board's memory - it will only execute it. To save the code and run it later, proceed to the following steps where we will explain how to \"push\" files. Pushing files Pushing files is very similar to executing (running) files except we put them into our ESP32 device without actually running them, later on we can run them directly from the ESP32 board. In Mac OSX / Linux: ampy --port /dev/tty.usbserial-<NUMBER_GOES_HERE> put test.py In Windows: ampy --port <COM_PORT_NAME_GOES_HERE> put test.py Again, please do remember you need to change the COM port if you are on windows or type the correct serial number if you are on Linux / OSX. Getting files Getting files is the process of taking a file we have previously pushed into our ESP32 board but for some reason we don't have it anymore or we changed our local file and want to get the file that is currently inside the board. To do that, we'll use the \"get\" command to get the file from the ESP32 board into our local machine. In Mac OSX / Linux: ampy --port /dev/tty.usbserial-<NUMBER_GOES_HERE> get test.py In Windows: ampy --port <COM_PORT_NAME_GOES_HERE> get test.py Please note that \"get test.py\" has nothing to do with your local file test.py on your machine, by running \"get test.py\" it will overwrite any existing files named test.py, if you want to name it differently add another line at the end to state the new file name as follows: In Mac OSX / Linux: ampy --port /dev/tty.usbserial-<NUMBER_GOES_HERE> get test.py new_test.py In Windows: ampy --port <COM_PORT_NAME_GOES_HERE> get test.py new_test.py Removing files Sometimes we don't need the files we pushed earlier into our board, they take up unnecessary flash space and therefore we should delete them. to do so, we can use the \"rm\" command which stands for removal of existing files on the board In Mac OSX / Linux: ampy --port /dev/tty.usbserial-<NUMBER_GOES_HERE> rm test.py In Windows: ampy --port <COM_PORT_NAME_GOES_HERE> rm test.py Note, this will not affect any local file on your machine named \"test.py\" it will only remove the \"test.py\" file from the memory of the ESP32 chipset. Listing files The final step will be listing the files, let's say you previously pushed some files and removed some files and it's been some time or you've got confused what files we have in the ESP32 board and what files are missing ... all of this can be solved with one simple command \"ls\" which stands for list. In Mac OSX / Linux: ampy --port /dev/tty.usbserial-<NUMBER_GOES_HERE> ls In Windows: ampy --port <COM_PORT_NAME_GOES_HERE> ls As you can see, we don't need to mention any file that's because we just want to get the name of all the files that already exist on the ESP32 board. That's all the Ampy commands that you'll need, make sure to practice by pushing, getting, removing and listing files before you move to your own project to avoid mistakes! Coming up next Congratulations! you've made your first step in command line programming, hardware and the STEM world! Next, we'll start by introducing each sensor that is available on top of the Eduponics mini kit. After you'll master the science behind the sensors and how to program them yourself. We'll then move on to more advanced examples, combining multiple sensors together to achieve a fully functional IoT plant monitoring system.","title":"Advance manual tools"},{"location":"kits/eduponics_mini/advance_tools/#advanced-programming-tools","text":"Previously we've discussed how to get started with Eduponics mini IDE, if you consider yourself an advanced programmer, you might want to take things one step further. We'd like to introduce some advanced tools such as detecting the UART manually and operating the ESP32 with Ampy (an Adafruit Tool) something that can be useful if you want to work outside of the Thonny IDE environment. Manual work from now on We strongly suggest you to start with Thonny IDE if you are a complete beginner the following steps will explain about Ampy, Putty and some other tools that can help you install and run scripts manually on your Eduponics kit this might be very useful for advanced users but not so friendly for new users without previous experience.","title":"Advanced programming tools"},{"location":"kits/eduponics_mini/advance_tools/#connecting-to-the-kit-through-uart","text":"Once we have the necessary drivers installed, it's time to connect to our board through UART for the first time. Firstly, we'll need to find the UART port. Baud rate also stands for bits per second and is a number related to the speed of data transmission in a system. The rate indicates the number of electrical oscillations per second that occurs within a data transmission. The higher the baud rate - the higher the transfer rate of bits per second. In our Eduponics mini kit, the UART baud rate is 115200 which we will use by default to communicate with our ESP32 microcontroller. If we use a different baud rate we might get nonsense or \"spaghetti\" feedback instead of what we expect the board to print back to us in response.","title":"Connecting to the kit through UART"},{"location":"kits/eduponics_mini/advance_tools/#in-mac-osx-and-linux","text":"Run the following command in terminal to find connected UART devices to make the process easier, make sure only the Eduponics Mini kit is connected to your computer by USB. Else, you might see other unrelated devices that might confuse you. ls /dev/*usb* the results should look similar to this: /dev/cu.usbserial-14310 /dev/tty.usbserial-14310 In our example the UART name will be \"tty.usbserial-14310\" which we will use to connect to the Eduponics mini. Now when we have the right UART name, we can easily run the following command in terminal to connect to the ESP32 MicroPython command-line interface: screen tty.usbserial-14310 115200 Of course, you will need to change the number \"14310\" to the one that shows up on your machine - it might look different. \"115200\" stands for the communication baud rate we use. Small tip for alternatives to screen On Linux, \"picocom\" or \"minicom\" may be used instead of \"screen\". The USB serial address might also be listed as /dev/ttyUSB01 or a higher increment for ttyUSB. Additionally, the elevated permissions to access the device (e.g. group uucp/dialout or use sudo) may be required. This can be done by typing the following commands sudo usermod -a -G dialout $user sudo chmod a+rw /dev/ttyUSB0","title":"in Mac OSX and Linux:"},{"location":"kits/eduponics_mini/advance_tools/#in-windows","text":"In Windows it's a little different, let's follow the steps below: Open Device Manager. Click on View in the menu bar and select Show hidden devices. Locate Ports (COM & LPT) in the list. Check for the com ports by expanding the COM menu option. Once you've located the right COM port, it's time to download putty to connect to the UART port. PuTTY is an SSH and telnet client, developed originally by Simon Tatham for the Windows platform. PuTTY is an open-source software that is available with source code and is developed and supported by a group of volunteers. We use PuTTY to communicate through UART with the Eduponics Mini, in OSX or Linux operation systems - a small piece of software called \"screen\" is already included, that allows us to communicate through UART without the need of external software You can download Putty from here: Putty official website Once you have Putty installed, you can proceed to entering the COM port that we found earlier in the device manager (it may not necessarily be COM4, it could be a different number) also make sure to set the baud rate as 115200 as we mentioned earlier. Tick the connection type checkbox as \"Serial\" once you are ready click the \"Open\" button to intialize the connection. Thonny IDE detects the UART name automatically If you use the Thonny IDE for your programming needs, in the interpeter it will already show you the port name and device information without needing to look for it manually.","title":"In Windows"},{"location":"kits/eduponics_mini/advance_tools/#adafruit-micropython-tool","text":"Adafruit MicroPython Tool (ampy) - Utility helps you to interact with a MicroPython board over a serial connection. This appreciable utility can be useful to send, read, and run files on our Eduponics mini board with ease. Ampy is meant to be a simple command line tool to manipulate files and run code on a MicroPython board over its serial connection. With ampy you can send files from your computer to the board's file system, download files from a board to your computer, and even send a Python script to a board to be executed. We can find the ampy github repository here: https://github.com/scientifichackers/ampy The installation is very straight forward, let's make sure we have all the pre-requisites such as pyhon-pip, pyserial and python3.","title":"Adafruit MicroPython Tool"},{"location":"kits/eduponics_mini/advance_tools/#on-macos-or-linux","text":"in a terminal run the following command: pip3 install --user adafruit-ampy Note on some Linux and Mac OSX systems you might need to run as root with sudo: sudo pip3 install adafruit-ampy","title":"on MacOS or Linux"},{"location":"kits/eduponics_mini/advance_tools/#on-windows","text":"do the following pip3 install adafruit-ampy","title":"On Windows:"},{"location":"kits/eduponics_mini/advance_tools/#installing-from-source","text":"If you'd like to install from the Github source then use the standard Python setup.py install: git clone https://github.com/scientifichackers/ampy.git cd ampy python3 setup.py install","title":"Installing from source"},{"location":"kits/eduponics_mini/advance_tools/#ampy-usage-information","text":"Once installed verify you can run the ampy program and get help output: ampy --help You should see usage information displayed like below: Usage: ampy [OPTIONS] COMMAND [ARGS]... ampy - Adafruit MicroPython Tool Ampy is a tool to control MicroPython boards over a serial connection. Using ampy you can manipulate files on the board's internal filesystem and even run scripts. Options: -p, --port PORT Name of serial port for connected board. [required] -b, --baud BAUD Baud rate for the serial connection. (default 115200) -d, --delay DELAY Delay in seconds before entering RAW MODE (default 0) --help Show this message and exit. Commands: get Retrieve a file from the board. ls List contents of a directory on the board. put Put a file on the board. rm Remove a file from the board. run Run a script and print its output.","title":"Ampy Usage information"},{"location":"kits/eduponics_mini/advance_tools/#running-files","text":"To run files with ampy we first need to make a file. let's make a python script and call it test.py this file can be created in text editor or your IDE / Code editor. inside the python script let's write the following: print ( \"hello world\" ) Make sure to save it. Once we have test.py file with the print hello world command inside of it, we can run it on our microcontroller using ampy by running the following commands: Serial port name You will need to change the USB Serial port name as it shows on your computer In Mac OSX / Linux: ampy --port /dev/tty.usbserial-<NUMBER_GOES_HERE> run test.py In Windows: ampy --port <COM_PORT_NAME_GOES_HERE> run test.py Once you'll run the code a response should come back with the text \"hello world\" Running doesn't mean save the code Running the code on your ESP32 Eduponics Mini board doesn't save the code inside the board's memory - it will only execute it. To save the code and run it later, proceed to the following steps where we will explain how to \"push\" files.","title":"Running files"},{"location":"kits/eduponics_mini/advance_tools/#pushing-files","text":"Pushing files is very similar to executing (running) files except we put them into our ESP32 device without actually running them, later on we can run them directly from the ESP32 board. In Mac OSX / Linux: ampy --port /dev/tty.usbserial-<NUMBER_GOES_HERE> put test.py In Windows: ampy --port <COM_PORT_NAME_GOES_HERE> put test.py Again, please do remember you need to change the COM port if you are on windows or type the correct serial number if you are on Linux / OSX.","title":"Pushing files"},{"location":"kits/eduponics_mini/advance_tools/#getting-files","text":"Getting files is the process of taking a file we have previously pushed into our ESP32 board but for some reason we don't have it anymore or we changed our local file and want to get the file that is currently inside the board. To do that, we'll use the \"get\" command to get the file from the ESP32 board into our local machine. In Mac OSX / Linux: ampy --port /dev/tty.usbserial-<NUMBER_GOES_HERE> get test.py In Windows: ampy --port <COM_PORT_NAME_GOES_HERE> get test.py Please note that \"get test.py\" has nothing to do with your local file test.py on your machine, by running \"get test.py\" it will overwrite any existing files named test.py, if you want to name it differently add another line at the end to state the new file name as follows: In Mac OSX / Linux: ampy --port /dev/tty.usbserial-<NUMBER_GOES_HERE> get test.py new_test.py In Windows: ampy --port <COM_PORT_NAME_GOES_HERE> get test.py new_test.py","title":"Getting files"},{"location":"kits/eduponics_mini/advance_tools/#removing-files","text":"Sometimes we don't need the files we pushed earlier into our board, they take up unnecessary flash space and therefore we should delete them. to do so, we can use the \"rm\" command which stands for removal of existing files on the board In Mac OSX / Linux: ampy --port /dev/tty.usbserial-<NUMBER_GOES_HERE> rm test.py In Windows: ampy --port <COM_PORT_NAME_GOES_HERE> rm test.py Note, this will not affect any local file on your machine named \"test.py\" it will only remove the \"test.py\" file from the memory of the ESP32 chipset.","title":"Removing files"},{"location":"kits/eduponics_mini/advance_tools/#listing-files","text":"The final step will be listing the files, let's say you previously pushed some files and removed some files and it's been some time or you've got confused what files we have in the ESP32 board and what files are missing ... all of this can be solved with one simple command \"ls\" which stands for list. In Mac OSX / Linux: ampy --port /dev/tty.usbserial-<NUMBER_GOES_HERE> ls In Windows: ampy --port <COM_PORT_NAME_GOES_HERE> ls As you can see, we don't need to mention any file that's because we just want to get the name of all the files that already exist on the ESP32 board. That's all the Ampy commands that you'll need, make sure to practice by pushing, getting, removing and listing files before you move to your own project to avoid mistakes!","title":"Listing files"},{"location":"kits/eduponics_mini/advance_tools/#coming-up-next","text":"Congratulations! you've made your first step in command line programming, hardware and the STEM world! Next, we'll start by introducing each sensor that is available on top of the Eduponics mini kit. After you'll master the science behind the sensors and how to program them yourself. We'll then move on to more advanced examples, combining multiple sensors together to achieve a fully functional IoT plant monitoring system.","title":"Coming up next"},{"location":"kits/eduponics_mini/eduponics_mini_getting_started/","text":"Getting started with Eduponics Mini Before we get started - we need to get our programming environment ready, this includes installing some tools and drivers. It won't take long, just follow along with the guide and you should be ready in no time! Connecting the kit to the power The Eduponics Mini board includes 2 power interfaces. DC 12V Power interface USB Type-C 5V Power interface It's possible to power the board only by 5V USB Type C through one of the USB ports available on your computer or through an external USB hub. The USB Type-C should be used only for programming and not be used for general operation as the voltage is not enough to power some of the development board functionalities such as the 12V pump. Once you've finished programming, use the 12V power adapter to power your project, some modules and sensors such as the water pump and the relay require 12V, the inability to provide 12V input, and trying to use those sensors might cause instability and unexpected results. Powering the board by 12V and 5V power at the same time is completely safe and won't cause any damage to the board. Only use Eduponics mini supplied DC Power adapter Our Eduponics Mini 12V2A power adapter is RoHs, CE and FCC certified. The power adapter passed the most critical tests to ensure your safety and the safety of your project. The use of any other unofficial power adapter might result in damage to you or your project and we are not liable for the outcome Installing USB TTL Drivers The USB TTL Serial cables are a range of USB to serial converter cables which provide connectivity between USB and serial UART interfaces, In our kit, we include a USB Type-C cable that can communicate with the Eduponics Mini board to upload or download code into and from the ESP32 microcontroller that we use in our Eduponics mini kit. The Eduponics mini UART (serial communication) port is based on the CH340C driver which is the USB to TTL chip we are using. In order to make sure your computer can read and write to and from the Eduponics mini ESP32 kit we need to make sure we have the appropriate drivers installed Some computers might include support for it but some don't, if it doesn't work for you right away you might need to follow the instructions to install the driver. Windows and OSX drivers automatically installed If you have Windows or Mac system, The latest version of the Universal Driver should be automatically installed from a Windows Update or included with the OSX System pre-installed. On other systems you might need to download and install the drivers manually. SparkFun Electronics created a fabulous video that explains step by step how to get the driver installed on your machine. Follow the video below if you're having difficulties with your drivers and learn how to install the driver on your Windows, Mac, or Linux machine: The link to the tutorial can be found here: SparkFun how to install CH340C driver System reboot might be required When the installation is finished, a restart (reboot) to your system might be required in order for the driver to function properly. IDE or Code Editor The term \u201cIDE\u201d stands for \"Integrated Development Environment\". It is intended as a comprehensive toolset including a text editor, compiler, build/make integration, debugging and so on. Virtually all IDEs are tied specifically to a language or framework or a tightly collected set of languages or frameworks. Some examples: Visual Studio for .NET and other Microsoft languages, RubyMine for Ruby, IntelliJ for Java, XCode for Apple technologies. An editor is simply that, a tool that is designed to edit text. Typically they are optimized for programming languages though many programmer\u2019s text editors are branching out and adding features for non-programming text like Markdown 108 or Org Mode 88. The key here is that text editors are designed to work with whatever language or framework you choose. There are many available IDEs and code editors that support MicroPython, In STEMinds we prefer to use the Thonny IDE for the purpose of programming this kit and if you are a beginner and you'll see why. Inside the Thonny IDE, which is available both for Mac OSX, Windows and Linux; We can configure our Eduponics Mini to work right out of the box. The IDE allows us to communicate through UART directly, upload code, run code, and manage existing files on the Eduponics Mini. With the Thonny IDE you can run, manage and execute files directly in an easy, convenient and fast way. You can download Thonny IDE from here: Thonny IDE official website Configuring Eduponics mini with Thonny IDE The first thing you should to do is to connect the Eduponics Mini to your PC/Mac using the USB Type-C cable. Remember, the USB Type-C cable is the data cable we will use to write/read data from the Eduponics Mini kit while the DC power adapter is used to power the board, particularly the 12V pump. Once we've connected the Eduponics Mini board - drivers should be installed automatically, if you have an old operating system you can install them manually using the instructions we've mentioned earlier. Under Thonny -> Preferences you will find a tab called interpreter like this: In the interpreter make sure to choose MicroPython (ESP32) because that's the one we are using and in the port you should see USB Serial port, choose the one that is suitable to the Eduponics Mini device and not any other device that is connected to your system. Press OK to save the settings. Hello world Now when everything is ready - it's time to run our first command to make sure everything is working. In Python, we use the \"print\" command to print something into the terminal (or console if you are on windows) to run the hello world command - type the following into the putty window or your terminal after connecting to the USB UART using the \"screen\" command: print ( \"hello world\" ) if you are using Thonny IDE, on the bottom of the IDE, once you've connected your ESP32 Eduponics kit successfully, you should notice something similar to: \"MicroPython v1.13 on 2020-09-02; ESP32 module with ESP32\". Now every line of code you'll write will be directly executed on the Eduponics mini ESP32 microcontroller. Once you've typed the command and pressed \"Enter\" you should see \"Hello world\" on your screen! well done! Command is executed on the ESP32 not on your machine Once the \"hello world\" printing command was successfully executed, be aware that it was executed on the ESP32 Eduponics Mini board directly! Your machine may or may not have Python3 installed but the code through Thonny is running on the development board directly which means we can continue to code more exciting things and explore all the feature the Eduponics Mini prepared for us! Installing micropython-eduponics Library In order to ease things up, we've created a special library MicroPython for the Eduponics Mini and the Eduponics Mini extension board. The library can be found on our Github account: Micropython-Eduponics on github This library will allow us to use different type of functions with ease without the need to drag external dependencies and libs to the ESP32 board. If you are planning on using Arduino IDE environment, you can ignore the following steps. We will install the library through upip which is a MicroPython implementation of pip, python package manager. In order to do that, we first have to connect to the WiFi, we can do this by creating a file called boot.py on our Eduponics Mini device inside Thonny IDE and adding the following lines: import network import esp esp . osdebug ( None ) import gc gc . collect () ssid = 'WIFI_NAME' password = 'WIFI_PASSWORD' station = network . WLAN ( network . STA_IF ) station . active ( True ) station . connect ( ssid , password ) while station . isconnected () == False : pass print ( 'Connected to WiFi successfully, IP: %s ' % station . ifconfig ()[ 0 ]) We need to make sure to change WIFI_NAME and WIFI_PASSWORD to your Access point at home (WiFI credentials), make sure that the WiFi is 2.4GhZ and not 5G as the ESP32 currently doesn't support 5G wireless networks. Once the ESP32 is successfully connected to the WiFi and received IP address, we can write the following commands: import upip upip . install ( \"micropython-eduponics\" ) This will import upip and using the command upip.install() we can install the micropython-eduponics library. Now once everything is ready, we can import eduponics library and time and use the API to ease our programming experience and tasks!","title":"Getting started"},{"location":"kits/eduponics_mini/eduponics_mini_getting_started/#getting-started-with-eduponics-mini","text":"Before we get started - we need to get our programming environment ready, this includes installing some tools and drivers. It won't take long, just follow along with the guide and you should be ready in no time!","title":"Getting started with Eduponics Mini"},{"location":"kits/eduponics_mini/eduponics_mini_getting_started/#connecting-the-kit-to-the-power","text":"The Eduponics Mini board includes 2 power interfaces. DC 12V Power interface USB Type-C 5V Power interface It's possible to power the board only by 5V USB Type C through one of the USB ports available on your computer or through an external USB hub. The USB Type-C should be used only for programming and not be used for general operation as the voltage is not enough to power some of the development board functionalities such as the 12V pump. Once you've finished programming, use the 12V power adapter to power your project, some modules and sensors such as the water pump and the relay require 12V, the inability to provide 12V input, and trying to use those sensors might cause instability and unexpected results. Powering the board by 12V and 5V power at the same time is completely safe and won't cause any damage to the board. Only use Eduponics mini supplied DC Power adapter Our Eduponics Mini 12V2A power adapter is RoHs, CE and FCC certified. The power adapter passed the most critical tests to ensure your safety and the safety of your project. The use of any other unofficial power adapter might result in damage to you or your project and we are not liable for the outcome","title":"Connecting the kit to the power"},{"location":"kits/eduponics_mini/eduponics_mini_getting_started/#installing-usb-ttl-drivers","text":"The USB TTL Serial cables are a range of USB to serial converter cables which provide connectivity between USB and serial UART interfaces, In our kit, we include a USB Type-C cable that can communicate with the Eduponics Mini board to upload or download code into and from the ESP32 microcontroller that we use in our Eduponics mini kit. The Eduponics mini UART (serial communication) port is based on the CH340C driver which is the USB to TTL chip we are using. In order to make sure your computer can read and write to and from the Eduponics mini ESP32 kit we need to make sure we have the appropriate drivers installed Some computers might include support for it but some don't, if it doesn't work for you right away you might need to follow the instructions to install the driver. Windows and OSX drivers automatically installed If you have Windows or Mac system, The latest version of the Universal Driver should be automatically installed from a Windows Update or included with the OSX System pre-installed. On other systems you might need to download and install the drivers manually. SparkFun Electronics created a fabulous video that explains step by step how to get the driver installed on your machine. Follow the video below if you're having difficulties with your drivers and learn how to install the driver on your Windows, Mac, or Linux machine: The link to the tutorial can be found here: SparkFun how to install CH340C driver System reboot might be required When the installation is finished, a restart (reboot) to your system might be required in order for the driver to function properly.","title":"Installing USB TTL Drivers"},{"location":"kits/eduponics_mini/eduponics_mini_getting_started/#ide-or-code-editor","text":"The term \u201cIDE\u201d stands for \"Integrated Development Environment\". It is intended as a comprehensive toolset including a text editor, compiler, build/make integration, debugging and so on. Virtually all IDEs are tied specifically to a language or framework or a tightly collected set of languages or frameworks. Some examples: Visual Studio for .NET and other Microsoft languages, RubyMine for Ruby, IntelliJ for Java, XCode for Apple technologies. An editor is simply that, a tool that is designed to edit text. Typically they are optimized for programming languages though many programmer\u2019s text editors are branching out and adding features for non-programming text like Markdown 108 or Org Mode 88. The key here is that text editors are designed to work with whatever language or framework you choose. There are many available IDEs and code editors that support MicroPython, In STEMinds we prefer to use the Thonny IDE for the purpose of programming this kit and if you are a beginner and you'll see why. Inside the Thonny IDE, which is available both for Mac OSX, Windows and Linux; We can configure our Eduponics Mini to work right out of the box. The IDE allows us to communicate through UART directly, upload code, run code, and manage existing files on the Eduponics Mini. With the Thonny IDE you can run, manage and execute files directly in an easy, convenient and fast way. You can download Thonny IDE from here: Thonny IDE official website","title":"IDE or Code Editor"},{"location":"kits/eduponics_mini/eduponics_mini_getting_started/#configuring-eduponics-mini-with-thonny-ide","text":"The first thing you should to do is to connect the Eduponics Mini to your PC/Mac using the USB Type-C cable. Remember, the USB Type-C cable is the data cable we will use to write/read data from the Eduponics Mini kit while the DC power adapter is used to power the board, particularly the 12V pump. Once we've connected the Eduponics Mini board - drivers should be installed automatically, if you have an old operating system you can install them manually using the instructions we've mentioned earlier. Under Thonny -> Preferences you will find a tab called interpreter like this: In the interpreter make sure to choose MicroPython (ESP32) because that's the one we are using and in the port you should see USB Serial port, choose the one that is suitable to the Eduponics Mini device and not any other device that is connected to your system. Press OK to save the settings.","title":"Configuring Eduponics mini with Thonny IDE"},{"location":"kits/eduponics_mini/eduponics_mini_getting_started/#hello-world","text":"Now when everything is ready - it's time to run our first command to make sure everything is working. In Python, we use the \"print\" command to print something into the terminal (or console if you are on windows) to run the hello world command - type the following into the putty window or your terminal after connecting to the USB UART using the \"screen\" command: print ( \"hello world\" ) if you are using Thonny IDE, on the bottom of the IDE, once you've connected your ESP32 Eduponics kit successfully, you should notice something similar to: \"MicroPython v1.13 on 2020-09-02; ESP32 module with ESP32\". Now every line of code you'll write will be directly executed on the Eduponics mini ESP32 microcontroller. Once you've typed the command and pressed \"Enter\" you should see \"Hello world\" on your screen! well done! Command is executed on the ESP32 not on your machine Once the \"hello world\" printing command was successfully executed, be aware that it was executed on the ESP32 Eduponics Mini board directly! Your machine may or may not have Python3 installed but the code through Thonny is running on the development board directly which means we can continue to code more exciting things and explore all the feature the Eduponics Mini prepared for us!","title":"Hello world"},{"location":"kits/eduponics_mini/eduponics_mini_getting_started/#installing-micropython-eduponics-library","text":"In order to ease things up, we've created a special library MicroPython for the Eduponics Mini and the Eduponics Mini extension board. The library can be found on our Github account: Micropython-Eduponics on github This library will allow us to use different type of functions with ease without the need to drag external dependencies and libs to the ESP32 board. If you are planning on using Arduino IDE environment, you can ignore the following steps. We will install the library through upip which is a MicroPython implementation of pip, python package manager. In order to do that, we first have to connect to the WiFi, we can do this by creating a file called boot.py on our Eduponics Mini device inside Thonny IDE and adding the following lines: import network import esp esp . osdebug ( None ) import gc gc . collect () ssid = 'WIFI_NAME' password = 'WIFI_PASSWORD' station = network . WLAN ( network . STA_IF ) station . active ( True ) station . connect ( ssid , password ) while station . isconnected () == False : pass print ( 'Connected to WiFi successfully, IP: %s ' % station . ifconfig ()[ 0 ]) We need to make sure to change WIFI_NAME and WIFI_PASSWORD to your Access point at home (WiFI credentials), make sure that the WiFi is 2.4GhZ and not 5G as the ESP32 currently doesn't support 5G wireless networks. Once the ESP32 is successfully connected to the WiFi and received IP address, we can write the following commands: import upip upip . install ( \"micropython-eduponics\" ) This will import upip and using the command upip.install() we can install the micropython-eduponics library. Now once everything is ready, we can import eduponics library and time and use the API to ease our programming experience and tasks!","title":"Installing micropython-eduponics Library"},{"location":"kits/eduponics_mini/introduction/","text":"STEMinds Eduponics Mini Kit The Eduponics Mini is smart agriculture learning kit based on the ESP32 Microcontroller, it features many built in sensors as well as WiFi, Bluetooth and low power consumption support to enable real life IoT applications. This page provides you the basic knowledge and tools to get started with your Eduponics Mini kit. Usually, companies print this type of page as a small manual delivered together with the product. At STEMinds we care about the environment, and one of the ways we support this cause is by saving on unnecessary paper prints. By having the basic manual and instructions here we can assure you that we will always keep it up to date and working. Eduponics Mini Development board Except for the sensors and modules included in the Eduponics mini kit, the main thing is our custom made Eduponics Mini Board. The Eduponics Mini board is a custom printed circuit board (PCB) that consists of 2 layers with multiple connectors and sensors. On the top side of the board you'll find: ESP32 Micro Controller (already pre-installed with MicroPython) Water quantity, soil moisture and pump XH2.54 interfaces Tiny relay that is used for controlling the pump ON/OFF Switch 12V DC Power interface USB Type-C programmable interface (UART) Reset Button Wake up button (can be used with deep sleep functionality) RTC DS1307 Module (coin-cell battery not included with the kit) BH1750 I2C Light sensor BME280 Temperature, humidity and barometric pressure sensor Extension for DHT11 / DHT22 sensor (DHT sensor not included) AT24C02 EEPROM chip IO Expansion pins to connect extra sensors or modules Unpacking the kit Once you unpack the package, you will find it contains the following: Custom Eduponics Mini ESP32 development board 12V2A DC Power adapter USB Type-C data cable Soil moisture sensor 12V Submersible water pump Touch-less water quantity sensor Irrigation Water hose All those words might sound like a foreign language to you but we can assure you that at the end of the course not only will you understand their meaning but you'll also be able to control those sensors, program them and make your inventions completely by yourself! Comparison to other kits Eduponics is without doubt the best choice when it comes to price over value, our kit offer the best value for the same price as similar projects that exist in the market. Most importantly, most of the existing IoT agriculture kit offer no support for extension, the Eduponics Mini allows dozen of extension pins in order to integrate any sensor as you wish as well as Open source MicroPython + Arduino software and mobile IoT app. Eduponics Mini EcoDuino Smart Plant Care Gardening Add-On Kit Manufacturer STEMinds DFRobot Seeed Studio STEMpedia Soil Moisture sensor Yes (custom design) Yes Yes Yes (Corrosive) Extension IO pins Yes No Yes No MCU ESP32 ATmega None None WiFi Yes No No No Bluetooth/BLE Yes No No HC05 Bluetooth module Environmental sensors BME280 DHT11 DHT11 No Low powered Support deep-sleep No No No Protection enclosure STL files provided Yes No No RTC Module Yes No No No Ambient light sensor Yes No Yes Yes Water quantity sensor Yes No No No IoT Mobile app Yes, Eduponics APP No No No Indications RGB LED No OLED Display Blue/Red LEDs EEPROM Yes No No No Battery / solar powered External module External module No No Open Source Schematic+SW+STL SW HW+SW SW Programming languages Arduino, MicroPython Arduino C Arduino C Arduino C USB interface Type-C Micro-USB None None Supported extensions Yes No Arduino HATs or Grove No Documentation Complete, Arduino+Python Minimal Minimal Minimal Open source software All our code examples and drivers are completely open source, while our Eduponics mobile app is not open sourced for security reasons we do provide an MQTT library to control every aspect of the app remotely such as: Add and change sensors data Change plants name Water plants remotely Control an unlimited amount of plants All the code is available in our git repository: STEMinds Eduponics Mini repository Eduponics Mobile app The Eduponics Mini kit can be integrated with Eduponics app that allows it to be controlled from anywhere in the world using the MQTT communication protocol. This allows users and students to get sense of real life useful IoT applications that can be used in our daily lives. Programing language For this kit we've decided to use the MicroPython language which is based on Python3 but designed for microcontrollers. Python is the most popular programming language that exists today, millions of people use it for automation, AI, websites and programs that they use in their daily life. The Firmware we use is generic ESP32 firmware which allows you to program both in MicroPython using Thonny IDE or C++ using Arduino IDE. We currently officially support MicroPython but we've also added most of the examples for Arduino IDE in C++ programming language, in our Github repository you might find other supported ESP32 firmwares that could allow you to program in many different programming languages and explore other ways to interact with the Eduponics Mini!","title":"Introduction"},{"location":"kits/eduponics_mini/introduction/#steminds-eduponics-mini-kit","text":"The Eduponics Mini is smart agriculture learning kit based on the ESP32 Microcontroller, it features many built in sensors as well as WiFi, Bluetooth and low power consumption support to enable real life IoT applications. This page provides you the basic knowledge and tools to get started with your Eduponics Mini kit. Usually, companies print this type of page as a small manual delivered together with the product. At STEMinds we care about the environment, and one of the ways we support this cause is by saving on unnecessary paper prints. By having the basic manual and instructions here we can assure you that we will always keep it up to date and working.","title":"STEMinds Eduponics Mini Kit"},{"location":"kits/eduponics_mini/introduction/#eduponics-mini-development-board","text":"Except for the sensors and modules included in the Eduponics mini kit, the main thing is our custom made Eduponics Mini Board. The Eduponics Mini board is a custom printed circuit board (PCB) that consists of 2 layers with multiple connectors and sensors. On the top side of the board you'll find: ESP32 Micro Controller (already pre-installed with MicroPython) Water quantity, soil moisture and pump XH2.54 interfaces Tiny relay that is used for controlling the pump ON/OFF Switch 12V DC Power interface USB Type-C programmable interface (UART) Reset Button Wake up button (can be used with deep sleep functionality) RTC DS1307 Module (coin-cell battery not included with the kit) BH1750 I2C Light sensor BME280 Temperature, humidity and barometric pressure sensor Extension for DHT11 / DHT22 sensor (DHT sensor not included) AT24C02 EEPROM chip IO Expansion pins to connect extra sensors or modules","title":"Eduponics Mini Development board"},{"location":"kits/eduponics_mini/introduction/#unpacking-the-kit","text":"Once you unpack the package, you will find it contains the following: Custom Eduponics Mini ESP32 development board 12V2A DC Power adapter USB Type-C data cable Soil moisture sensor 12V Submersible water pump Touch-less water quantity sensor Irrigation Water hose All those words might sound like a foreign language to you but we can assure you that at the end of the course not only will you understand their meaning but you'll also be able to control those sensors, program them and make your inventions completely by yourself!","title":"Unpacking the kit"},{"location":"kits/eduponics_mini/introduction/#comparison-to-other-kits","text":"Eduponics is without doubt the best choice when it comes to price over value, our kit offer the best value for the same price as similar projects that exist in the market. Most importantly, most of the existing IoT agriculture kit offer no support for extension, the Eduponics Mini allows dozen of extension pins in order to integrate any sensor as you wish as well as Open source MicroPython + Arduino software and mobile IoT app. Eduponics Mini EcoDuino Smart Plant Care Gardening Add-On Kit Manufacturer STEMinds DFRobot Seeed Studio STEMpedia Soil Moisture sensor Yes (custom design) Yes Yes Yes (Corrosive) Extension IO pins Yes No Yes No MCU ESP32 ATmega None None WiFi Yes No No No Bluetooth/BLE Yes No No HC05 Bluetooth module Environmental sensors BME280 DHT11 DHT11 No Low powered Support deep-sleep No No No Protection enclosure STL files provided Yes No No RTC Module Yes No No No Ambient light sensor Yes No Yes Yes Water quantity sensor Yes No No No IoT Mobile app Yes, Eduponics APP No No No Indications RGB LED No OLED Display Blue/Red LEDs EEPROM Yes No No No Battery / solar powered External module External module No No Open Source Schematic+SW+STL SW HW+SW SW Programming languages Arduino, MicroPython Arduino C Arduino C Arduino C USB interface Type-C Micro-USB None None Supported extensions Yes No Arduino HATs or Grove No Documentation Complete, Arduino+Python Minimal Minimal Minimal","title":"Comparison to other kits"},{"location":"kits/eduponics_mini/introduction/#open-source-software","text":"All our code examples and drivers are completely open source, while our Eduponics mobile app is not open sourced for security reasons we do provide an MQTT library to control every aspect of the app remotely such as: Add and change sensors data Change plants name Water plants remotely Control an unlimited amount of plants All the code is available in our git repository: STEMinds Eduponics Mini repository","title":"Open source software"},{"location":"kits/eduponics_mini/introduction/#eduponics-mobile-app","text":"The Eduponics Mini kit can be integrated with Eduponics app that allows it to be controlled from anywhere in the world using the MQTT communication protocol. This allows users and students to get sense of real life useful IoT applications that can be used in our daily lives.","title":"Eduponics Mobile app"},{"location":"kits/eduponics_mini/introduction/#programing-language","text":"For this kit we've decided to use the MicroPython language which is based on Python3 but designed for microcontrollers. Python is the most popular programming language that exists today, millions of people use it for automation, AI, websites and programs that they use in their daily life. The Firmware we use is generic ESP32 firmware which allows you to program both in MicroPython using Thonny IDE or C++ using Arduino IDE. We currently officially support MicroPython but we've also added most of the examples for Arduino IDE in C++ programming language, in our Github repository you might find other supported ESP32 firmwares that could allow you to program in many different programming languages and explore other ways to interact with the Eduponics Mini!","title":"Programing language"},{"location":"kits/eduponics_mini/advance_usage/RGB_indicators/","text":"RGB based sensors indicators Previously we've discussed how WS2812B RGB LED can be useful in multiple applications and we've created a simple example how to change the RGB colors and brightness. Let's take it one step forward and combine the RGB with other sensors such as the water level sensor, soil moisture, temperature and humidity and more to create interactive light based on the value changes of those sensors. In this tutorials you might notice we used Try and except KeyboardInterrupt, The reason is that as long as the script runs in \"while\" loop the only way to shut it down is by interruption, while we interrupt the script the RGB will freeze in it's last state (the last used color). To overcome this situation, we except a keyboard interrupt event and manually turn off the LED after we finished with our program. Water level indication In this example we will change the WS2812B RGB LED color between green and red to indicate if our water container is empty or not. If it's empty - we'll change the RGB LED to red color else we'll make it green. in the code, we wrap everything around \"while\" loop to let our program check the quantity of the water every second and change the LED accordingly. If the water container is empty, the function is_empty() will return True (the sensor output HIGH when no water detected) and LOW if water detected. After setting np[0] (remember, we only have one LED at place 0) with the color we want, we need to remember to save changes using np.write() command. MicroPython import machine , neopixel import time # define water level sensor as INPUT on IO pin number 21 water_level = machine . Pin ( 21 , machine . Pin . IN ) # Configure the RGB LED at IO pin 14 (1 indicates 1 LED) np = neopixel . NeoPixel ( machine . Pin ( 14 ), 1 ) def is_empty (): # will return 0 if container have no water and 1 if it has water return water_level . value () try : while True : if ( is_empty ()): print ( \"[-] You don't have water in the container\" ) np [ 0 ] = ( 255 , 0 , 0 ) # set to red, full brightness else : print ( \"[-] The water container has sufficient amount of water\" ) np [ 0 ] = ( 0 , 255 , 0 ) # set to green, full brightness # save changes np . write () # save changes # wait one second before checking again time . sleep ( 1 ) except KeyboardInterrupt : # keyboard interrupt, let's turn off LED np [ 0 ] = ( 0 , 0 , 0 ) np . write () Soil moisture indication Previously in the soil moisture tutorial we've showed how to get percentage of approximately how much water our plant submerged in. in this part we'll combine one more functionality - the RGB LED. using the LED we can indicate whenever the plant has enough water or not. We'll use 3 colors: RED, YELLOW and GREEN. the red color will indicate the soil moisture is in critical levels, the yellow color will give us warning that we might need to water our plant and the green color will let us know everything is alright and we have nothing to worry about. MicroPython from machine import ADC , Pin import neopixel import time # set max val and min val of the sensor # this requires manual calibration # minVal get be recieved by putting the sensor submerged in the water # maxVal can be recieved by making sure the sensor is dry in the clear air minVal = 710 maxVal = 4095 # configure neopixel np = neopixel . NeoPixel ( Pin ( 14 ), 1 ) def value_in_percentage ( val ): # scale the value based on maxVal and minVal scale = 100 / ( minVal - maxVal ) # get calculated scale normal_reading = ( \" %s%s \" % ( int (( val - maxVal ) * scale ), \"%\" )) # we can also get inverted value if needed inverted_reading = ( \" %s%s \" % ( int (( minVal - val ) * scale ), \"%\" )) # for this example we'll return only the normal reading return normal_reading # set adc (analog to digital) on pin 35 adc = ADC ( Pin ( 35 )) # read analog input adc . read () # set 11dB input attenuation (voltage range roughly 0.0v - 3.6v) adc . atten ( ADC . ATTN_11DB ) # keep running the software till we stop it manually. try : while True : # get sensor value value = adc . read () # get the value in percentage, convert it to int estimated = int ( value_in_percentage ( value ) . replace ( \"%\" , \"\" )) if ( estimated >= 0 and estimated < 35 ): # turn RED color, it's critical np [ 0 ] = ( 255 , 0 , 0 ) # set to red, full brightness if ( estimated >= 35 and estimated < 65 ): # turn YELLOW color, it's alright for now np [ 0 ] = ( 255 , 255 , 0 ) # set to yellow, full brightness if ( estimated >= 65 and estimated <= 100 ): # turn GREEN color, we have enough water np [ 0 ] = ( 0 , 255 , 0 ) # set to green, full brightness # write changes of the RGB LED color np . write () # print the analog results (moisture) print ( \"sensor value: %s \" % value ) print ( \"sensor value in percentage: %s \" % value_in_percentage ( value )) # sleep for 1 second time . sleep ( 1 ) except KeyboardInterrupt : # keyboard interrupt, let's turn off LED np [ 0 ] = ( 0 , 0 , 0 ) np . write () Temperature / Humidity indication Let's understand more about what is right or wrong temperature for the plants by the following chart made by the ministry of environment in Canada: The X axis represents the temperature while the Y axis represents the humidity. We can match them both in order to find the optional temperature and humidity on how to behave during heat waves. Humidex provides a crucial information on how to behave during certain temperature and humidity situations to avoid damage to humans such as workers that work outdoors, kids at schools and more ... Not all plants are the same, changes in the variables might be required each plant is different, if you know the optimal temperature/humidity for your plant you should consider using your known data points instead. humidex might not be the right solution for your build so you can consider other alternatives. The graph above is called \"Humidex chart\" from wikipedia: The humidex (short for humidity index) is an index number used by Canadian meteorologists to describe how hot the weather feels to the average person, by combining the effect of heat and humidity. The term humidex was first coined in 1965. The humidex is a nominally dimensionless quantity (though generally recognized by the public as equivalent to the degree Celsius) based on the dew point. In order to find the humidex value we need 2 parameters: Temperature (in celsius) Himidity (in celsius) This 2 variables we can get using our temperature and humidity sensor. But, we will need few more things which the sensor won't provide us directly. the first thing will be something called \"dew point\" which is the temperature at which the air is saturated (100 percent relative humidity). Don't worry, we have a formulate to get this thing ready for us: Where RH stands for \"relative humidity\" the humidity we get through our temperature and humidity sensor. The results of this formula will be in celsius but to calculate humidex we'll need the result in Kelvin, the formula for celsius to kevin is quite easy: dewpoint_k = (dewpoint_c + 273.15) Now when we have the depoint in Kavin, it's time to get the humidex value, the formula as follows: Looks quite complicated right? no worries, we've implemented it in Python already in the example that will come up next. The graph itself already state for us the necessary values: Less than 29 - No discomfort 30-39 - Some discomfort 40 > - Great discomfort The \"discomfort\" chart is for humans but we can use it for plants as well, if you feel it's extremely hot and dry outside your plant will probably feel the same and maybe on even much larger scale. again, depends on the type of plant you have. To finalize everything we learned let's write the Python Code: MicroPython import dht from machine import Pin import math import neopixel import time def calculate_humidex ( T , RH ): # find dewpoint in celsius dewpoint_c = 243.04 * ( math . log ( RH / 100 , math . e ) + (( 17.625 * T ) / ( 243.04 + T ))) / ( 17.625 - math . log ( RH / 100 , math . e ) - (( 17.625 * T ) / ( 243.04 + T ))) # convert celsius to Kelvin dewpoint_k = ( dewpoint_c + 273.15 ) # find the humidex using the dewpoint we found earlier humidex = T + ( 0.5555 ) * ( 6.11 * math . exp ( 5417.7530 * (( 1 / 273.16 ) - ( 1 / dewpoint_k ))) - 10.0 ) # return humidex return humidex # initialize dht object, DHT11 coonected to IO19 d = dht . DHT11 ( Pin ( 19 )) # configure neopixel np = neopixel . NeoPixel ( Pin ( 14 ), 1 ) try : while True : # measure sensor data d . measure () # get temperature and humidity temperature = d . temperature () humidity = d . humidity () # get humidex humidex = calculate_humidex ( temperature , humidity ) # check the value of the humidex if ( humidex > 0 and humidex < 29 ): # Turn on green RGB np [ 0 ] = ( 0 , 255 , 0 ) # set to green, full brightness if ( humidex >= 30 and humidex <= 39 ): # Turn on yellow RGB np [ 0 ] = ( 255 , 255 , 0 ) # set to red, full brightness if ( humidex > 40 ): # Turn on red RGB np [ 0 ] = ( 255 , 0 , 0 ) # set to red, full brightness # write the data to the RGB np . write () # print temperature and humidity print ( \"--------------------------\" ) print ( \"temperature : %s \" % temperature ) print ( \"humidity : %s \" % humidity ) print ( \"humidex : %s \" % humidex ) print ( \"--------------------------\" ) print ( \"\" ) # sleep for 1 second time . sleep ( 1 ) except KeyboardInterrupt : # keyboard interrupt, let's turn off LED np [ 0 ] = ( 0 , 0 , 0 ) np . write () To summarize what the python code will do: use the function calculate_humidex which is based on the previous formulas we've studied to calculate the humidex value based on the current temperature and humidity. Then, it will run a loop as long as the keyboard does not interrupt it to measure temperature and humidity and check if the value is good, normal or bad and change the RGB LEDs accordingly. Light indication Each plant need different amount of light and that's a fact. We've found this great document by the University Of Melbourne that explains amount of light required for indoor plants in lux (Lumens per square metre). By that University made document we can understand few levels of lights that we can configure: Low \u2013 range 270 to 807Lux Medium \u2013 range of 807 to 1614 Lux. High \u2013 range 1614 to 10764 Lux As in previous examples we'll configure 3 main colors: red for low, yellow for medium and green for high. We will use the light class we've made earlier and combine it with the Neopixel functionality to turn on different RGB color at different state of light. MicroPython import machine , neopixel import time class LightSensor (): def __init__ ( self ): # Define some constants from the datasheet self . DEVICE = 0x5c # Default device I2C address self . POWER_DOWN = 0x00 # No active state self . POWER_ON = 0x01 # Power on self . RESET = 0x07 # Reset data register value # Start measurement at 4lx resolution. Time typically 16ms. self . CONTINUOUS_LOW_RES_MODE = 0x13 # Start measurement at 1lx resolution. Time typically 120ms self . CONTINUOUS_HIGH_RES_MODE_1 = 0x10 # Start measurement at 0.5lx resolution. Time typically 120ms self . CONTINUOUS_HIGH_RES_MODE_2 = 0x11 # Start measurement at 1lx resolution. Time typically 120ms # Device is automatically set to Power Down after measurement. self . ONE_TIME_HIGH_RES_MODE_1 = 0x20 # Start measurement at 0.5lx resolution. Time typically 120ms # Device is automatically set to Power Down after measurement. self . ONE_TIME_HIGH_RES_MODE_2 = 0x21 # Start measurement at 1lx resolution. Time typically 120ms # Device is automatically set to Power Down after measurement. self . ONE_TIME_LOW_RES_MODE = 0x23 # setup I2C self . i2c = machine . I2C ( scl = machine . Pin ( 15 ), sda = machine . Pin ( 4 )) def convertToNumber ( self , data ): # Simple function to convert 2 bytes of data # into a decimal number return (( data [ 1 ] + ( 256 * data [ 0 ])) / 1.2 ) def readLight ( self ): data = self . i2c . readfrom_mem ( self . DEVICE , self . ONE_TIME_HIGH_RES_MODE_1 , 2 ) return self . convertToNumber ( data ) # Configure the RGB LED at IO pin 14 (1 indicates 1 LED) np = neopixel . NeoPixel ( machine . Pin ( 14 ), 1 ) # Configure light sensor sensor = LightSensor () try : while True : # get amount of light light = int ( sensor . readLight ()) # check amount of light if ( light <= 807 ): # low light, turn on red RGB np [ 0 ] = ( 255 , 0 , 0 ) elif ( light > 807 and light <= 1614 ): # medium light, turn on yellow RGB np [ 0 ] = ( 255 , 255 , 0 ) elif ( light > 1614 ): # high light, turn on green RGB np [ 0 ] = ( 0 , 255 , 0 ) # Save changes to RGB np . write () # Print amount of light in lux print ( \"Light in the room: %s lux\" % light ) # Sleep 1 second time . sleep ( 1 ) except KeyboardInterrupt : # keyboard interrupt, let's turn off LED np [ 0 ] = ( 0 , 0 , 0 ) np . write ()","title":"RGB based indicators"},{"location":"kits/eduponics_mini/advance_usage/RGB_indicators/#rgb-based-sensors-indicators","text":"Previously we've discussed how WS2812B RGB LED can be useful in multiple applications and we've created a simple example how to change the RGB colors and brightness. Let's take it one step forward and combine the RGB with other sensors such as the water level sensor, soil moisture, temperature and humidity and more to create interactive light based on the value changes of those sensors. In this tutorials you might notice we used Try and except KeyboardInterrupt, The reason is that as long as the script runs in \"while\" loop the only way to shut it down is by interruption, while we interrupt the script the RGB will freeze in it's last state (the last used color). To overcome this situation, we except a keyboard interrupt event and manually turn off the LED after we finished with our program.","title":"RGB based sensors indicators"},{"location":"kits/eduponics_mini/advance_usage/RGB_indicators/#water-level-indication","text":"In this example we will change the WS2812B RGB LED color between green and red to indicate if our water container is empty or not. If it's empty - we'll change the RGB LED to red color else we'll make it green. in the code, we wrap everything around \"while\" loop to let our program check the quantity of the water every second and change the LED accordingly. If the water container is empty, the function is_empty() will return True (the sensor output HIGH when no water detected) and LOW if water detected. After setting np[0] (remember, we only have one LED at place 0) with the color we want, we need to remember to save changes using np.write() command. MicroPython import machine , neopixel import time # define water level sensor as INPUT on IO pin number 21 water_level = machine . Pin ( 21 , machine . Pin . IN ) # Configure the RGB LED at IO pin 14 (1 indicates 1 LED) np = neopixel . NeoPixel ( machine . Pin ( 14 ), 1 ) def is_empty (): # will return 0 if container have no water and 1 if it has water return water_level . value () try : while True : if ( is_empty ()): print ( \"[-] You don't have water in the container\" ) np [ 0 ] = ( 255 , 0 , 0 ) # set to red, full brightness else : print ( \"[-] The water container has sufficient amount of water\" ) np [ 0 ] = ( 0 , 255 , 0 ) # set to green, full brightness # save changes np . write () # save changes # wait one second before checking again time . sleep ( 1 ) except KeyboardInterrupt : # keyboard interrupt, let's turn off LED np [ 0 ] = ( 0 , 0 , 0 ) np . write ()","title":"Water level indication"},{"location":"kits/eduponics_mini/advance_usage/RGB_indicators/#soil-moisture-indication","text":"Previously in the soil moisture tutorial we've showed how to get percentage of approximately how much water our plant submerged in. in this part we'll combine one more functionality - the RGB LED. using the LED we can indicate whenever the plant has enough water or not. We'll use 3 colors: RED, YELLOW and GREEN. the red color will indicate the soil moisture is in critical levels, the yellow color will give us warning that we might need to water our plant and the green color will let us know everything is alright and we have nothing to worry about. MicroPython from machine import ADC , Pin import neopixel import time # set max val and min val of the sensor # this requires manual calibration # minVal get be recieved by putting the sensor submerged in the water # maxVal can be recieved by making sure the sensor is dry in the clear air minVal = 710 maxVal = 4095 # configure neopixel np = neopixel . NeoPixel ( Pin ( 14 ), 1 ) def value_in_percentage ( val ): # scale the value based on maxVal and minVal scale = 100 / ( minVal - maxVal ) # get calculated scale normal_reading = ( \" %s%s \" % ( int (( val - maxVal ) * scale ), \"%\" )) # we can also get inverted value if needed inverted_reading = ( \" %s%s \" % ( int (( minVal - val ) * scale ), \"%\" )) # for this example we'll return only the normal reading return normal_reading # set adc (analog to digital) on pin 35 adc = ADC ( Pin ( 35 )) # read analog input adc . read () # set 11dB input attenuation (voltage range roughly 0.0v - 3.6v) adc . atten ( ADC . ATTN_11DB ) # keep running the software till we stop it manually. try : while True : # get sensor value value = adc . read () # get the value in percentage, convert it to int estimated = int ( value_in_percentage ( value ) . replace ( \"%\" , \"\" )) if ( estimated >= 0 and estimated < 35 ): # turn RED color, it's critical np [ 0 ] = ( 255 , 0 , 0 ) # set to red, full brightness if ( estimated >= 35 and estimated < 65 ): # turn YELLOW color, it's alright for now np [ 0 ] = ( 255 , 255 , 0 ) # set to yellow, full brightness if ( estimated >= 65 and estimated <= 100 ): # turn GREEN color, we have enough water np [ 0 ] = ( 0 , 255 , 0 ) # set to green, full brightness # write changes of the RGB LED color np . write () # print the analog results (moisture) print ( \"sensor value: %s \" % value ) print ( \"sensor value in percentage: %s \" % value_in_percentage ( value )) # sleep for 1 second time . sleep ( 1 ) except KeyboardInterrupt : # keyboard interrupt, let's turn off LED np [ 0 ] = ( 0 , 0 , 0 ) np . write ()","title":"Soil moisture indication"},{"location":"kits/eduponics_mini/advance_usage/RGB_indicators/#temperature-humidity-indication","text":"Let's understand more about what is right or wrong temperature for the plants by the following chart made by the ministry of environment in Canada: The X axis represents the temperature while the Y axis represents the humidity. We can match them both in order to find the optional temperature and humidity on how to behave during heat waves. Humidex provides a crucial information on how to behave during certain temperature and humidity situations to avoid damage to humans such as workers that work outdoors, kids at schools and more ... Not all plants are the same, changes in the variables might be required each plant is different, if you know the optimal temperature/humidity for your plant you should consider using your known data points instead. humidex might not be the right solution for your build so you can consider other alternatives. The graph above is called \"Humidex chart\" from wikipedia: The humidex (short for humidity index) is an index number used by Canadian meteorologists to describe how hot the weather feels to the average person, by combining the effect of heat and humidity. The term humidex was first coined in 1965. The humidex is a nominally dimensionless quantity (though generally recognized by the public as equivalent to the degree Celsius) based on the dew point. In order to find the humidex value we need 2 parameters: Temperature (in celsius) Himidity (in celsius) This 2 variables we can get using our temperature and humidity sensor. But, we will need few more things which the sensor won't provide us directly. the first thing will be something called \"dew point\" which is the temperature at which the air is saturated (100 percent relative humidity). Don't worry, we have a formulate to get this thing ready for us: Where RH stands for \"relative humidity\" the humidity we get through our temperature and humidity sensor. The results of this formula will be in celsius but to calculate humidex we'll need the result in Kelvin, the formula for celsius to kevin is quite easy: dewpoint_k = (dewpoint_c + 273.15) Now when we have the depoint in Kavin, it's time to get the humidex value, the formula as follows: Looks quite complicated right? no worries, we've implemented it in Python already in the example that will come up next. The graph itself already state for us the necessary values: Less than 29 - No discomfort 30-39 - Some discomfort 40 > - Great discomfort The \"discomfort\" chart is for humans but we can use it for plants as well, if you feel it's extremely hot and dry outside your plant will probably feel the same and maybe on even much larger scale. again, depends on the type of plant you have. To finalize everything we learned let's write the Python Code: MicroPython import dht from machine import Pin import math import neopixel import time def calculate_humidex ( T , RH ): # find dewpoint in celsius dewpoint_c = 243.04 * ( math . log ( RH / 100 , math . e ) + (( 17.625 * T ) / ( 243.04 + T ))) / ( 17.625 - math . log ( RH / 100 , math . e ) - (( 17.625 * T ) / ( 243.04 + T ))) # convert celsius to Kelvin dewpoint_k = ( dewpoint_c + 273.15 ) # find the humidex using the dewpoint we found earlier humidex = T + ( 0.5555 ) * ( 6.11 * math . exp ( 5417.7530 * (( 1 / 273.16 ) - ( 1 / dewpoint_k ))) - 10.0 ) # return humidex return humidex # initialize dht object, DHT11 coonected to IO19 d = dht . DHT11 ( Pin ( 19 )) # configure neopixel np = neopixel . NeoPixel ( Pin ( 14 ), 1 ) try : while True : # measure sensor data d . measure () # get temperature and humidity temperature = d . temperature () humidity = d . humidity () # get humidex humidex = calculate_humidex ( temperature , humidity ) # check the value of the humidex if ( humidex > 0 and humidex < 29 ): # Turn on green RGB np [ 0 ] = ( 0 , 255 , 0 ) # set to green, full brightness if ( humidex >= 30 and humidex <= 39 ): # Turn on yellow RGB np [ 0 ] = ( 255 , 255 , 0 ) # set to red, full brightness if ( humidex > 40 ): # Turn on red RGB np [ 0 ] = ( 255 , 0 , 0 ) # set to red, full brightness # write the data to the RGB np . write () # print temperature and humidity print ( \"--------------------------\" ) print ( \"temperature : %s \" % temperature ) print ( \"humidity : %s \" % humidity ) print ( \"humidex : %s \" % humidex ) print ( \"--------------------------\" ) print ( \"\" ) # sleep for 1 second time . sleep ( 1 ) except KeyboardInterrupt : # keyboard interrupt, let's turn off LED np [ 0 ] = ( 0 , 0 , 0 ) np . write () To summarize what the python code will do: use the function calculate_humidex which is based on the previous formulas we've studied to calculate the humidex value based on the current temperature and humidity. Then, it will run a loop as long as the keyboard does not interrupt it to measure temperature and humidity and check if the value is good, normal or bad and change the RGB LEDs accordingly.","title":"Temperature / Humidity indication"},{"location":"kits/eduponics_mini/advance_usage/RGB_indicators/#light-indication","text":"Each plant need different amount of light and that's a fact. We've found this great document by the University Of Melbourne that explains amount of light required for indoor plants in lux (Lumens per square metre). By that University made document we can understand few levels of lights that we can configure: Low \u2013 range 270 to 807Lux Medium \u2013 range of 807 to 1614 Lux. High \u2013 range 1614 to 10764 Lux As in previous examples we'll configure 3 main colors: red for low, yellow for medium and green for high. We will use the light class we've made earlier and combine it with the Neopixel functionality to turn on different RGB color at different state of light. MicroPython import machine , neopixel import time class LightSensor (): def __init__ ( self ): # Define some constants from the datasheet self . DEVICE = 0x5c # Default device I2C address self . POWER_DOWN = 0x00 # No active state self . POWER_ON = 0x01 # Power on self . RESET = 0x07 # Reset data register value # Start measurement at 4lx resolution. Time typically 16ms. self . CONTINUOUS_LOW_RES_MODE = 0x13 # Start measurement at 1lx resolution. Time typically 120ms self . CONTINUOUS_HIGH_RES_MODE_1 = 0x10 # Start measurement at 0.5lx resolution. Time typically 120ms self . CONTINUOUS_HIGH_RES_MODE_2 = 0x11 # Start measurement at 1lx resolution. Time typically 120ms # Device is automatically set to Power Down after measurement. self . ONE_TIME_HIGH_RES_MODE_1 = 0x20 # Start measurement at 0.5lx resolution. Time typically 120ms # Device is automatically set to Power Down after measurement. self . ONE_TIME_HIGH_RES_MODE_2 = 0x21 # Start measurement at 1lx resolution. Time typically 120ms # Device is automatically set to Power Down after measurement. self . ONE_TIME_LOW_RES_MODE = 0x23 # setup I2C self . i2c = machine . I2C ( scl = machine . Pin ( 15 ), sda = machine . Pin ( 4 )) def convertToNumber ( self , data ): # Simple function to convert 2 bytes of data # into a decimal number return (( data [ 1 ] + ( 256 * data [ 0 ])) / 1.2 ) def readLight ( self ): data = self . i2c . readfrom_mem ( self . DEVICE , self . ONE_TIME_HIGH_RES_MODE_1 , 2 ) return self . convertToNumber ( data ) # Configure the RGB LED at IO pin 14 (1 indicates 1 LED) np = neopixel . NeoPixel ( machine . Pin ( 14 ), 1 ) # Configure light sensor sensor = LightSensor () try : while True : # get amount of light light = int ( sensor . readLight ()) # check amount of light if ( light <= 807 ): # low light, turn on red RGB np [ 0 ] = ( 255 , 0 , 0 ) elif ( light > 807 and light <= 1614 ): # medium light, turn on yellow RGB np [ 0 ] = ( 255 , 255 , 0 ) elif ( light > 1614 ): # high light, turn on green RGB np [ 0 ] = ( 0 , 255 , 0 ) # Save changes to RGB np . write () # Print amount of light in lux print ( \"Light in the room: %s lux\" % light ) # Sleep 1 second time . sleep ( 1 ) except KeyboardInterrupt : # keyboard interrupt, let's turn off LED np [ 0 ] = ( 0 , 0 , 0 ) np . write ()","title":"Light indication"},{"location":"kits/eduponics_mini/advance_usage/basic_mqtt_client/","text":"Basic MQTT client In this article we'll build a simple MQTT client that publish static data at specific interval. We'll use the \"smart home\" scenario where we have lights at home, we'll publish data through the MQTT broker and finally read the data in real time. This article doesn't have much real-life use using our Eduponics Mini but it will give you a glance and easy understand of how MQTT works. in our next article we'll integrate into our client all the Eduponics Mini sensor and send them over the MQTT network to our mobile app - The Eduponics APP. Install mosquitto CLI on your PC/Mac/Linux At the end of this guide we'll be able to publish static data at interval from our Eduponics Mini to the MQTT public broker. in order to listen (subscribe) to the data and see when it goes through, we'll need to install the mosquitto CLI into our machine. The installation is fairly easy and mosquitto.org gives instructions and binary to download for each machine, follow the instructions in mosquitto.org website to install the binary that is suitable for you: MQTT mosquitto.org CLI download Connecting Eduponics Mini to WiFi The first thing you might be asking yourself \"how does the Eduponics mini communicate with the cloud without wireless connectivity?\" Well, the good news is ESP32, the microcontroller that the Eduponics mini uses includes WiFi and Bluetooth! First thing before we even think about using the MQTT functionality is to make sure that our Eduponics Mini board can connect to the WiFi and has network connectivity so we could proceed. We can achieve this by creating boot.py file, this file will first load when our Eduponics Mini restart or the power plugged in, in this file we'll configure the WiFi credentials such as ESSID (WiFi name) and the WiFi password. Once we've connected to the WiFi using the station.connect() command, we can print our ESP32 WiFi IP address into the console. MicroPython import network import esp import time esp . osdebug ( None ) import gc gc . collect () # set WiFi credentials ssid = '' password = '' # check if there is username and password for wifi if ( ssid != '' and password != '' ): station = network . WLAN ( network . STA_IF ) station . active ( True ) station . connect ( ssid , password ) timeout_interval = 10 # try to connect with timeout interval for i in range ( 0 , timeout_interval ): if ( station . isconnected () == False ): time . sleep ( 1 ) pass else : break ; if ( station . isconnected ()): print ( 'Connected to WiFi successfully, IP: %s ' % station . ifconfig ()[ 0 ]) else : print ( \"Something went wrong, connection timeout, try again!\" ) else : print ( \"Please add WiFi credentials properly\" ) Now every time we restart or power the Eduponics Mini board it will automatically connect to the WiFi at our home. 2.54GhZ WiFi support only The ESP32 support only 2.54GhZ WiFi networks. Most of the 5Ghz WiFi routers / access points allow both 5Ghz and 2.54Ghz, make sure to choose the 2.54Ghz one. Installing the micropython-eduponics library The MicroPython-Eduponics library can be found on STEMinds Micropython-Eduponics repository the easist way to install the library is through uPip. Make sure to change WiFi ESSID and Password. Once the ESP32 is connected to the Wifi, run the following commands: import upip upip . install ( \"micropython-eduponics\" ) The installation should complete and once it's done you shall have a \"lib\" directory on your ESP32 device containing all the pre-requirements for this tutorial. Another way would be to grab the firmwares directly from the repository and install them into your ESP32 device using the esptool mentioned in the first tutorials. uMQTTSimple class This class was taken from randomnedtutorials.com and it's extremely useful for what we are trying to achieve. this class will enable us to deal with the entire MQTT protocol (publishing and subscribing) with ease. If you look at the initialiser you'll see we give it a couple of parameters such as server (we'll use a public server at mqtt.eclipse.com ) and some other credentials we won't use such as username, password and other parameters. We should save this python code into file we'll call umqttsimple.py and we will import it using the import command every time we want to use the MQTT functionalities to communicate through the MQTT network. It's important to note that the class already exists in the micropython-eduponics library and if you followed the instructions above, you don't need to copy this class, it's for reference only. MicroPython import usocket as socket import machine import ustruct as struct from ubinascii import hexlify class MQTTException ( Exception ): pass class MQTTClient : def __init__ ( self , client_id = hexlify ( machine . unique_id ()), server = \"mqtt.eclipseprojects.io\" , port = 0 , user = None , password = None , keepalive = 0 , ssl = False , ssl_params = {}): if port == 0 : port = 8883 if ssl else 1883 self . client_id = client_id self . sock = None self . server = server self . port = port self . ssl = ssl self . ssl_params = ssl_params self . pid = 0 self . cb = None self . user = user self . pswd = password self . keepalive = keepalive self . lw_topic = None self . lw_msg = None self . lw_qos = 0 self . lw_retain = False def _send_str ( self , s ): self . sock . write ( struct . pack ( \"!H\" , len ( s ))) self . sock . write ( s ) def _recv_len ( self ): n = 0 sh = 0 while 1 : b = self . sock . read ( 1 )[ 0 ] n |= ( b & 0x7f ) << sh if not b & 0x80 : return n sh += 7 def set_callback ( self , f ): self . cb = f def set_last_will ( self , topic , msg , retain = False , qos = 0 ): assert 0 <= qos <= 2 assert topic self . lw_topic = topic self . lw_msg = msg self . lw_qos = qos self . lw_retain = retain def connect ( self , clean_session = True ): self . sock = socket . socket () addr = socket . getaddrinfo ( self . server , self . port )[ 0 ][ - 1 ] self . sock . connect ( addr ) if self . ssl : import ussl self . sock = ussl . wrap_socket ( self . sock , ** self . ssl_params ) premsg = bytearray ( b \" \\x10\\0\\0\\0\\0\\0 \" ) msg = bytearray ( b \" \\x04 MQTT \\x04\\x02\\0\\0 \" ) sz = 10 + 2 + len ( self . client_id ) msg [ 6 ] = clean_session << 1 if self . user is not None : sz += 2 + len ( self . user ) + 2 + len ( self . pswd ) msg [ 6 ] |= 0xC0 if self . keepalive : assert self . keepalive < 65536 msg [ 7 ] |= self . keepalive >> 8 msg [ 8 ] |= self . keepalive & 0x00FF if self . lw_topic : sz += 2 + len ( self . lw_topic ) + 2 + len ( self . lw_msg ) msg [ 6 ] |= 0x4 | ( self . lw_qos & 0x1 ) << 3 | ( self . lw_qos & 0x2 ) << 3 msg [ 6 ] |= self . lw_retain << 5 i = 1 while sz > 0x7f : premsg [ i ] = ( sz & 0x7f ) | 0x80 sz >>= 7 i += 1 premsg [ i ] = sz self . sock . write ( premsg , i + 2 ) self . sock . write ( msg ) #print(hex(len(msg)), hexlify(msg, \":\")) self . _send_str ( self . client_id ) if self . lw_topic : self . _send_str ( self . lw_topic ) self . _send_str ( self . lw_msg ) if self . user is not None : self . _send_str ( self . user ) self . _send_str ( self . pswd ) resp = self . sock . read ( 4 ) assert resp [ 0 ] == 0x20 and resp [ 1 ] == 0x02 if resp [ 3 ] != 0 : raise MQTTException ( resp [ 3 ]) return resp [ 2 ] & 1 def disconnect ( self ): self . sock . write ( b \" \\xe0\\0 \" ) self . sock . close () def ping ( self ): self . sock . write ( b \" \\xc0\\0 \" ) def publish ( self , topic , msg , retain = False , qos = 0 ): pkt = bytearray ( b \" \\x30\\0\\0\\0 \" ) pkt [ 0 ] |= qos << 1 | retain sz = 2 + len ( topic ) + len ( msg ) if qos > 0 : sz += 2 assert sz < 2097152 i = 1 while sz > 0x7f : pkt [ i ] = ( sz & 0x7f ) | 0x80 sz >>= 7 i += 1 pkt [ i ] = sz #print(hex(len(pkt)), hexlify(pkt, \":\")) self . sock . write ( pkt , i + 1 ) self . _send_str ( topic ) if qos > 0 : self . pid += 1 pid = self . pid struct . pack_into ( \"!H\" , pkt , 0 , pid ) self . sock . write ( pkt , 2 ) self . sock . write ( msg ) if qos == 1 : while 1 : op = self . wait_msg () if op == 0x40 : sz = self . sock . read ( 1 ) assert sz == b \" \\x02 \" rcv_pid = self . sock . read ( 2 ) rcv_pid = rcv_pid [ 0 ] << 8 | rcv_pid [ 1 ] if pid == rcv_pid : return elif qos == 2 : assert 0 def subscribe ( self , topic , qos = 0 ): assert self . cb is not None , \"Subscribe callback is not set\" pkt = bytearray ( b \" \\x82\\0\\0\\0 \" ) self . pid += 1 struct . pack_into ( \"!BH\" , pkt , 1 , 2 + 2 + len ( topic ) + 1 , self . pid ) #print(hex(len(pkt)), hexlify(pkt, \":\")) self . sock . write ( pkt ) self . _send_str ( topic ) self . sock . write ( qos . to_bytes ( 1 , \"little\" )) while 1 : op = self . wait_msg () if op == 0x90 : resp = self . sock . read ( 4 ) #print(resp) assert resp [ 1 ] == pkt [ 2 ] and resp [ 2 ] == pkt [ 3 ] if resp [ 3 ] == 0x80 : raise MQTTException ( resp [ 3 ]) return # Wait for a single incoming MQTT message and process it. # Subscribed messages are delivered to a callback previously # set by .set_callback() method. Other (internal) MQTT # messages processed internally. def wait_msg ( self ): res = self . sock . read ( 1 ) self . sock . setblocking ( True ) if res is None : return None if res == b \"\" : raise OSError ( - 1 ) if res == b \" \\xd0 \" : # PINGRESP sz = self . sock . read ( 1 )[ 0 ] assert sz == 0 return None op = res [ 0 ] if op & 0xf0 != 0x30 : return op sz = self . _recv_len () topic_len = self . sock . read ( 2 ) topic_len = ( topic_len [ 0 ] << 8 ) | topic_len [ 1 ] topic = self . sock . read ( topic_len ) sz -= topic_len + 2 if op & 6 : pid = self . sock . read ( 2 ) pid = pid [ 0 ] << 8 | pid [ 1 ] sz -= 2 msg = self . sock . read ( sz ) self . cb ( topic , msg ) if op & 6 == 2 : pkt = bytearray ( b \" \\x40\\x02\\0\\0 \" ) struct . pack_into ( \"!H\" , pkt , 2 , pid ) self . sock . write ( pkt ) elif op & 6 == 4 : assert 0 # Checks whether a pending message from server is available. # If not, returns immediately with None. Otherwise, does # the same processing as wait_msg. def check_msg ( self ): self . sock . setblocking ( False ) return self . wait_msg () MQTT Main client The final step will be to create our main program, we should start by creating an empty file called main.py this file will be the second file to run once the system reboot/boot (the first file will be boot.py) main.py will run once we've successfully connected to the WiFi network. In main.py we will import our umqttsimple library we've created earlier and configure few data point in advance for our MQTT client to use. Unique UUID A lot of devices will connect to the broker and if we'll use a topic like \"living_room/light\" how to define our light from hundreds of other devices use the exact same topic? off course one solution will be to own our private broker, this will solve the case. but for us, we will use a public one for this example. In order to identify our device we'll need to generate a unique UUID for it, there are 2 ways to do that: use UUID generator online generate using MicroPython command For the first example, we could head to uuidgenerator.net and copy paste the automatically generated UUID for us. If we want to use the second option, here is a MicroPython example code to generate unique UUID, there are few kinds: unique based on host ID and current timestamp which is what we recommend, a UUID based on MD5 hash of a namespace (if you use this method, make sure to change steminds.com to something else, something random) and the last option to generate a random UUID. MicroPython import uuid # make a UUID based on the host ID and current time, best option. uuid_x = uuid . uuid1 () print ( uuid_x ) # make a UUID using an MD5 hash of a namespace UUID and a name uuid_y = uuid . uuid3 ( uuid . NAMESPACE_DNS , 'steminds.com' ) print ( uuid_y ) # make a random UUID uuid_z = uuid . uuid4 () print ( uuid_z ) Once you have your unique UUID we can continue to the next step of creating the actual client, make sure where it says UUID = \"YOUR_UUID_GENERATED_ID\" Replace \"YOUR_UUID_GENERATED_ID\" with your custom generated UUID. The following MQTT client will subscribe to one basic topic called \"living_room/light\" and every 1 second (where message interval is, you can change that to any number for longer or shorter interval) will publish the current light state which in our example doesn't change, it will always be 1. (light status = 1) If we'll get messages back at \"living_room/light\" topic, it will go directly to on_message_callback() function which will print the topic and message into the console. This is just an example to demonstrate a very simple and basic MQTT client and how it works. MicroPython from Eduponics import umqttsimple import machine import time import json # MQTT Unique ID UUID = \"YOUR_UUID_GENERATED_ID\" # MQTT Topics topics = [ \"living_room/light\" ] def on_message_callback ( topic , msg ): ''' get the message and topic and print it ''' print (( topic , msg )) def connect_and_subscribe (): print ( \"[-] Connecting to MQTT client ...\" ) # set the MQTT broker object client = umqttsimple . MQTTClient () # set a callback for incoming messages (subscribed topics) client . set_callback ( on_message_callback ) # connect to the broker client . connect () # subscribe to the topics for topic in topics : client . subscribe ( \" %s / %s \" % ( UUID , topic )) print ( \"[-] Subscribed to %s successfully\" % topic ) print ( \"[-] Connected to %s MQTT broker successfully\" % client . server ) return client def restart_and_reconnect (): # something went wrong, reconnect in 5 seconds ... print ( '[-] Failed to connect to MQTT broker. Reconnecting...' ) time . sleep ( 5 ) machine . reset () try : client = connect_and_subscribe () except OSError as e : restart_and_reconnect () # configure few variables last_message = 0 message_interval = 1 # dummy light status of the living room light_status = 1 while True : try : # check if there are new messages pending to be processed # if there are, redirect them to callback on_message_callback() client . check_msg () # check if the last published data wasn't less than message_interval if ( time . time () - last_message ) > message_interval : client . publish ( \" %s /home/living_room/light\" % UUID , light_status ) print ( \"[-] published light status: %s \" % light_status ) # update last message timestamp last_message = time . time () except OSError as e : # if something goes wrong, reconnect to MQTT server restart_and_reconnect () Subscribing through mosquitto CLI In order to see the published data from our ESP32 Eduponics mini kit to the MQTT broker network, we'll need to subscribe to it from our machine (your PC / laptop). Earlier on we've installed mosquitto CLI and now we are going to use it to archive it. On your machine open terminal / console and type the following: mosquitto_sub -h mqtt.eclipseprojects.io -p 1883 -t \"UUID_GOES_HERE/living_room/light\" Make sure to change the line that says: \"UUID_GOES_HERE\" With your UUID that you've generated and inserted into your ESP32 device. If everything goes well, every time the ESP32 will publish to the MQTT broker you should see it on your machine using the MQTT CLI: As we always publish the same static data (integer 1) there is nothing much to see or operate except the proof that it works, next we'll move to real life application using the Eduponics Mobile APP to receive and control the sensors on top of our Eduponics Mini board! Do you not use the UUID shown in the picture above You should generate your own unique UUID using the examples we've given earlier, failing to do so might compromise your application to strangers in real life applications.","title":"Basic MQTT client"},{"location":"kits/eduponics_mini/advance_usage/basic_mqtt_client/#basic-mqtt-client","text":"In this article we'll build a simple MQTT client that publish static data at specific interval. We'll use the \"smart home\" scenario where we have lights at home, we'll publish data through the MQTT broker and finally read the data in real time. This article doesn't have much real-life use using our Eduponics Mini but it will give you a glance and easy understand of how MQTT works. in our next article we'll integrate into our client all the Eduponics Mini sensor and send them over the MQTT network to our mobile app - The Eduponics APP.","title":"Basic MQTT client"},{"location":"kits/eduponics_mini/advance_usage/basic_mqtt_client/#install-mosquitto-cli-on-your-pcmaclinux","text":"At the end of this guide we'll be able to publish static data at interval from our Eduponics Mini to the MQTT public broker. in order to listen (subscribe) to the data and see when it goes through, we'll need to install the mosquitto CLI into our machine. The installation is fairly easy and mosquitto.org gives instructions and binary to download for each machine, follow the instructions in mosquitto.org website to install the binary that is suitable for you: MQTT mosquitto.org CLI download","title":"Install mosquitto CLI on your PC/Mac/Linux"},{"location":"kits/eduponics_mini/advance_usage/basic_mqtt_client/#connecting-eduponics-mini-to-wifi","text":"The first thing you might be asking yourself \"how does the Eduponics mini communicate with the cloud without wireless connectivity?\" Well, the good news is ESP32, the microcontroller that the Eduponics mini uses includes WiFi and Bluetooth! First thing before we even think about using the MQTT functionality is to make sure that our Eduponics Mini board can connect to the WiFi and has network connectivity so we could proceed. We can achieve this by creating boot.py file, this file will first load when our Eduponics Mini restart or the power plugged in, in this file we'll configure the WiFi credentials such as ESSID (WiFi name) and the WiFi password. Once we've connected to the WiFi using the station.connect() command, we can print our ESP32 WiFi IP address into the console. MicroPython import network import esp import time esp . osdebug ( None ) import gc gc . collect () # set WiFi credentials ssid = '' password = '' # check if there is username and password for wifi if ( ssid != '' and password != '' ): station = network . WLAN ( network . STA_IF ) station . active ( True ) station . connect ( ssid , password ) timeout_interval = 10 # try to connect with timeout interval for i in range ( 0 , timeout_interval ): if ( station . isconnected () == False ): time . sleep ( 1 ) pass else : break ; if ( station . isconnected ()): print ( 'Connected to WiFi successfully, IP: %s ' % station . ifconfig ()[ 0 ]) else : print ( \"Something went wrong, connection timeout, try again!\" ) else : print ( \"Please add WiFi credentials properly\" ) Now every time we restart or power the Eduponics Mini board it will automatically connect to the WiFi at our home. 2.54GhZ WiFi support only The ESP32 support only 2.54GhZ WiFi networks. Most of the 5Ghz WiFi routers / access points allow both 5Ghz and 2.54Ghz, make sure to choose the 2.54Ghz one.","title":"Connecting Eduponics Mini to WiFi"},{"location":"kits/eduponics_mini/advance_usage/basic_mqtt_client/#installing-the-micropython-eduponics-library","text":"The MicroPython-Eduponics library can be found on STEMinds Micropython-Eduponics repository the easist way to install the library is through uPip. Make sure to change WiFi ESSID and Password. Once the ESP32 is connected to the Wifi, run the following commands: import upip upip . install ( \"micropython-eduponics\" ) The installation should complete and once it's done you shall have a \"lib\" directory on your ESP32 device containing all the pre-requirements for this tutorial. Another way would be to grab the firmwares directly from the repository and install them into your ESP32 device using the esptool mentioned in the first tutorials.","title":"Installing the micropython-eduponics library"},{"location":"kits/eduponics_mini/advance_usage/basic_mqtt_client/#umqttsimple-class","text":"This class was taken from randomnedtutorials.com and it's extremely useful for what we are trying to achieve. this class will enable us to deal with the entire MQTT protocol (publishing and subscribing) with ease. If you look at the initialiser you'll see we give it a couple of parameters such as server (we'll use a public server at mqtt.eclipse.com ) and some other credentials we won't use such as username, password and other parameters. We should save this python code into file we'll call umqttsimple.py and we will import it using the import command every time we want to use the MQTT functionalities to communicate through the MQTT network. It's important to note that the class already exists in the micropython-eduponics library and if you followed the instructions above, you don't need to copy this class, it's for reference only. MicroPython import usocket as socket import machine import ustruct as struct from ubinascii import hexlify class MQTTException ( Exception ): pass class MQTTClient : def __init__ ( self , client_id = hexlify ( machine . unique_id ()), server = \"mqtt.eclipseprojects.io\" , port = 0 , user = None , password = None , keepalive = 0 , ssl = False , ssl_params = {}): if port == 0 : port = 8883 if ssl else 1883 self . client_id = client_id self . sock = None self . server = server self . port = port self . ssl = ssl self . ssl_params = ssl_params self . pid = 0 self . cb = None self . user = user self . pswd = password self . keepalive = keepalive self . lw_topic = None self . lw_msg = None self . lw_qos = 0 self . lw_retain = False def _send_str ( self , s ): self . sock . write ( struct . pack ( \"!H\" , len ( s ))) self . sock . write ( s ) def _recv_len ( self ): n = 0 sh = 0 while 1 : b = self . sock . read ( 1 )[ 0 ] n |= ( b & 0x7f ) << sh if not b & 0x80 : return n sh += 7 def set_callback ( self , f ): self . cb = f def set_last_will ( self , topic , msg , retain = False , qos = 0 ): assert 0 <= qos <= 2 assert topic self . lw_topic = topic self . lw_msg = msg self . lw_qos = qos self . lw_retain = retain def connect ( self , clean_session = True ): self . sock = socket . socket () addr = socket . getaddrinfo ( self . server , self . port )[ 0 ][ - 1 ] self . sock . connect ( addr ) if self . ssl : import ussl self . sock = ussl . wrap_socket ( self . sock , ** self . ssl_params ) premsg = bytearray ( b \" \\x10\\0\\0\\0\\0\\0 \" ) msg = bytearray ( b \" \\x04 MQTT \\x04\\x02\\0\\0 \" ) sz = 10 + 2 + len ( self . client_id ) msg [ 6 ] = clean_session << 1 if self . user is not None : sz += 2 + len ( self . user ) + 2 + len ( self . pswd ) msg [ 6 ] |= 0xC0 if self . keepalive : assert self . keepalive < 65536 msg [ 7 ] |= self . keepalive >> 8 msg [ 8 ] |= self . keepalive & 0x00FF if self . lw_topic : sz += 2 + len ( self . lw_topic ) + 2 + len ( self . lw_msg ) msg [ 6 ] |= 0x4 | ( self . lw_qos & 0x1 ) << 3 | ( self . lw_qos & 0x2 ) << 3 msg [ 6 ] |= self . lw_retain << 5 i = 1 while sz > 0x7f : premsg [ i ] = ( sz & 0x7f ) | 0x80 sz >>= 7 i += 1 premsg [ i ] = sz self . sock . write ( premsg , i + 2 ) self . sock . write ( msg ) #print(hex(len(msg)), hexlify(msg, \":\")) self . _send_str ( self . client_id ) if self . lw_topic : self . _send_str ( self . lw_topic ) self . _send_str ( self . lw_msg ) if self . user is not None : self . _send_str ( self . user ) self . _send_str ( self . pswd ) resp = self . sock . read ( 4 ) assert resp [ 0 ] == 0x20 and resp [ 1 ] == 0x02 if resp [ 3 ] != 0 : raise MQTTException ( resp [ 3 ]) return resp [ 2 ] & 1 def disconnect ( self ): self . sock . write ( b \" \\xe0\\0 \" ) self . sock . close () def ping ( self ): self . sock . write ( b \" \\xc0\\0 \" ) def publish ( self , topic , msg , retain = False , qos = 0 ): pkt = bytearray ( b \" \\x30\\0\\0\\0 \" ) pkt [ 0 ] |= qos << 1 | retain sz = 2 + len ( topic ) + len ( msg ) if qos > 0 : sz += 2 assert sz < 2097152 i = 1 while sz > 0x7f : pkt [ i ] = ( sz & 0x7f ) | 0x80 sz >>= 7 i += 1 pkt [ i ] = sz #print(hex(len(pkt)), hexlify(pkt, \":\")) self . sock . write ( pkt , i + 1 ) self . _send_str ( topic ) if qos > 0 : self . pid += 1 pid = self . pid struct . pack_into ( \"!H\" , pkt , 0 , pid ) self . sock . write ( pkt , 2 ) self . sock . write ( msg ) if qos == 1 : while 1 : op = self . wait_msg () if op == 0x40 : sz = self . sock . read ( 1 ) assert sz == b \" \\x02 \" rcv_pid = self . sock . read ( 2 ) rcv_pid = rcv_pid [ 0 ] << 8 | rcv_pid [ 1 ] if pid == rcv_pid : return elif qos == 2 : assert 0 def subscribe ( self , topic , qos = 0 ): assert self . cb is not None , \"Subscribe callback is not set\" pkt = bytearray ( b \" \\x82\\0\\0\\0 \" ) self . pid += 1 struct . pack_into ( \"!BH\" , pkt , 1 , 2 + 2 + len ( topic ) + 1 , self . pid ) #print(hex(len(pkt)), hexlify(pkt, \":\")) self . sock . write ( pkt ) self . _send_str ( topic ) self . sock . write ( qos . to_bytes ( 1 , \"little\" )) while 1 : op = self . wait_msg () if op == 0x90 : resp = self . sock . read ( 4 ) #print(resp) assert resp [ 1 ] == pkt [ 2 ] and resp [ 2 ] == pkt [ 3 ] if resp [ 3 ] == 0x80 : raise MQTTException ( resp [ 3 ]) return # Wait for a single incoming MQTT message and process it. # Subscribed messages are delivered to a callback previously # set by .set_callback() method. Other (internal) MQTT # messages processed internally. def wait_msg ( self ): res = self . sock . read ( 1 ) self . sock . setblocking ( True ) if res is None : return None if res == b \"\" : raise OSError ( - 1 ) if res == b \" \\xd0 \" : # PINGRESP sz = self . sock . read ( 1 )[ 0 ] assert sz == 0 return None op = res [ 0 ] if op & 0xf0 != 0x30 : return op sz = self . _recv_len () topic_len = self . sock . read ( 2 ) topic_len = ( topic_len [ 0 ] << 8 ) | topic_len [ 1 ] topic = self . sock . read ( topic_len ) sz -= topic_len + 2 if op & 6 : pid = self . sock . read ( 2 ) pid = pid [ 0 ] << 8 | pid [ 1 ] sz -= 2 msg = self . sock . read ( sz ) self . cb ( topic , msg ) if op & 6 == 2 : pkt = bytearray ( b \" \\x40\\x02\\0\\0 \" ) struct . pack_into ( \"!H\" , pkt , 2 , pid ) self . sock . write ( pkt ) elif op & 6 == 4 : assert 0 # Checks whether a pending message from server is available. # If not, returns immediately with None. Otherwise, does # the same processing as wait_msg. def check_msg ( self ): self . sock . setblocking ( False ) return self . wait_msg ()","title":"uMQTTSimple class"},{"location":"kits/eduponics_mini/advance_usage/basic_mqtt_client/#mqtt-main-client","text":"The final step will be to create our main program, we should start by creating an empty file called main.py this file will be the second file to run once the system reboot/boot (the first file will be boot.py) main.py will run once we've successfully connected to the WiFi network. In main.py we will import our umqttsimple library we've created earlier and configure few data point in advance for our MQTT client to use.","title":"MQTT Main client"},{"location":"kits/eduponics_mini/advance_usage/basic_mqtt_client/#unique-uuid","text":"A lot of devices will connect to the broker and if we'll use a topic like \"living_room/light\" how to define our light from hundreds of other devices use the exact same topic? off course one solution will be to own our private broker, this will solve the case. but for us, we will use a public one for this example. In order to identify our device we'll need to generate a unique UUID for it, there are 2 ways to do that: use UUID generator online generate using MicroPython command For the first example, we could head to uuidgenerator.net and copy paste the automatically generated UUID for us. If we want to use the second option, here is a MicroPython example code to generate unique UUID, there are few kinds: unique based on host ID and current timestamp which is what we recommend, a UUID based on MD5 hash of a namespace (if you use this method, make sure to change steminds.com to something else, something random) and the last option to generate a random UUID. MicroPython import uuid # make a UUID based on the host ID and current time, best option. uuid_x = uuid . uuid1 () print ( uuid_x ) # make a UUID using an MD5 hash of a namespace UUID and a name uuid_y = uuid . uuid3 ( uuid . NAMESPACE_DNS , 'steminds.com' ) print ( uuid_y ) # make a random UUID uuid_z = uuid . uuid4 () print ( uuid_z ) Once you have your unique UUID we can continue to the next step of creating the actual client, make sure where it says UUID = \"YOUR_UUID_GENERATED_ID\" Replace \"YOUR_UUID_GENERATED_ID\" with your custom generated UUID. The following MQTT client will subscribe to one basic topic called \"living_room/light\" and every 1 second (where message interval is, you can change that to any number for longer or shorter interval) will publish the current light state which in our example doesn't change, it will always be 1. (light status = 1) If we'll get messages back at \"living_room/light\" topic, it will go directly to on_message_callback() function which will print the topic and message into the console. This is just an example to demonstrate a very simple and basic MQTT client and how it works. MicroPython from Eduponics import umqttsimple import machine import time import json # MQTT Unique ID UUID = \"YOUR_UUID_GENERATED_ID\" # MQTT Topics topics = [ \"living_room/light\" ] def on_message_callback ( topic , msg ): ''' get the message and topic and print it ''' print (( topic , msg )) def connect_and_subscribe (): print ( \"[-] Connecting to MQTT client ...\" ) # set the MQTT broker object client = umqttsimple . MQTTClient () # set a callback for incoming messages (subscribed topics) client . set_callback ( on_message_callback ) # connect to the broker client . connect () # subscribe to the topics for topic in topics : client . subscribe ( \" %s / %s \" % ( UUID , topic )) print ( \"[-] Subscribed to %s successfully\" % topic ) print ( \"[-] Connected to %s MQTT broker successfully\" % client . server ) return client def restart_and_reconnect (): # something went wrong, reconnect in 5 seconds ... print ( '[-] Failed to connect to MQTT broker. Reconnecting...' ) time . sleep ( 5 ) machine . reset () try : client = connect_and_subscribe () except OSError as e : restart_and_reconnect () # configure few variables last_message = 0 message_interval = 1 # dummy light status of the living room light_status = 1 while True : try : # check if there are new messages pending to be processed # if there are, redirect them to callback on_message_callback() client . check_msg () # check if the last published data wasn't less than message_interval if ( time . time () - last_message ) > message_interval : client . publish ( \" %s /home/living_room/light\" % UUID , light_status ) print ( \"[-] published light status: %s \" % light_status ) # update last message timestamp last_message = time . time () except OSError as e : # if something goes wrong, reconnect to MQTT server restart_and_reconnect ()","title":"Unique UUID"},{"location":"kits/eduponics_mini/advance_usage/basic_mqtt_client/#subscribing-through-mosquitto-cli","text":"In order to see the published data from our ESP32 Eduponics mini kit to the MQTT broker network, we'll need to subscribe to it from our machine (your PC / laptop). Earlier on we've installed mosquitto CLI and now we are going to use it to archive it. On your machine open terminal / console and type the following: mosquitto_sub -h mqtt.eclipseprojects.io -p 1883 -t \"UUID_GOES_HERE/living_room/light\" Make sure to change the line that says: \"UUID_GOES_HERE\" With your UUID that you've generated and inserted into your ESP32 device. If everything goes well, every time the ESP32 will publish to the MQTT broker you should see it on your machine using the MQTT CLI: As we always publish the same static data (integer 1) there is nothing much to see or operate except the proof that it works, next we'll move to real life application using the Eduponics Mobile APP to receive and control the sensors on top of our Eduponics Mini board! Do you not use the UUID shown in the picture above You should generate your own unique UUID using the examples we've given earlier, failing to do so might compromise your application to strangers in real life applications.","title":"Subscribing through mosquitto CLI"},{"location":"kits/eduponics_mini/advance_usage/eduponics_mqtt_app/","text":"Eduponics MQTT Powered Mobile APP The Eduponics App is a special app we've developed in order to turn your kit into a complete autonomous smart watering solution. By using the app and pairing it with the Eduponics mini kit you'll be able to control your plants remotely by pumping water when needed, view sensors data in real time such as: temperature and humidity, light intensity, water quantity and off course monitoring soil moisture levels. The app can work anywhere, whenever you are at home, at work or on vocation. it doesn't require a local server or port forwarding. The app currently support the following languages: English, Hebrew, Mandarin (Chinese), Spanish, German, Ukrainian, Russian, Hindi, Portuguese The language is selected by your system language (your mobile phone language). If you'd like us to add extra translations and would like to help us translate the app for more languages, feel free to contact us! For now, only Android app version is available Although we developed both the Android and iOS version for the Eduponics app, we haven't released the iOS app yet for the apple appstore due to app regulations and application approval process, we plan to release it as soon as possible, stay tuned! Preparing the Eduponics Mini Before we'll jump directly into our app, we need to prepare our Eduponics Mini ESP32 board first with custom software that will enable our kit to connect to the MQTT broker and publish and subscribe to and from topics. In order for this tutorial to work, make sure you follow the installation instructions below to install the micropython-eduponics library on your Eduponics Mini device. Connecting Eduponics Mini to WiFi Let's repeat the same process we've used in the basic MQTT client tutorial by creating boot.py file, this file will first load when our Eduponics Mini restart or the power plugged in, in this file we'll configure the WiFi credentials such as ESSID (WiFi name) and the WiFi password. Once we've connected to the WiFi using the station.connect() command, we can print our ESP32 WiFi IP address into the console. MicroPython import network import esp import time esp . osdebug ( None ) import gc gc . collect () # set WiFi credentials ssid = '' password = '' # check if there is username and password for wifi if ( ssid != '' and password != '' ): station = network . WLAN ( network . STA_IF ) station . active ( True ) station . connect ( ssid , password ) timeout_interval = 10 # try to connect with timeout interval for i in range ( 0 , timeout_interval ): if ( station . isconnected () == False ): time . sleep ( 1 ) pass else : break ; if ( station . isconnected ()): print ( 'Connected to WiFi successfully, IP: %s ' % station . ifconfig ()[ 0 ]) else : print ( \"Something went wrong, connection timeout, try again!\" ) else : print ( \"Please add WiFi credentials properly\" ) Now every time we restart or power the Eduponics Mini board it will automatically connect to the WiFi at our home. 2.54GhZ WiFi support only Just reminding once again, the ESP32 support only 2.54GhZ WiFi networks. Most of the 5Ghz WiFi routers / access points allow both 5Ghz and 2.54Ghz, make sure to choose the 2.54Ghz one. to avoid connectivity issues make sure your network is operated on 2.54Ghz. Installing the micropython-eduponics library The MicroPython-Eduponics library can be found on STEMinds Micropython-Eduponics repository the easist way to install the library is through uPip. Make sure to change WiFi ESSID and Password. Once the ESP32 is connected to the Wifi, run the following commands: import upip upip . install ( \"micropython-eduponics\" ) The installation should complete and once it's done you shall have a \"lib\" directory on your ESP32 device containing all the pre-requirements for this tutorial. Another way would be to grab the firmwares directly from the repository and install them into your ESP32 device using the esptool mentioned in the first tutorials. Generating UUID As we've mentioned in the basic MQTT client tutorial, we could either head to uuidgenerator.net and copy paste the automatically generated UUID for us or generate it by ourselves. The UUID is used to identify our device from other devices on the MQTT network. it is crucial to generate a unique UUID and not re-use it . If we want to use the second option, here is a MicroPython example code to generate unique UUID, there are few kinds: unique based on host ID and current timestamp which is what we recommend, a UUID based on MD5 hash of a namespace (if you use this method, make sure to change steminds.com to something else, something random) and the last option to generate a random UUID. MicroPython import uuid # make a UUID based on the host ID and current time, best option. uuid_x = uuid . uuid1 () print ( uuid_x ) # make a UUID using an MD5 hash of a namespace UUID and a name uuid_y = uuid . uuid3 ( uuid . NAMESPACE_DNS , 'steminds.com' ) print ( uuid_y ) # make a random UUID uuid_z = uuid . uuid4 () print ( uuid_z ) Adding main MQTT client The main MQTT client we will use now is very different from the previous basic MQTT example we've done. In this example, we will integrate all our sensors and use them when needed, we will start by defining in our ode all the sensors such as ADC for the soil moisture sensor, light sensor, BME280 sensor and water quantity sensor. Then we'll have multiple topics, the topics we will use are: plants/soil plants/environment plants/water The plants/soil topic is used to publish soil moisture sensor data, take a look at the JSON file below: plant = { \"id\":0, \"name\":\"Plant A\", \"enabled\":1, \"moisture\":normal_reading } We can name the plant as we wish and it will show on our app, enabled can be changed between 1 or 0 which will describe if the plant can be used or not (watering functionality mainly) and inside moisture we add the soil moisture sensor values. It's import to keep the ID 0 as we use only one soil moisture, if you use the IO extension pins to add more plants, you can change the ID from 0 to 1,2,3 .. as follows: plants = [{ \"id\":0, \"name\":\"Plant A\", \"enabled\":1, \"moisture\":normal_reading },{ \"id\":1, \"name\":\"Plant B\", \"enabled\":1, \"moisture\":normal_reading_two }] In the plants/environment topic we will publish temperature, humidity, sunlight and water quantity using the rest of the sensors that are integrated in the Eduponics Mini kit. And finally plants/water will be used to subscribe instead of publishing, in our app we can press the watering icon which will water our plants, our ESP32 will receive the message from the plants/water topic and water the plants accordingly. Note in water_plant() function the following lines: # check if soil moisture is bigger than 60 if(int(json.loads(get_soil_moisture())[\"moisture\"].replace(\"%\",\"\")) > 60): # enough water, stop giving water break; We've set default of allowing to give water only if the plant has less than 60% soil moisture or if the water quantity sensor says there is no more water left. this configuration can be played with as well as to add automatic watering and not manual operation through the app. Here is the complete code, make sure to save it as main.py as this will be our main program: MicroPython \"\"\" MicroPython MQTT Eduponics APP Client https://github.com/STEMinds/micropython-eduponics MIT License Copyright (c) 2020 STEMinds Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \"\"\" from Eduponics import umqttsimple , bh1750 , bme280 import machine import time import json # set adc (analog to digital) on pin 35 adc = machine . ADC ( machine . Pin ( 35 )) # set 11dB input attenuation (voltage range roughly 0.0v - 3.6v) adc . atten ( machine . ADC . ATTN_11DB ) # Configure light sensor light_sensor = bh1750 . BH1750 () # Configure BME280 # setup I2C connection i2c = machine . I2C ( scl = machine . Pin ( 15 ), sda = machine . Pin ( 4 )) # Initialize BME280 object with default address 0x76 bme_sensor = bme280 . BME280 ( i2c = i2c ) # initialize dht object, DHT11 coonected to IO19 #d = dht.DHT11(machine.Pin(19)) # define water level sensor as INPUT on IO pin number 21 water_level = machine . Pin ( 21 , machine . Pin . IN ) # define pump on pin IO23 as OUTPUT, define pump state pump = machine . Pin ( 23 , machine . Pin . OUT ) pump_state = False # MQTT Unique ID UUID = \"YOUR_UUID_GENERATED_ID\" # MQTT Topics topics = [ \"plants/soil\" , \"plants/environment\" , \"plants/water\" ] def handle_water_level ( pin ): global pump_state # water level triggered, turn off the pump # wait for 0.3 seconds to make sure it's just a little below the water sensor # else the pump might become unstable time . sleep ( 0.3 ) pump . value ( 0 ) pump_state = False def get_soil_moisture (): # sensor min and max values # can be changed and callibrated minVal = 710 maxVal = 4095 # read soil moisture sensor data val = adc . read () # scale the value based on maxVal and minVal scale = 100 / ( minVal - maxVal ) # get calculated scale normal_reading = ( \" %s%s \" % ( int (( val - maxVal ) * scale ), \"%\" )) # we can also get inverted value if needed inverted_reading = ( \" %s%s \" % ( int (( minVal - val ) * scale ), \"%\" )) # for this example we'll return only the normal reading # put everything in a JSON format suitable for the eduponics app plant = { \"id\" : 0 , \"name\" : \"Plant A\" , \"enabled\" : 1 , \"moisture\" : normal_reading } # return the data return str ( plant ) . replace ( \"'\" , '\"' ) def get_environmental_data (): # get light from the light sensor lux = int ( light_sensor . readLight ()) # get bme280 sensor data bme280_values = bme_sensor . values temperature = bme280_values [ 0 ] . replace ( \"C\" , \"\" ) pressure = bme280_values [ 1 ] humidity = bme280_values [ 2 ] . replace ( \"%\" , \"\" ) # get DHT11 sensor data # measure sensor data #d.measure() # get temperature and humidity #temperature = d.temperature() #humidity = d.humidity() # get water quantity water_quantity = water_level . value () # put all this data into a JSON object data = { \"temp\" : temperature , \"humidity\" : humidity , \"sunlight\" : lux , \"water_quantity\" : water_quantity } return str ( data ) . replace ( \"'\" , '\"' ) def water_plant (): global pump_state if ( pump_state or water_level . value () == 1 ): # turn off the pump pump . value ( 0 ) pump_state = False else : # turn on the pump pump . value ( 1 ) pump_state = True return True def on_message_callback ( topic , msg ): ''' this is a callback, will be called when the app asks for certain information such as to water the plants when the watering button pressed ''' # convert topic and message byte to string topic = str ( topic , 'utf-8' ) msg = json . loads ( str ( msg , 'utf-8' )) if ( topic == \" %s /plants/soil\" % UUID or topic == \" %s /plants/environment\" % UUID ): # Do nothing, we only publish to those topics pass elif ( topic == \" %s /plants/water\" % UUID ): # when the app request for plant watering it goes here if ( \"key\" in msg and \"status\" in msg ): # valid request, let's process it if ( msg [ \"status\" ] == \"pending\" ): # it's waiting for us to water it, let's water it water_plant () # after watering, publish success message of watering response = { \"key\" : msg [ \"key\" ], \"status\" : \"ok\" } client . publish ( \" %s /plants/water\" % UUID , str ( response ) . replace ( \"'\" , '\"' )) else : print (( topic , msg )) def connect_and_subscribe (): print ( \"[-] Connecting to MQTT client ...\" ) # set the MQTT broker object client = umqttsimple . MQTTClient () # set a callback for incoming messages (subscribed topics) client . set_callback ( on_message_callback ) # connect to the broker client . connect () # subscribe to the topics for topic in topics : client . subscribe ( \" %s / %s \" % ( UUID , topic )) print ( \"[-] Subscribed to %s successfully\" % topic ) print ( \"[-] Connected to %s MQTT broker successfully\" % client . server ) return client def restart_and_reconnect (): # something went wrong, reconnect in 5 seconds ... print ( '[-] Failed to connect to MQTT broker. Reconnecting...' ) time . sleep ( 5 ) machine . reset () try : client = connect_and_subscribe () except OSError as e : restart_and_reconnect () # configure few variables last_message = 0 message_interval = 5 # set callback on the water level sensor, if no water stop the pump water_level . irq ( trigger = machine . Pin . IRQ_RISING , handler = handle_water_level ) while True : try : # check if there are new messages pending to be processed # if there are, redirect them to callback on_message_callback() client . check_msg () # check if the last published data wasn't less than message_interval if ( time . time () - last_message ) > message_interval : # get soil moisture soil_moisture = get_soil_moisture () # publish soil moisture data client . publish ( \" %s /plants/soil\" % UUID , soil_moisture ) #print(\"[-] published soil moisture\") # update environmetal data env = get_environmental_data () client . publish ( \" %s /plants/environment\" % UUID , env ) #print(\"[-] published evironmental data\") # update last message timestamp last_message = time . time () except OSError as e : # if something goes wrong, reconnct to MQTT server restart_and_reconnect () Changing the MQTT broker If you'd like to change the existing MQTT broker (mqtt.eclipseprojects.io) you can modify the umqttsimple.py located in the lib directory of the Eduponics library an add your custom broker of your choice. The Eduponics Mobile app support any type of broker with or without SSL support. Preparing the Eduponics APP Now once we have everything ready on our ESP32 Eduponics Mini hardware, it's time to move to the app installation and preparation. Downloading & Installing Eduponics APP Currently the app is only available on the Android store and should be able to work on most if not all Android phones. To download, search \"Eduponics\" in playstore app and you should find it right away. Alternatively you can install it directly to your phone using the web browser playstore application: Eduponics Playstore APP Connecting Eduponics APP to Eduponics Mini After downloading and launching the app successfully a popup window will show that the hardware is not initialized, this is normal and will happen on first launch of the app or if we've pressed the \"wipe data\" button in settings to wipe the internal memory of the app. In this window press \"Let's go!\" and it will take you automatically to the settings page to bind the Eduponics Mini hardware with the APP. Once we've been redirected successfully, it's time to bind the app with our hardware. In order to do so - we'll need the UUID we've generated earlier and initialized in our eduponics mini hardware, we can either type it manually or take a picture of a QR code with the UUID inside of it. Make sure to press the 'Enter' key on the virtual keyboard After you've typed the UUID completely, press the enter key on the virtual keyboard to confirm the UUID, this should complete the process. Once the virtual key entered successfully, we are now successfully connected to the same channel (the topics) as our Eduponics Mini hardware! it's time to go back to the \"Control\" tab and see if we can get real time data from our device. Now you can monitor your plant from everywhere, water it remotely and track the sensors data to make smarter decisions. As the app doesn't use any external server except the MQTT broker, you can control it even outside of your home network.","title":"Eduponics MQTT APP"},{"location":"kits/eduponics_mini/advance_usage/eduponics_mqtt_app/#eduponics-mqtt-powered-mobile-app","text":"The Eduponics App is a special app we've developed in order to turn your kit into a complete autonomous smart watering solution. By using the app and pairing it with the Eduponics mini kit you'll be able to control your plants remotely by pumping water when needed, view sensors data in real time such as: temperature and humidity, light intensity, water quantity and off course monitoring soil moisture levels. The app can work anywhere, whenever you are at home, at work or on vocation. it doesn't require a local server or port forwarding. The app currently support the following languages: English, Hebrew, Mandarin (Chinese), Spanish, German, Ukrainian, Russian, Hindi, Portuguese The language is selected by your system language (your mobile phone language). If you'd like us to add extra translations and would like to help us translate the app for more languages, feel free to contact us! For now, only Android app version is available Although we developed both the Android and iOS version for the Eduponics app, we haven't released the iOS app yet for the apple appstore due to app regulations and application approval process, we plan to release it as soon as possible, stay tuned!","title":"Eduponics MQTT Powered Mobile APP"},{"location":"kits/eduponics_mini/advance_usage/eduponics_mqtt_app/#preparing-the-eduponics-mini","text":"Before we'll jump directly into our app, we need to prepare our Eduponics Mini ESP32 board first with custom software that will enable our kit to connect to the MQTT broker and publish and subscribe to and from topics. In order for this tutorial to work, make sure you follow the installation instructions below to install the micropython-eduponics library on your Eduponics Mini device.","title":"Preparing the Eduponics Mini"},{"location":"kits/eduponics_mini/advance_usage/eduponics_mqtt_app/#connecting-eduponics-mini-to-wifi","text":"Let's repeat the same process we've used in the basic MQTT client tutorial by creating boot.py file, this file will first load when our Eduponics Mini restart or the power plugged in, in this file we'll configure the WiFi credentials such as ESSID (WiFi name) and the WiFi password. Once we've connected to the WiFi using the station.connect() command, we can print our ESP32 WiFi IP address into the console. MicroPython import network import esp import time esp . osdebug ( None ) import gc gc . collect () # set WiFi credentials ssid = '' password = '' # check if there is username and password for wifi if ( ssid != '' and password != '' ): station = network . WLAN ( network . STA_IF ) station . active ( True ) station . connect ( ssid , password ) timeout_interval = 10 # try to connect with timeout interval for i in range ( 0 , timeout_interval ): if ( station . isconnected () == False ): time . sleep ( 1 ) pass else : break ; if ( station . isconnected ()): print ( 'Connected to WiFi successfully, IP: %s ' % station . ifconfig ()[ 0 ]) else : print ( \"Something went wrong, connection timeout, try again!\" ) else : print ( \"Please add WiFi credentials properly\" ) Now every time we restart or power the Eduponics Mini board it will automatically connect to the WiFi at our home. 2.54GhZ WiFi support only Just reminding once again, the ESP32 support only 2.54GhZ WiFi networks. Most of the 5Ghz WiFi routers / access points allow both 5Ghz and 2.54Ghz, make sure to choose the 2.54Ghz one. to avoid connectivity issues make sure your network is operated on 2.54Ghz.","title":"Connecting Eduponics Mini to WiFi"},{"location":"kits/eduponics_mini/advance_usage/eduponics_mqtt_app/#installing-the-micropython-eduponics-library","text":"The MicroPython-Eduponics library can be found on STEMinds Micropython-Eduponics repository the easist way to install the library is through uPip. Make sure to change WiFi ESSID and Password. Once the ESP32 is connected to the Wifi, run the following commands: import upip upip . install ( \"micropython-eduponics\" ) The installation should complete and once it's done you shall have a \"lib\" directory on your ESP32 device containing all the pre-requirements for this tutorial. Another way would be to grab the firmwares directly from the repository and install them into your ESP32 device using the esptool mentioned in the first tutorials.","title":"Installing the micropython-eduponics library"},{"location":"kits/eduponics_mini/advance_usage/eduponics_mqtt_app/#generating-uuid","text":"As we've mentioned in the basic MQTT client tutorial, we could either head to uuidgenerator.net and copy paste the automatically generated UUID for us or generate it by ourselves. The UUID is used to identify our device from other devices on the MQTT network. it is crucial to generate a unique UUID and not re-use it . If we want to use the second option, here is a MicroPython example code to generate unique UUID, there are few kinds: unique based on host ID and current timestamp which is what we recommend, a UUID based on MD5 hash of a namespace (if you use this method, make sure to change steminds.com to something else, something random) and the last option to generate a random UUID. MicroPython import uuid # make a UUID based on the host ID and current time, best option. uuid_x = uuid . uuid1 () print ( uuid_x ) # make a UUID using an MD5 hash of a namespace UUID and a name uuid_y = uuid . uuid3 ( uuid . NAMESPACE_DNS , 'steminds.com' ) print ( uuid_y ) # make a random UUID uuid_z = uuid . uuid4 () print ( uuid_z )","title":"Generating UUID"},{"location":"kits/eduponics_mini/advance_usage/eduponics_mqtt_app/#adding-main-mqtt-client","text":"The main MQTT client we will use now is very different from the previous basic MQTT example we've done. In this example, we will integrate all our sensors and use them when needed, we will start by defining in our ode all the sensors such as ADC for the soil moisture sensor, light sensor, BME280 sensor and water quantity sensor. Then we'll have multiple topics, the topics we will use are: plants/soil plants/environment plants/water The plants/soil topic is used to publish soil moisture sensor data, take a look at the JSON file below: plant = { \"id\":0, \"name\":\"Plant A\", \"enabled\":1, \"moisture\":normal_reading } We can name the plant as we wish and it will show on our app, enabled can be changed between 1 or 0 which will describe if the plant can be used or not (watering functionality mainly) and inside moisture we add the soil moisture sensor values. It's import to keep the ID 0 as we use only one soil moisture, if you use the IO extension pins to add more plants, you can change the ID from 0 to 1,2,3 .. as follows: plants = [{ \"id\":0, \"name\":\"Plant A\", \"enabled\":1, \"moisture\":normal_reading },{ \"id\":1, \"name\":\"Plant B\", \"enabled\":1, \"moisture\":normal_reading_two }] In the plants/environment topic we will publish temperature, humidity, sunlight and water quantity using the rest of the sensors that are integrated in the Eduponics Mini kit. And finally plants/water will be used to subscribe instead of publishing, in our app we can press the watering icon which will water our plants, our ESP32 will receive the message from the plants/water topic and water the plants accordingly. Note in water_plant() function the following lines: # check if soil moisture is bigger than 60 if(int(json.loads(get_soil_moisture())[\"moisture\"].replace(\"%\",\"\")) > 60): # enough water, stop giving water break; We've set default of allowing to give water only if the plant has less than 60% soil moisture or if the water quantity sensor says there is no more water left. this configuration can be played with as well as to add automatic watering and not manual operation through the app. Here is the complete code, make sure to save it as main.py as this will be our main program: MicroPython \"\"\" MicroPython MQTT Eduponics APP Client https://github.com/STEMinds/micropython-eduponics MIT License Copyright (c) 2020 STEMinds Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \"\"\" from Eduponics import umqttsimple , bh1750 , bme280 import machine import time import json # set adc (analog to digital) on pin 35 adc = machine . ADC ( machine . Pin ( 35 )) # set 11dB input attenuation (voltage range roughly 0.0v - 3.6v) adc . atten ( machine . ADC . ATTN_11DB ) # Configure light sensor light_sensor = bh1750 . BH1750 () # Configure BME280 # setup I2C connection i2c = machine . I2C ( scl = machine . Pin ( 15 ), sda = machine . Pin ( 4 )) # Initialize BME280 object with default address 0x76 bme_sensor = bme280 . BME280 ( i2c = i2c ) # initialize dht object, DHT11 coonected to IO19 #d = dht.DHT11(machine.Pin(19)) # define water level sensor as INPUT on IO pin number 21 water_level = machine . Pin ( 21 , machine . Pin . IN ) # define pump on pin IO23 as OUTPUT, define pump state pump = machine . Pin ( 23 , machine . Pin . OUT ) pump_state = False # MQTT Unique ID UUID = \"YOUR_UUID_GENERATED_ID\" # MQTT Topics topics = [ \"plants/soil\" , \"plants/environment\" , \"plants/water\" ] def handle_water_level ( pin ): global pump_state # water level triggered, turn off the pump # wait for 0.3 seconds to make sure it's just a little below the water sensor # else the pump might become unstable time . sleep ( 0.3 ) pump . value ( 0 ) pump_state = False def get_soil_moisture (): # sensor min and max values # can be changed and callibrated minVal = 710 maxVal = 4095 # read soil moisture sensor data val = adc . read () # scale the value based on maxVal and minVal scale = 100 / ( minVal - maxVal ) # get calculated scale normal_reading = ( \" %s%s \" % ( int (( val - maxVal ) * scale ), \"%\" )) # we can also get inverted value if needed inverted_reading = ( \" %s%s \" % ( int (( minVal - val ) * scale ), \"%\" )) # for this example we'll return only the normal reading # put everything in a JSON format suitable for the eduponics app plant = { \"id\" : 0 , \"name\" : \"Plant A\" , \"enabled\" : 1 , \"moisture\" : normal_reading } # return the data return str ( plant ) . replace ( \"'\" , '\"' ) def get_environmental_data (): # get light from the light sensor lux = int ( light_sensor . readLight ()) # get bme280 sensor data bme280_values = bme_sensor . values temperature = bme280_values [ 0 ] . replace ( \"C\" , \"\" ) pressure = bme280_values [ 1 ] humidity = bme280_values [ 2 ] . replace ( \"%\" , \"\" ) # get DHT11 sensor data # measure sensor data #d.measure() # get temperature and humidity #temperature = d.temperature() #humidity = d.humidity() # get water quantity water_quantity = water_level . value () # put all this data into a JSON object data = { \"temp\" : temperature , \"humidity\" : humidity , \"sunlight\" : lux , \"water_quantity\" : water_quantity } return str ( data ) . replace ( \"'\" , '\"' ) def water_plant (): global pump_state if ( pump_state or water_level . value () == 1 ): # turn off the pump pump . value ( 0 ) pump_state = False else : # turn on the pump pump . value ( 1 ) pump_state = True return True def on_message_callback ( topic , msg ): ''' this is a callback, will be called when the app asks for certain information such as to water the plants when the watering button pressed ''' # convert topic and message byte to string topic = str ( topic , 'utf-8' ) msg = json . loads ( str ( msg , 'utf-8' )) if ( topic == \" %s /plants/soil\" % UUID or topic == \" %s /plants/environment\" % UUID ): # Do nothing, we only publish to those topics pass elif ( topic == \" %s /plants/water\" % UUID ): # when the app request for plant watering it goes here if ( \"key\" in msg and \"status\" in msg ): # valid request, let's process it if ( msg [ \"status\" ] == \"pending\" ): # it's waiting for us to water it, let's water it water_plant () # after watering, publish success message of watering response = { \"key\" : msg [ \"key\" ], \"status\" : \"ok\" } client . publish ( \" %s /plants/water\" % UUID , str ( response ) . replace ( \"'\" , '\"' )) else : print (( topic , msg )) def connect_and_subscribe (): print ( \"[-] Connecting to MQTT client ...\" ) # set the MQTT broker object client = umqttsimple . MQTTClient () # set a callback for incoming messages (subscribed topics) client . set_callback ( on_message_callback ) # connect to the broker client . connect () # subscribe to the topics for topic in topics : client . subscribe ( \" %s / %s \" % ( UUID , topic )) print ( \"[-] Subscribed to %s successfully\" % topic ) print ( \"[-] Connected to %s MQTT broker successfully\" % client . server ) return client def restart_and_reconnect (): # something went wrong, reconnect in 5 seconds ... print ( '[-] Failed to connect to MQTT broker. Reconnecting...' ) time . sleep ( 5 ) machine . reset () try : client = connect_and_subscribe () except OSError as e : restart_and_reconnect () # configure few variables last_message = 0 message_interval = 5 # set callback on the water level sensor, if no water stop the pump water_level . irq ( trigger = machine . Pin . IRQ_RISING , handler = handle_water_level ) while True : try : # check if there are new messages pending to be processed # if there are, redirect them to callback on_message_callback() client . check_msg () # check if the last published data wasn't less than message_interval if ( time . time () - last_message ) > message_interval : # get soil moisture soil_moisture = get_soil_moisture () # publish soil moisture data client . publish ( \" %s /plants/soil\" % UUID , soil_moisture ) #print(\"[-] published soil moisture\") # update environmetal data env = get_environmental_data () client . publish ( \" %s /plants/environment\" % UUID , env ) #print(\"[-] published evironmental data\") # update last message timestamp last_message = time . time () except OSError as e : # if something goes wrong, reconnct to MQTT server restart_and_reconnect ()","title":"Adding main MQTT client"},{"location":"kits/eduponics_mini/advance_usage/eduponics_mqtt_app/#changing-the-mqtt-broker","text":"If you'd like to change the existing MQTT broker (mqtt.eclipseprojects.io) you can modify the umqttsimple.py located in the lib directory of the Eduponics library an add your custom broker of your choice. The Eduponics Mobile app support any type of broker with or without SSL support.","title":"Changing the MQTT broker"},{"location":"kits/eduponics_mini/advance_usage/eduponics_mqtt_app/#preparing-the-eduponics-app","text":"Now once we have everything ready on our ESP32 Eduponics Mini hardware, it's time to move to the app installation and preparation.","title":"Preparing the Eduponics APP"},{"location":"kits/eduponics_mini/advance_usage/eduponics_mqtt_app/#downloading-installing-eduponics-app","text":"Currently the app is only available on the Android store and should be able to work on most if not all Android phones. To download, search \"Eduponics\" in playstore app and you should find it right away. Alternatively you can install it directly to your phone using the web browser playstore application: Eduponics Playstore APP","title":"Downloading &amp; Installing Eduponics APP"},{"location":"kits/eduponics_mini/advance_usage/eduponics_mqtt_app/#connecting-eduponics-app-to-eduponics-mini","text":"After downloading and launching the app successfully a popup window will show that the hardware is not initialized, this is normal and will happen on first launch of the app or if we've pressed the \"wipe data\" button in settings to wipe the internal memory of the app. In this window press \"Let's go!\" and it will take you automatically to the settings page to bind the Eduponics Mini hardware with the APP. Once we've been redirected successfully, it's time to bind the app with our hardware. In order to do so - we'll need the UUID we've generated earlier and initialized in our eduponics mini hardware, we can either type it manually or take a picture of a QR code with the UUID inside of it. Make sure to press the 'Enter' key on the virtual keyboard After you've typed the UUID completely, press the enter key on the virtual keyboard to confirm the UUID, this should complete the process. Once the virtual key entered successfully, we are now successfully connected to the same channel (the topics) as our Eduponics Mini hardware! it's time to go back to the \"Control\" tab and see if we can get real time data from our device. Now you can monitor your plant from everywhere, water it remotely and track the sensors data to make smarter decisions. As the app doesn't use any external server except the MQTT broker, you can control it even outside of your home network.","title":"Connecting Eduponics APP to Eduponics Mini"},{"location":"kits/eduponics_mini/advance_usage/introduction_to_mqtt/","text":"Introduction to MQTT MQTT is a standard for moving data between an IoT device and a server. Originally developed in 1999 by Andy Standford-Clark and Arlen Nipper to monitor oil and gas pipelines over remote satellite connections, MQTT has become the de-facto IoT standard for connecting all sorts of IoT devices. Today, all major IoT platforms, IoT cloud services providers, and many IoT edge gateways and devices support connectivity with MQTT. What is MQTT MQTT is a publish/subscribe protocol that is lightweight and requires a minimal footprint and bandwidth to connect an IoT device. Unlike HTTP\u2019s request/response paradigm, MQTT is event driven and enables messages to be pushed to clients. This type of architecture decouples the clients from each other to enable a highly scalable solution without dependencies between data producers and data consumers. When using HTTP/HTTPS you need to pull data at interval and check whenever there is new data waiting for you, the requests often contain headers and more info which make the task quite heavy for small IoT nodes that need a lightweight and fast solution. By Using MQTT, an IoT device can subscribe to a channel or publish to it (or both) when publishing a message, all the subscribed devices will get it almost instantly. MQTT Benefits Lightweight and efficient to minimize resources required for the client and network bandwidth. Enables bidirectional communication between devices and servers. Also, enabling broadcasting messages to groups of things. Scales to millions of things (devices). MQTT specifies Quality of Service (QoS) levels to support message reliability. MQTT supports persistent sessions between device and server that reduces reconnection time required over unreliable networks. MQTT messages can be encrypted with TLS and support client authentication protocols. MQTT Vocabulary When we talk about MQTT we need to clarify some vocabulary to make sure we all on the same page: MQTT - The protocol name we use to communicate between IoT devices. Message - When a device / server want to send packet of data, we call it a message. Topic - a URL where we subscribe / publish data to such as: sensors/light/ Publish - When a device want to send a message, the action of sending a message called \"Publish\". Subscribe - When a device want to listen to new incoming messages, the action is called \"Subscribe\". Broker - The MQTT Server that handle the publish/subscribe transactions Client - The end device (any IoT device that we use to send or receive messages) QoS - Quality of service, a method to give a priority to messages (which one is more important to be received or sent first) MQTT useful applications There are a lot of very useful and interesting applications that MQTT can be used for, particularly in the world of IoT. For example: Sending lightweight sensor data such as: temperature, humidity, light state etc ... Receiving sensors data and processing it Sending message to multiple (millions) of devices at the same time Receiving message in real time from a central server If this applications don't tell you much, don't worry about it. Later on in our tutorials we will focus on our Eduponics Mini kit and will learn how to send the sensors data from the ESP32 Eduponics mini board to our mobile app through a dedicated STEMinds broker we've prepared in advance. MQTT Software While MQTT is the name of the protocol itself there are huge variety of softwares we can use to implement the MQTT protocol into our code, the most popular one called \"Mosquitto\", many services and broker providers use this software and in result it has the highest community support. Eclipse Mosquitto is the freely available broker software we use to connect the Eduponics mini to the cloud and communicate with it through our dedicated Eduponics mobile app. MQTT protocol The MQTT protocol is deadly simple to use, as we've mentioned there are 2 main things we need to remember: Subscribe & Publish. MQTT Publish When we want to send data (it can be any data, such as: temperature and humidity, light, state etc ...) we use publish. The data we publish called \"Message\" and we publish it into a url like channel for example Imagine we want to turn on the living light, we can publish message to sensors/living_room/ topic with the message '1': sensors/living_room/light/1 Any other device that is subscribed to /sensors/living_room/light will receive the state 1 or 0 and will be able to process commands from there. There are couple of things to mind when designing topics, Here is a good article from HiveMQ on best practices when designing MQTT topics: MQTT Topics & Best Practices - MQTT Essentials MQTT Subscribe The other thing to mind is the Subscribe functionality, when we want to receive message that been broadcast by other devices or the server itself through the MQTT network we need to subscribe to a topic. This is fairly easy as we don't need to send any data just receive it. For example, we can subscribe to the following topic: sensors/living_room/light Any device can post a message to that topic and we'll receive it almost instantly, then we can decide what to do with the information given. should we report to the database? should we give feedback? should we just ignore it? it all depends on the application we are trying to archive. Coming up next In the next couple of lessons we'll build our first MQTT basic client and finally we'll connect our Eduponics Mini to the Eduponics Mobile APP for full functionality!","title":"Introduction to MQTT"},{"location":"kits/eduponics_mini/advance_usage/introduction_to_mqtt/#introduction-to-mqtt","text":"MQTT is a standard for moving data between an IoT device and a server. Originally developed in 1999 by Andy Standford-Clark and Arlen Nipper to monitor oil and gas pipelines over remote satellite connections, MQTT has become the de-facto IoT standard for connecting all sorts of IoT devices. Today, all major IoT platforms, IoT cloud services providers, and many IoT edge gateways and devices support connectivity with MQTT.","title":"Introduction to MQTT"},{"location":"kits/eduponics_mini/advance_usage/introduction_to_mqtt/#what-is-mqtt","text":"MQTT is a publish/subscribe protocol that is lightweight and requires a minimal footprint and bandwidth to connect an IoT device. Unlike HTTP\u2019s request/response paradigm, MQTT is event driven and enables messages to be pushed to clients. This type of architecture decouples the clients from each other to enable a highly scalable solution without dependencies between data producers and data consumers. When using HTTP/HTTPS you need to pull data at interval and check whenever there is new data waiting for you, the requests often contain headers and more info which make the task quite heavy for small IoT nodes that need a lightweight and fast solution. By Using MQTT, an IoT device can subscribe to a channel or publish to it (or both) when publishing a message, all the subscribed devices will get it almost instantly.","title":"What is MQTT"},{"location":"kits/eduponics_mini/advance_usage/introduction_to_mqtt/#mqtt-benefits","text":"Lightweight and efficient to minimize resources required for the client and network bandwidth. Enables bidirectional communication between devices and servers. Also, enabling broadcasting messages to groups of things. Scales to millions of things (devices). MQTT specifies Quality of Service (QoS) levels to support message reliability. MQTT supports persistent sessions between device and server that reduces reconnection time required over unreliable networks. MQTT messages can be encrypted with TLS and support client authentication protocols.","title":"MQTT Benefits"},{"location":"kits/eduponics_mini/advance_usage/introduction_to_mqtt/#mqtt-vocabulary","text":"When we talk about MQTT we need to clarify some vocabulary to make sure we all on the same page: MQTT - The protocol name we use to communicate between IoT devices. Message - When a device / server want to send packet of data, we call it a message. Topic - a URL where we subscribe / publish data to such as: sensors/light/ Publish - When a device want to send a message, the action of sending a message called \"Publish\". Subscribe - When a device want to listen to new incoming messages, the action is called \"Subscribe\". Broker - The MQTT Server that handle the publish/subscribe transactions Client - The end device (any IoT device that we use to send or receive messages) QoS - Quality of service, a method to give a priority to messages (which one is more important to be received or sent first)","title":"MQTT Vocabulary"},{"location":"kits/eduponics_mini/advance_usage/introduction_to_mqtt/#mqtt-useful-applications","text":"There are a lot of very useful and interesting applications that MQTT can be used for, particularly in the world of IoT. For example: Sending lightweight sensor data such as: temperature, humidity, light state etc ... Receiving sensors data and processing it Sending message to multiple (millions) of devices at the same time Receiving message in real time from a central server If this applications don't tell you much, don't worry about it. Later on in our tutorials we will focus on our Eduponics Mini kit and will learn how to send the sensors data from the ESP32 Eduponics mini board to our mobile app through a dedicated STEMinds broker we've prepared in advance.","title":"MQTT useful applications"},{"location":"kits/eduponics_mini/advance_usage/introduction_to_mqtt/#mqtt-software","text":"While MQTT is the name of the protocol itself there are huge variety of softwares we can use to implement the MQTT protocol into our code, the most popular one called \"Mosquitto\", many services and broker providers use this software and in result it has the highest community support. Eclipse Mosquitto is the freely available broker software we use to connect the Eduponics mini to the cloud and communicate with it through our dedicated Eduponics mobile app.","title":"MQTT Software"},{"location":"kits/eduponics_mini/advance_usage/introduction_to_mqtt/#mqtt-protocol","text":"The MQTT protocol is deadly simple to use, as we've mentioned there are 2 main things we need to remember: Subscribe & Publish.","title":"MQTT protocol"},{"location":"kits/eduponics_mini/advance_usage/introduction_to_mqtt/#mqtt-publish","text":"When we want to send data (it can be any data, such as: temperature and humidity, light, state etc ...) we use publish. The data we publish called \"Message\" and we publish it into a url like channel for example Imagine we want to turn on the living light, we can publish message to sensors/living_room/ topic with the message '1': sensors/living_room/light/1 Any other device that is subscribed to /sensors/living_room/light will receive the state 1 or 0 and will be able to process commands from there. There are couple of things to mind when designing topics, Here is a good article from HiveMQ on best practices when designing MQTT topics: MQTT Topics & Best Practices - MQTT Essentials","title":"MQTT Publish"},{"location":"kits/eduponics_mini/advance_usage/introduction_to_mqtt/#mqtt-subscribe","text":"The other thing to mind is the Subscribe functionality, when we want to receive message that been broadcast by other devices or the server itself through the MQTT network we need to subscribe to a topic. This is fairly easy as we don't need to send any data just receive it. For example, we can subscribe to the following topic: sensors/living_room/light Any device can post a message to that topic and we'll receive it almost instantly, then we can decide what to do with the information given. should we report to the database? should we give feedback? should we just ignore it? it all depends on the application we are trying to archive.","title":"MQTT Subscribe"},{"location":"kits/eduponics_mini/advance_usage/introduction_to_mqtt/#coming-up-next","text":"In the next couple of lessons we'll build our first MQTT basic client and finally we'll connect our Eduponics Mini to the Eduponics Mobile APP for full functionality!","title":"Coming up next"},{"location":"kits/eduponics_mini/advance_usage/water_level_based_water_pumping/","text":"Water level activated pump We've mentioned couple of times during our previous lessons that due to the characteristics of the pump - we cannot power it on outside of the water or it might get damaged. Now imagine the following scenario: you control your pump while you are not at home to water your plants but you haven't combined the pump functionality with the water quantity sensor which results in the pump pumping water when no water is presented at all! That will eventually cause damage to the pump. We are going to solve it by combining both functionalities - the pump and the the liquid sensor to determine whenever there is water or not then decide if we should allow or prevent water pumping. Getting the water level First stage will be getting the amount of water from the liquid sensor, we did it earlier but let's do it once again. Using the following code we can tell if our container is empty or full and determine if it's safe to use the pump at any given time. MicroPython import machine # define water level sensor as INPUT on IO pin number 21 water_level = machine . Pin ( 21 , machine . Pin . IN ) def is_empty (): # will return 0 if container have no water and 1 if it has water return water_level . value () if ( is_empty ()): print ( \"The water container is empty\" ) else : print ( \"The water container is full\" ) Activating the relay Next step will be to activate the relay. we also learned it previously but let's take a look again at the code to make sure we know what we are doing. Remember, the pump is powered by 12V DC adapter so make sure to plug it in when you want to use the pump functionality. MicroPython import machine import time # define pump on pin IO23 as OUTPUT pump = machine . Pin ( 23 , machine . Pin . OUT ) # turn on the pump pump . value ( 1 ) # turn off the pump pump . value ( 0 ) Final program Now when we revised previous learned lessons on how to power the pump and use the water quantity sensor - let's combine both functionalities to give water only if the bucket is not empty: MicroPython import machine import time # define pump on pin IO23 as OUTPUT pump = machine . Pin ( 23 , machine . Pin . OUT ) def is_empty (): return water_quantity . value () # define pump on pin IO23 as OUTPUT pump = machine . Pin ( 23 , machine . Pin . OUT ) # turn on the pump pump . value ( 1 ) while not is_empty (): # not empty yet, keep giving water time . sleep ( 0.1 ) # oh no, now the bucket is empty, stop it! # turn off the pump pump . value ( 0 )","title":"Water level based pump"},{"location":"kits/eduponics_mini/advance_usage/water_level_based_water_pumping/#water-level-activated-pump","text":"We've mentioned couple of times during our previous lessons that due to the characteristics of the pump - we cannot power it on outside of the water or it might get damaged. Now imagine the following scenario: you control your pump while you are not at home to water your plants but you haven't combined the pump functionality with the water quantity sensor which results in the pump pumping water when no water is presented at all! That will eventually cause damage to the pump. We are going to solve it by combining both functionalities - the pump and the the liquid sensor to determine whenever there is water or not then decide if we should allow or prevent water pumping.","title":"Water level activated pump"},{"location":"kits/eduponics_mini/advance_usage/water_level_based_water_pumping/#getting-the-water-level","text":"First stage will be getting the amount of water from the liquid sensor, we did it earlier but let's do it once again. Using the following code we can tell if our container is empty or full and determine if it's safe to use the pump at any given time. MicroPython import machine # define water level sensor as INPUT on IO pin number 21 water_level = machine . Pin ( 21 , machine . Pin . IN ) def is_empty (): # will return 0 if container have no water and 1 if it has water return water_level . value () if ( is_empty ()): print ( \"The water container is empty\" ) else : print ( \"The water container is full\" )","title":"Getting the water level"},{"location":"kits/eduponics_mini/advance_usage/water_level_based_water_pumping/#activating-the-relay","text":"Next step will be to activate the relay. we also learned it previously but let's take a look again at the code to make sure we know what we are doing. Remember, the pump is powered by 12V DC adapter so make sure to plug it in when you want to use the pump functionality. MicroPython import machine import time # define pump on pin IO23 as OUTPUT pump = machine . Pin ( 23 , machine . Pin . OUT ) # turn on the pump pump . value ( 1 ) # turn off the pump pump . value ( 0 )","title":"Activating the relay"},{"location":"kits/eduponics_mini/advance_usage/water_level_based_water_pumping/#final-program","text":"Now when we revised previous learned lessons on how to power the pump and use the water quantity sensor - let's combine both functionalities to give water only if the bucket is not empty: MicroPython import machine import time # define pump on pin IO23 as OUTPUT pump = machine . Pin ( 23 , machine . Pin . OUT ) def is_empty (): return water_quantity . value () # define pump on pin IO23 as OUTPUT pump = machine . Pin ( 23 , machine . Pin . OUT ) # turn on the pump pump . value ( 1 ) while not is_empty (): # not empty yet, keep giving water time . sleep ( 0.1 ) # oh no, now the bucket is empty, stop it! # turn off the pump pump . value ( 0 )","title":"Final program"},{"location":"kits/eduponics_mini/basic_sensors_usage/bme280_temperature_and_humidity/","text":"BME280 Temperature & Humidity sensor The Bosch BME280 sensor is a humidity, temperature and barometric pressure sensor especially developed for mobile applications and wearables where size and low power consumption are key design parameters. The unit combines high linearity and high accuracy sensors and is perfectly feasible for low current consumption, long-term stability and high EMC robustness. The combined sensor offers an extremely fast response time and therefore supports performance requirements for emerging applications such as context awareness, and high accuracy over a wide temperature range. Specifications 3 in 1 - temperature, humidity and barometric pressure Low power consumption Extremely fast and accurate temperature, humidity and pressure reading Barometric pressure operation range 300-1100hPa, temperature operation range -40-85\u00b0C. The humidity range is 0-100% real humidity. 10 Years lifespan. View the complete datasheet at Bosch website: BME280 3 in 1 sensor datasheet Possible applications Some of the great possible applications we can use the BME280 for are: Temperature and humidity measurement Barometric pressure measurement Measuring approximate height using the barometric sensor Weather station Indoor air quality monitoring Smart agriculture Green house monitoring Hardware explanation There is not much information on the inside of the BME280 IC (integrated circuit) we guess it's because its Bosch patented technology. what we do know is that the tiny IC integrates 3 features inside and we can use the I2C protocol to read data from it. In the schematic above we can see how we've connected the BME280 to our Eduponics mini ESP32 board (MCU is where our ESP32 is). The BME280 requires only 1.8V voltage of operation, extremely low in power requirements as well as power consumption. Next, we'll learn by code example how we can read the data from the sensor and use it for our own needs. Software explanation Make sure micropython-eduponics is installed through upip For our Python code, we will need to import eduponics library, make sure you followed the introduction guide on installing the library on the ESP32 Eduponics Mini board. For the following code create a new file and call it bme.py using Thonny IDE and copy paste the code into it. if we walk through the code, it's basically based on the BME280 Bosch schematics and communication methods using the I2C protocol, we have functions to read humidity, temperature and air pressure. all the functions in this code are commented and easy to understand what's going on. In our main code we import the library (make sure you've installed micropython-eduponics through upip) by calling from eduponics import bme280. Then we need to configure the I2C connection which in our case is SCL Pin 15 and SDA pin 4, we can initalize the bme280 sensor object using those I2C credentials, we don't need to supply address because the library already includes the default address which is 0x76. Now what left to do is to loop every second and read the sensor values. We can get pretty interesting data such as: temperature, humidity, pressure, sea level and even altitude which is calculate using the air pressure! If you are wondering how, it's called The Barometric Formula . MicroPython \"\"\" MicroPython BME280 temperature, humidity and air-pressure sensor https://github.com/STEMinds/eduponics-mini MIT License Copyright (c) 2020 STEMinds Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \"\"\" from machine import I2C , Pin from Eduponics import bme280 from utime import sleep # setup I2C connection i2c = I2C ( scl = Pin ( 15 ), sda = Pin ( 4 )) # Initialize BME280 object with default address 0x76 bme280 = bme280 . BME280 ( i2c = i2c ) while True : # get the values from the BME280 library values = bme280 . values altitude = bme280 . altitude dew_point = bme280 . dew_point sea_level = bme280 . sealevel # print the values every 1 second print ( \"------------------------\" ) print ( \"Temperature: %s \" % values [ 0 ]) print ( \"Humidity: %s \" % values [ 1 ]) print ( \"Pressure: %s \" % values [ 2 ]) print ( \"Altitude: %s \" % altitude ) print ( \"Dew point: %s \" % dew_point ) print ( \"Sea level: %s \" % sea_level ) print ( \"------------------------\" ) print ( \"\" ) sleep ( 1 ) In Arduino IDE it would be differently, we can use the Adafruit libraries that are included in our Eduponics-Mini git repository to import them directly and write a shorter code: ESP32-Arduino #include <Wire.h> #include <Adafruit_Sensor.h> #include <Adafruit_BME280.h> #define SEALEVELPRESSURE_HPA (1013.25) Adafruit_BME280 bme ; // I2C communication object unsigned long delayTime ; void setup () { // start serial communication Serial . begin ( 115200 ); // start I2C on pins 4 and 15 Wire . begin ( 4 , 15 ); // start BME280 sensor on address 0x76 bme . begin ( 0x76 ); delayTime = 1000 ; } void loop () { printValues (); delay ( delayTime ); } void printValues () { Serial . print ( \"Temperature = \" ); Serial . print ( bme . readTemperature ()); Serial . println ( \" *C\" ); // Convert temperature to Fahrenheit /*Serial.print(\"Temperature = \"); Serial.print(1.8 * bme.readTemperature() + 32); Serial.println(\" *F\");*/ Serial . print ( \"Pressure = \" ); Serial . print ( bme . readPressure () / 100.0F ); Serial . println ( \" hPa\" ); Serial . print ( \"Approx. Altitude = \" ); Serial . print ( bme . readAltitude ( SEALEVELPRESSURE_HPA )); Serial . println ( \" m\" ); Serial . print ( \"Humidity = \" ); Serial . print ( bme . readHumidity ()); Serial . println ( \" %\" ); Serial . println (); }","title":"BME280 sensor"},{"location":"kits/eduponics_mini/basic_sensors_usage/bme280_temperature_and_humidity/#bme280-temperature-humidity-sensor","text":"The Bosch BME280 sensor is a humidity, temperature and barometric pressure sensor especially developed for mobile applications and wearables where size and low power consumption are key design parameters. The unit combines high linearity and high accuracy sensors and is perfectly feasible for low current consumption, long-term stability and high EMC robustness. The combined sensor offers an extremely fast response time and therefore supports performance requirements for emerging applications such as context awareness, and high accuracy over a wide temperature range.","title":"BME280 Temperature &amp; Humidity sensor"},{"location":"kits/eduponics_mini/basic_sensors_usage/bme280_temperature_and_humidity/#specifications","text":"3 in 1 - temperature, humidity and barometric pressure Low power consumption Extremely fast and accurate temperature, humidity and pressure reading Barometric pressure operation range 300-1100hPa, temperature operation range -40-85\u00b0C. The humidity range is 0-100% real humidity. 10 Years lifespan. View the complete datasheet at Bosch website: BME280 3 in 1 sensor datasheet","title":"Specifications"},{"location":"kits/eduponics_mini/basic_sensors_usage/bme280_temperature_and_humidity/#possible-applications","text":"Some of the great possible applications we can use the BME280 for are: Temperature and humidity measurement Barometric pressure measurement Measuring approximate height using the barometric sensor Weather station Indoor air quality monitoring Smart agriculture Green house monitoring","title":"Possible applications"},{"location":"kits/eduponics_mini/basic_sensors_usage/bme280_temperature_and_humidity/#hardware-explanation","text":"There is not much information on the inside of the BME280 IC (integrated circuit) we guess it's because its Bosch patented technology. what we do know is that the tiny IC integrates 3 features inside and we can use the I2C protocol to read data from it. In the schematic above we can see how we've connected the BME280 to our Eduponics mini ESP32 board (MCU is where our ESP32 is). The BME280 requires only 1.8V voltage of operation, extremely low in power requirements as well as power consumption. Next, we'll learn by code example how we can read the data from the sensor and use it for our own needs.","title":"Hardware explanation"},{"location":"kits/eduponics_mini/basic_sensors_usage/bme280_temperature_and_humidity/#software-explanation","text":"Make sure micropython-eduponics is installed through upip For our Python code, we will need to import eduponics library, make sure you followed the introduction guide on installing the library on the ESP32 Eduponics Mini board. For the following code create a new file and call it bme.py using Thonny IDE and copy paste the code into it. if we walk through the code, it's basically based on the BME280 Bosch schematics and communication methods using the I2C protocol, we have functions to read humidity, temperature and air pressure. all the functions in this code are commented and easy to understand what's going on. In our main code we import the library (make sure you've installed micropython-eduponics through upip) by calling from eduponics import bme280. Then we need to configure the I2C connection which in our case is SCL Pin 15 and SDA pin 4, we can initalize the bme280 sensor object using those I2C credentials, we don't need to supply address because the library already includes the default address which is 0x76. Now what left to do is to loop every second and read the sensor values. We can get pretty interesting data such as: temperature, humidity, pressure, sea level and even altitude which is calculate using the air pressure! If you are wondering how, it's called The Barometric Formula . MicroPython \"\"\" MicroPython BME280 temperature, humidity and air-pressure sensor https://github.com/STEMinds/eduponics-mini MIT License Copyright (c) 2020 STEMinds Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \"\"\" from machine import I2C , Pin from Eduponics import bme280 from utime import sleep # setup I2C connection i2c = I2C ( scl = Pin ( 15 ), sda = Pin ( 4 )) # Initialize BME280 object with default address 0x76 bme280 = bme280 . BME280 ( i2c = i2c ) while True : # get the values from the BME280 library values = bme280 . values altitude = bme280 . altitude dew_point = bme280 . dew_point sea_level = bme280 . sealevel # print the values every 1 second print ( \"------------------------\" ) print ( \"Temperature: %s \" % values [ 0 ]) print ( \"Humidity: %s \" % values [ 1 ]) print ( \"Pressure: %s \" % values [ 2 ]) print ( \"Altitude: %s \" % altitude ) print ( \"Dew point: %s \" % dew_point ) print ( \"Sea level: %s \" % sea_level ) print ( \"------------------------\" ) print ( \"\" ) sleep ( 1 ) In Arduino IDE it would be differently, we can use the Adafruit libraries that are included in our Eduponics-Mini git repository to import them directly and write a shorter code: ESP32-Arduino #include <Wire.h> #include <Adafruit_Sensor.h> #include <Adafruit_BME280.h> #define SEALEVELPRESSURE_HPA (1013.25) Adafruit_BME280 bme ; // I2C communication object unsigned long delayTime ; void setup () { // start serial communication Serial . begin ( 115200 ); // start I2C on pins 4 and 15 Wire . begin ( 4 , 15 ); // start BME280 sensor on address 0x76 bme . begin ( 0x76 ); delayTime = 1000 ; } void loop () { printValues (); delay ( delayTime ); } void printValues () { Serial . print ( \"Temperature = \" ); Serial . print ( bme . readTemperature ()); Serial . println ( \" *C\" ); // Convert temperature to Fahrenheit /*Serial.print(\"Temperature = \"); Serial.print(1.8 * bme.readTemperature() + 32); Serial.println(\" *F\");*/ Serial . print ( \"Pressure = \" ); Serial . print ( bme . readPressure () / 100.0F ); Serial . println ( \" hPa\" ); Serial . print ( \"Approx. Altitude = \" ); Serial . print ( bme . readAltitude ( SEALEVELPRESSURE_HPA )); Serial . println ( \" m\" ); Serial . print ( \"Humidity = \" ); Serial . print ( bme . readHumidity ()); Serial . println ( \" %\" ); Serial . println (); }","title":"Software explanation"},{"location":"kits/eduponics_mini/basic_sensors_usage/deep_sleep_wakeup/","text":"Wakeup from Deep sleep Having the Eduponics Mini ESP32 board running on active mode with batteries it\u2019s not ideal, since the power from batteries will drain very quickly. If you put the board in deep sleep mode, it will reduce the power consumption and your batteries will last longer. Having the board in deep sleep mode means cutting with the activities that consume more power while operating but leave just enough activity to wake up the processor when something interesting happens. When operating in deep sleep mode, the board have a current consumption on the \u03bcA range. With a custom and carefully designed board you can get a minimal consumption of about 5 \u03bcA. This feature is very specific to the ESP32 other boards such as Arduino or Raspberry Pi don't have this deep sleep functionality thus not suitable for outdoor / battery powered applications. Wakeup sources There are multiple ways that ESP32 can wakeup from a deep sleep, such as: Timer - using ESP32 internal RTC to count and wakeup after x seconds External wakeup - we'v dedicated a \"wakeup\" button on the Eduponics mini board for this purpose. touch pins - waking up by connecting touch button to the board In our tutorial we'll focus on waking up by push of a button, this is useful if you want to check sensors data on the Eduponics mini board by pressing it from time to time let's say when you come home every day, this can be extremely beneficial for the battery life if you power the board with an external battery. Waking up by button press We've integrated a special button on the top right side of the Eduponics mini board, it's just a simple button that is connected to IO PIN number 36, technically this button can be used for anything but we've decided to dedicate it for a special use which is waking up from deep sleep. Before we go into deep sleep we must set a wake up input, failing to do so will cause our board to go into infinite loop where it wakes up and goes back to sleep. We can do it by the function called .wake_on_ext0() supply the wakeup pin which is IO PIN 36 which we configured as input and wakeup any high means any type of button touch (LOW OR HIGH) the board will wakeup. After configuring the button, it's safe to continue writing the software and when we ready to put the board to sleep we can use machine.deepsleep() to enter deep sleeping state, once the button is pressed the board will restart and initialize the program again. MicroPython ESP32-Arduino import esp32 from machine import Pin from time import sleep wake_up = Pin ( 36 , mode = Pin . IN ) #level parameter can be: esp32.WAKEUP_ANY_HIGH or esp32.WAKEUP_ALL_LOW esp32 . wake_on_ext0 ( pin = wake_up , level = esp32 . WAKEUP_ANY_HIGH ) #your main code goes here to perform a task print ( 'Im awake now. Going to sleep in 5 seconds ...' ) sleep ( 5 ) print ( 'Going to sleep now ..' ) #once the main code finished, we can set the program to enter deep-sleep machine . deepsleep () /* Deep Sleep with External Wake Up ===================================== This code displays how to use deep sleep with an external trigger as a wake up source and how to store data in RTC memory to use it over reboots This code is under Public Domain License. Hardware Connections ====================== Push Button to GPIO 33 pulled down with a 10K Ohm resistor NOTE: ====== Only RTC IO can be used as a source for external wake source. They are pins: 0,2,4,12-15,25-27,32-39. Author: Pranav Cherukupalli <cherukupallip@gmail.com> */ #define BUTTON_PIN_BITMASK 0x200000000 // 2^33 in hex RTC_DATA_ATTR int bootCount = 0 ; /* Method to print the reason by which ESP32 has been awaken from sleep */ void print_wakeup_reason (){ esp_sleep_wakeup_cause_t wakeup_reason ; wakeup_reason = esp_sleep_get_wakeup_cause (); switch ( wakeup_reason ) { case ESP_SLEEP_WAKEUP_EXT0 : Serial . println ( \"Wakeup caused by external signal using RTC_IO\" ); break ; case ESP_SLEEP_WAKEUP_EXT1 : Serial . println ( \"Wakeup caused by external signal using RTC_CNTL\" ); break ; case ESP_SLEEP_WAKEUP_TIMER : Serial . println ( \"Wakeup caused by timer\" ); break ; case ESP_SLEEP_WAKEUP_TOUCHPAD : Serial . println ( \"Wakeup caused by touchpad\" ); break ; case ESP_SLEEP_WAKEUP_ULP : Serial . println ( \"Wakeup caused by ULP program\" ); break ; default : Serial . printf ( \"Wakeup was not caused by deep sleep: %d \\n \" , wakeup_reason ); break ; } } void setup (){ Serial . begin ( 115200 ); delay ( 1000 ); //Take some time to open up the Serial Monitor //Increment boot number and print it every reboot ++ bootCount ; Serial . println ( \"Boot number: \" + String ( bootCount )); //Print the wakeup reason for ESP32 print_wakeup_reason (); /* First we configure the wake up source We set our ESP32 to wake up for an external trigger. There are two types for ESP32, ext0 and ext1 . ext0 uses RTC_IO to wakeup thus requires RTC peripherals to be on while ext1 uses RTC Controller so doesnt need peripherals to be powered on. Note that using internal pullups/pulldowns also requires RTC peripherals to be turned on. */ esp_sleep_enable_ext0_wakeup ( GPIO_NUM_36 , 1 ); //1 = High, 0 = Low //If you were to use ext1, you would use it like //esp_sleep_enable_ext1_wakeup(BUTTON_PIN_BITMASK,ESP_EXT1_WAKEUP_ANY_HIGH); //Go to sleep now Serial . println ( \"Going to sleep now\" ); delay ( 1000 ); esp_deep_sleep_start (); Serial . println ( \"This will never be printed\" ); } void loop (){ //This is not going to be called } Must set button input or any wake up input before going to deep sleep Failing to do so will cause infinite loop where when the board wakes up it goes back to sleep right away, it won't be possible to re-program it unless we'll clean the memory and write the firmware again.","title":"Deep sleep wakeup"},{"location":"kits/eduponics_mini/basic_sensors_usage/deep_sleep_wakeup/#wakeup-from-deep-sleep","text":"Having the Eduponics Mini ESP32 board running on active mode with batteries it\u2019s not ideal, since the power from batteries will drain very quickly. If you put the board in deep sleep mode, it will reduce the power consumption and your batteries will last longer. Having the board in deep sleep mode means cutting with the activities that consume more power while operating but leave just enough activity to wake up the processor when something interesting happens. When operating in deep sleep mode, the board have a current consumption on the \u03bcA range. With a custom and carefully designed board you can get a minimal consumption of about 5 \u03bcA. This feature is very specific to the ESP32 other boards such as Arduino or Raspberry Pi don't have this deep sleep functionality thus not suitable for outdoor / battery powered applications.","title":"Wakeup from Deep sleep"},{"location":"kits/eduponics_mini/basic_sensors_usage/deep_sleep_wakeup/#wakeup-sources","text":"There are multiple ways that ESP32 can wakeup from a deep sleep, such as: Timer - using ESP32 internal RTC to count and wakeup after x seconds External wakeup - we'v dedicated a \"wakeup\" button on the Eduponics mini board for this purpose. touch pins - waking up by connecting touch button to the board In our tutorial we'll focus on waking up by push of a button, this is useful if you want to check sensors data on the Eduponics mini board by pressing it from time to time let's say when you come home every day, this can be extremely beneficial for the battery life if you power the board with an external battery.","title":"Wakeup sources"},{"location":"kits/eduponics_mini/basic_sensors_usage/deep_sleep_wakeup/#waking-up-by-button-press","text":"We've integrated a special button on the top right side of the Eduponics mini board, it's just a simple button that is connected to IO PIN number 36, technically this button can be used for anything but we've decided to dedicate it for a special use which is waking up from deep sleep. Before we go into deep sleep we must set a wake up input, failing to do so will cause our board to go into infinite loop where it wakes up and goes back to sleep. We can do it by the function called .wake_on_ext0() supply the wakeup pin which is IO PIN 36 which we configured as input and wakeup any high means any type of button touch (LOW OR HIGH) the board will wakeup. After configuring the button, it's safe to continue writing the software and when we ready to put the board to sleep we can use machine.deepsleep() to enter deep sleeping state, once the button is pressed the board will restart and initialize the program again. MicroPython ESP32-Arduino import esp32 from machine import Pin from time import sleep wake_up = Pin ( 36 , mode = Pin . IN ) #level parameter can be: esp32.WAKEUP_ANY_HIGH or esp32.WAKEUP_ALL_LOW esp32 . wake_on_ext0 ( pin = wake_up , level = esp32 . WAKEUP_ANY_HIGH ) #your main code goes here to perform a task print ( 'Im awake now. Going to sleep in 5 seconds ...' ) sleep ( 5 ) print ( 'Going to sleep now ..' ) #once the main code finished, we can set the program to enter deep-sleep machine . deepsleep () /* Deep Sleep with External Wake Up ===================================== This code displays how to use deep sleep with an external trigger as a wake up source and how to store data in RTC memory to use it over reboots This code is under Public Domain License. Hardware Connections ====================== Push Button to GPIO 33 pulled down with a 10K Ohm resistor NOTE: ====== Only RTC IO can be used as a source for external wake source. They are pins: 0,2,4,12-15,25-27,32-39. Author: Pranav Cherukupalli <cherukupallip@gmail.com> */ #define BUTTON_PIN_BITMASK 0x200000000 // 2^33 in hex RTC_DATA_ATTR int bootCount = 0 ; /* Method to print the reason by which ESP32 has been awaken from sleep */ void print_wakeup_reason (){ esp_sleep_wakeup_cause_t wakeup_reason ; wakeup_reason = esp_sleep_get_wakeup_cause (); switch ( wakeup_reason ) { case ESP_SLEEP_WAKEUP_EXT0 : Serial . println ( \"Wakeup caused by external signal using RTC_IO\" ); break ; case ESP_SLEEP_WAKEUP_EXT1 : Serial . println ( \"Wakeup caused by external signal using RTC_CNTL\" ); break ; case ESP_SLEEP_WAKEUP_TIMER : Serial . println ( \"Wakeup caused by timer\" ); break ; case ESP_SLEEP_WAKEUP_TOUCHPAD : Serial . println ( \"Wakeup caused by touchpad\" ); break ; case ESP_SLEEP_WAKEUP_ULP : Serial . println ( \"Wakeup caused by ULP program\" ); break ; default : Serial . printf ( \"Wakeup was not caused by deep sleep: %d \\n \" , wakeup_reason ); break ; } } void setup (){ Serial . begin ( 115200 ); delay ( 1000 ); //Take some time to open up the Serial Monitor //Increment boot number and print it every reboot ++ bootCount ; Serial . println ( \"Boot number: \" + String ( bootCount )); //Print the wakeup reason for ESP32 print_wakeup_reason (); /* First we configure the wake up source We set our ESP32 to wake up for an external trigger. There are two types for ESP32, ext0 and ext1 . ext0 uses RTC_IO to wakeup thus requires RTC peripherals to be on while ext1 uses RTC Controller so doesnt need peripherals to be powered on. Note that using internal pullups/pulldowns also requires RTC peripherals to be turned on. */ esp_sleep_enable_ext0_wakeup ( GPIO_NUM_36 , 1 ); //1 = High, 0 = Low //If you were to use ext1, you would use it like //esp_sleep_enable_ext1_wakeup(BUTTON_PIN_BITMASK,ESP_EXT1_WAKEUP_ANY_HIGH); //Go to sleep now Serial . println ( \"Going to sleep now\" ); delay ( 1000 ); esp_deep_sleep_start (); Serial . println ( \"This will never be printed\" ); } void loop (){ //This is not going to be called } Must set button input or any wake up input before going to deep sleep Failing to do so will cause infinite loop where when the board wakes up it goes back to sleep right away, it won't be possible to re-program it unless we'll clean the memory and write the firmware again.","title":"Waking up by button press"},{"location":"kits/eduponics_mini/basic_sensors_usage/dht11_temperature_and_humidity/","text":"DHT11 Temperature & Humidity sensor DHT11 Temperature & Humidity Sensor features a temperature & humidity sensor complex with a calibrated digital signal output. By using the exclusive digital-signal-acquisition technique and temperature & humidity sensing technology, it ensures high reliability and excellent long-term stability. This sensor includes a resistive-type humidity measurement component and an NTC temperature measurement component, and connects to a high performance 8-bit microcontroller, offering excellent quality, fast response, anti-interference ability and cost-effectiveness DHT11 sensor is not included with the kit We've decided to replace the DHT11 with BME280 due to BME280 being a better, high accuracy sensor with more features. However, we've left the ports available so you could solder your own DHT sensor if you wish. The location of the pins are (4 pins) are right below the BME280 sensor on the Eduponics Mini board. Comparison to BME280 When we've tested multiple temperature and humidity sensors to add to the kit we've decided to not let quality and performance down. The DHT11 is simple to use and easy to learn sensor but not suitable for applications that require high sensitivity and reliability. We haven't included DHT11 with the kit but we left an available pins to connect one if you wish, BME280 is more sufficient, accurate and suitable for long term industrial real life applications. Specifications Each DHT11 sensor is calibrated in a special laboratory that is extremely accurate on humidity calibration. The calibration coefficients are stored in the program OTP memory, which is used by the sensor\u2019s internal signal detecting process. The single-wire serial interface makes system integration quick and easy. Its small size, low power consumption, and up-to-20 meter signal transmission making it the best choice for various applications, including those most demanding ones. The component is a 4-pin single row pin package. Here are some of the main specifications you'll need to know about the DHT11 sensor: 1% resolution, for example it's possible to get 25\u00b0C but not 25.3\u00b0C Good for 20-80% humidity readings with 5% accuracy Good for 0-50\u00b0C temperature readings \u00b12\u00b0C accuracy No more than 1 Hz sampling rate (once every second) The complete data sheet for DHT11 can be found here: Mouser.com DHT11 datasheet Possible applications The DHT11 is very useful sensor often used in environment related projects such as: Weather station Indoor air quality monitoring Smart agriculture Green house monitoring We will use the DHT11 to measure the environment around our plant, making sure it's not too cold and not too hot either. Regarding the humidity, multiple actions can be taken such as alert, automatic window opener and more. Hardware explanation The DHT11 sensor can measure both temperature and humidity. The temperature is measured with the help of a NTC thermistor or negative temperature coefficient thermistor. These thermistors are usually made with semiconductors, ceramic and polymers. The resistance of the device is inversely proportional with temperature and follows a hyperbolic curve. Temperature using NTC often found out Steinhart Hart equation . The sensor's humidity determined using a moisture dependent resistor. It has two electrodes with a moisture-holding substrate between them that holds the moisture. The result is the conductance and resistance change as the humidity changes. Both these temperatures and humidity changes analyzed by an IC placed on the other side of the board. It calculates the values of both and can transmit those values to a microcontroller using only a single data line. Software explanation Controlling the DHT11 is very easy due to the internal MicroPython supported library DHT. The only thing we need is to import the DHT library that is built-in in MicroPython and initialize it using dht.DHT11() with the PIN that we use. In our case, the Eduponics Mini uses IO PIN 19 for the DHT11 sensor. Then, we'll use the measure function to measure the temperature and humidity, put them into variables, and finally print them on screen. If you prefer Fahrenheit instead of Celcius, make sure to uncomment the conversion lines. MicroPython ESP32-Arduino import dht import machine # initialize dht object, DHT11 coonected to IO19 d = dht . DHT11 ( machine . Pin ( 19 )) # measure sensor data d . measure () # get data temp = d . temperature () humidity = d . humidity () # uncomment for temperature in Fahrenheit #temp = (temp / 100) * (9/5) + 32 #temp = str(round(temp, 2)) # print temperature and humidity print ( \"temperature : %s \" % temp ) print ( \"humidity : %s \" % humidity ) #include \"DHT.h\" #define DHTPIN 19 // Digital pin connected to the DHT sensor // Uncomment whatever type you're using! #define DHTTYPE DHT11 // DHT 11 //#define DHTTYPE DHT22 // DHT 22 (AM2302), AM2321 //#define DHTTYPE DHT21 // DHT 21 (AM2301) // Initialize DHT sensor. // Note that older versions of this library took an optional third parameter to // tweak the timings for faster processors. This parameter is no longer needed // as the current DHT reading algorithm adjusts itself to work on faster procs. DHT dht ( DHTPIN , DHTTYPE ); void setup () { Serial . begin ( 115200 ); Serial . println ( F ( \"DHTxx test!\" )); dht . begin (); } void loop () { // Wait a few seconds between measurements. delay ( 2000 ); // Reading temperature or humidity takes about 250 milliseconds! // Sensor readings may also be up to 2 seconds 'old' (its a very slow sensor) float h = dht . readHumidity (); // Read temperature as Celsius (the default) float t = dht . readTemperature (); // Read temperature as Fahrenheit (isFahrenheit = true) float f = dht . readTemperature ( true ); // Check if any reads failed and exit early (to try again). if ( isnan ( h ) || isnan ( t ) || isnan ( f )) { Serial . println ( F ( \"Failed to read from DHT sensor!\" )); return ; } // Compute heat index in Fahrenheit (the default) float hif = dht . computeHeatIndex ( f , h ); // Compute heat index in Celsius (isFahreheit = false) float hic = dht . computeHeatIndex ( t , h , false ); Serial . print ( F ( \"Humidity: \" )); Serial . print ( h ); Serial . print ( F ( \"% Temperature: \" )); Serial . print ( t ); Serial . print ( F ( \"\u00b0C \" )); Serial . print ( f ); Serial . print ( F ( \"\u00b0F Heat index: \" )); Serial . print ( hic ); Serial . print ( F ( \"\u00b0C \" )); Serial . print ( hif ); Serial . println ( F ( \"\u00b0F\" )); }","title":"DHT11 sensor"},{"location":"kits/eduponics_mini/basic_sensors_usage/dht11_temperature_and_humidity/#dht11-temperature-humidity-sensor","text":"DHT11 Temperature & Humidity Sensor features a temperature & humidity sensor complex with a calibrated digital signal output. By using the exclusive digital-signal-acquisition technique and temperature & humidity sensing technology, it ensures high reliability and excellent long-term stability. This sensor includes a resistive-type humidity measurement component and an NTC temperature measurement component, and connects to a high performance 8-bit microcontroller, offering excellent quality, fast response, anti-interference ability and cost-effectiveness DHT11 sensor is not included with the kit We've decided to replace the DHT11 with BME280 due to BME280 being a better, high accuracy sensor with more features. However, we've left the ports available so you could solder your own DHT sensor if you wish. The location of the pins are (4 pins) are right below the BME280 sensor on the Eduponics Mini board.","title":"DHT11 Temperature &amp; Humidity sensor"},{"location":"kits/eduponics_mini/basic_sensors_usage/dht11_temperature_and_humidity/#comparison-to-bme280","text":"When we've tested multiple temperature and humidity sensors to add to the kit we've decided to not let quality and performance down. The DHT11 is simple to use and easy to learn sensor but not suitable for applications that require high sensitivity and reliability. We haven't included DHT11 with the kit but we left an available pins to connect one if you wish, BME280 is more sufficient, accurate and suitable for long term industrial real life applications.","title":"Comparison to BME280"},{"location":"kits/eduponics_mini/basic_sensors_usage/dht11_temperature_and_humidity/#specifications","text":"Each DHT11 sensor is calibrated in a special laboratory that is extremely accurate on humidity calibration. The calibration coefficients are stored in the program OTP memory, which is used by the sensor\u2019s internal signal detecting process. The single-wire serial interface makes system integration quick and easy. Its small size, low power consumption, and up-to-20 meter signal transmission making it the best choice for various applications, including those most demanding ones. The component is a 4-pin single row pin package. Here are some of the main specifications you'll need to know about the DHT11 sensor: 1% resolution, for example it's possible to get 25\u00b0C but not 25.3\u00b0C Good for 20-80% humidity readings with 5% accuracy Good for 0-50\u00b0C temperature readings \u00b12\u00b0C accuracy No more than 1 Hz sampling rate (once every second) The complete data sheet for DHT11 can be found here: Mouser.com DHT11 datasheet","title":"Specifications"},{"location":"kits/eduponics_mini/basic_sensors_usage/dht11_temperature_and_humidity/#possible-applications","text":"The DHT11 is very useful sensor often used in environment related projects such as: Weather station Indoor air quality monitoring Smart agriculture Green house monitoring We will use the DHT11 to measure the environment around our plant, making sure it's not too cold and not too hot either. Regarding the humidity, multiple actions can be taken such as alert, automatic window opener and more.","title":"Possible applications"},{"location":"kits/eduponics_mini/basic_sensors_usage/dht11_temperature_and_humidity/#hardware-explanation","text":"The DHT11 sensor can measure both temperature and humidity. The temperature is measured with the help of a NTC thermistor or negative temperature coefficient thermistor. These thermistors are usually made with semiconductors, ceramic and polymers. The resistance of the device is inversely proportional with temperature and follows a hyperbolic curve. Temperature using NTC often found out Steinhart Hart equation . The sensor's humidity determined using a moisture dependent resistor. It has two electrodes with a moisture-holding substrate between them that holds the moisture. The result is the conductance and resistance change as the humidity changes. Both these temperatures and humidity changes analyzed by an IC placed on the other side of the board. It calculates the values of both and can transmit those values to a microcontroller using only a single data line.","title":"Hardware explanation"},{"location":"kits/eduponics_mini/basic_sensors_usage/dht11_temperature_and_humidity/#software-explanation","text":"Controlling the DHT11 is very easy due to the internal MicroPython supported library DHT. The only thing we need is to import the DHT library that is built-in in MicroPython and initialize it using dht.DHT11() with the PIN that we use. In our case, the Eduponics Mini uses IO PIN 19 for the DHT11 sensor. Then, we'll use the measure function to measure the temperature and humidity, put them into variables, and finally print them on screen. If you prefer Fahrenheit instead of Celcius, make sure to uncomment the conversion lines. MicroPython ESP32-Arduino import dht import machine # initialize dht object, DHT11 coonected to IO19 d = dht . DHT11 ( machine . Pin ( 19 )) # measure sensor data d . measure () # get data temp = d . temperature () humidity = d . humidity () # uncomment for temperature in Fahrenheit #temp = (temp / 100) * (9/5) + 32 #temp = str(round(temp, 2)) # print temperature and humidity print ( \"temperature : %s \" % temp ) print ( \"humidity : %s \" % humidity ) #include \"DHT.h\" #define DHTPIN 19 // Digital pin connected to the DHT sensor // Uncomment whatever type you're using! #define DHTTYPE DHT11 // DHT 11 //#define DHTTYPE DHT22 // DHT 22 (AM2302), AM2321 //#define DHTTYPE DHT21 // DHT 21 (AM2301) // Initialize DHT sensor. // Note that older versions of this library took an optional third parameter to // tweak the timings for faster processors. This parameter is no longer needed // as the current DHT reading algorithm adjusts itself to work on faster procs. DHT dht ( DHTPIN , DHTTYPE ); void setup () { Serial . begin ( 115200 ); Serial . println ( F ( \"DHTxx test!\" )); dht . begin (); } void loop () { // Wait a few seconds between measurements. delay ( 2000 ); // Reading temperature or humidity takes about 250 milliseconds! // Sensor readings may also be up to 2 seconds 'old' (its a very slow sensor) float h = dht . readHumidity (); // Read temperature as Celsius (the default) float t = dht . readTemperature (); // Read temperature as Fahrenheit (isFahrenheit = true) float f = dht . readTemperature ( true ); // Check if any reads failed and exit early (to try again). if ( isnan ( h ) || isnan ( t ) || isnan ( f )) { Serial . println ( F ( \"Failed to read from DHT sensor!\" )); return ; } // Compute heat index in Fahrenheit (the default) float hif = dht . computeHeatIndex ( f , h ); // Compute heat index in Celsius (isFahreheit = false) float hic = dht . computeHeatIndex ( t , h , false ); Serial . print ( F ( \"Humidity: \" )); Serial . print ( h ); Serial . print ( F ( \"% Temperature: \" )); Serial . print ( t ); Serial . print ( F ( \"\u00b0C \" )); Serial . print ( f ); Serial . print ( F ( \"\u00b0F Heat index: \" )); Serial . print ( hic ); Serial . print ( F ( \"\u00b0C \" )); Serial . print ( hif ); Serial . println ( F ( \"\u00b0F\" )); }","title":"Software explanation"},{"location":"kits/eduponics_mini/basic_sensors_usage/eeprom_module/","text":"AT24C02 EEPROM Module The Atmel AT24C02 EEPROM is a memory chip that allows you to store data and retain it even when the power goes off. It is usually used to store user settings or other kind of configuration. This great chip allows us to write bytes of information and read them later, no matter if the device rebooted itself or not. the ESP32 has the capability to store files locally using Python but we thought that adding EEPROM could be very useful. Specifications The EEPROM includes many great features such as 1 million write cycles and data retention of 100 years, but also: Low voltage operation I2C-Compatible (2-wire) serial interface Bidirectional data transfer protocol (read and write) Write Protect pin for full array hardware data protection Ultra low active current (1mA max) and standby current (0.8\u03bcA max) 8-byte Page Write mode, partial page writes are also allowed View the complete datasheet: AT24C02 EEPROM datasheet from octopart.com 1,000,000 write lifecycle usage limit 1,000,000 writes might sound like a lot and it's definitely is. but, in order to keep the EEPROM healthy we do not recommend writing on it using while or for loops in milliseconds of interval which means you should keep data when it's necessary and read it when necessary, use it wisely and you should have years of possible great usage with the AT24C02 EEPROM chip! Reading is not limited as much as writing. Possible applications There could be many reasons to use EEPROM, such as: authentication, keep login information or unique data that you need to access on time when device is booting; things that you need to check if device rebooted (if it's rebooted, you'll lose variables that were in memory, that's where EEPROM is useful for); remember the last state of a variable; save settings; save how many times an appliance was activated; any other type of data that you need to have saved permanently. Software explanation Make sure micropython-eduponics is installed through upip For our Python code, we will need to import eduponics library, make sure you followed the introduction guide on installing the library on the ESP32 Eduponics Mini board. The software library is written by Mike Causer, you can check the Github library here In micropython-eduponics we have a class called AT24C32N where there are multiple functions such as read and write. The first thing to do will be to initialize our EEPROM using the I2C protocol which has 2 pins SCL and SDA. The SCL pin would be pin 15 while the SDA pin would be pin number 4. Then, when we have our i2c object ready, we can initialize the EEPROM. First, we try to read 32 bytes which should be empty. Then, we'll write \"hello world\" which takes 11 bytes. finally, we'll read 11 bytes which is exactly the length of the string we've added which is \"hello world\". MicroPython ESP32-Arduino \"\"\" MicroPython TinyRTC I2C Module, DS1307 RTC + AT24C32N EEPROM https://github.com/mcauser/micropython-tinyrtc MIT License Copyright (c) 2018 Mike Causer 2021 STEMinds Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \"\"\" # AT24C32A, 32K (32768 kbit / 4 KB), 128 pages, 32 bytes per page, i2c addr 0x50 from Eduponics import at24c02 import machine import time # initialize i2c connection i2c = machine . I2C ( scl = machine . Pin ( 15 ), sda = machine . Pin ( 4 )) # define the EEPROM using the I2C eeprom = at24c02 . AT24C32N ( i2c ) # print 32 bytes print ( eeprom . read ( 0 , 32 )) # write \"hello world\" starting from sector 0 eeprom . write ( 0 , 'hello world' ) # read 11 bytes from the EEPROM print ( eeprom . read ( 0 , 11 )) /* * Use the I2C bus with EEPROM 24LC64 * Sketch: eeprom.ino * * Author: hkhijhe * Date: 01/10/2010 * * */ #include <Wire.h> void i2c_eeprom_write_byte ( int deviceaddress , unsigned int eeaddress , byte data ) { int rdata = data ; Wire . beginTransmission ( deviceaddress ); Wire . write (( int )( eeaddress >> 8 )); // MSB Wire . write (( int )( eeaddress & 0xFF )); // LSB Wire . write ( rdata ); Wire . endTransmission (); } // WARNING: address is a page address, 6-bit end will wrap around // also, data can be maximum of about 30 bytes, because the Wire library has a buffer of 32 bytes void i2c_eeprom_write_page ( int deviceaddress , unsigned int eeaddresspage , byte * data , byte length ) { Wire . beginTransmission ( deviceaddress ); Wire . write (( int )( eeaddresspage >> 8 )); // MSB Wire . write (( int )( eeaddresspage & 0xFF )); // LSB byte c ; for ( c = 0 ; c < length ; c ++ ) Wire . write ( data [ c ]); Wire . endTransmission (); } byte i2c_eeprom_read_byte ( int deviceaddress , unsigned int eeaddress ) { byte rdata = 0xFF ; Wire . beginTransmission ( deviceaddress ); Wire . write (( int )( eeaddress >> 8 )); // MSB Wire . write (( int )( eeaddress & 0xFF )); // LSB Wire . endTransmission (); Wire . requestFrom ( deviceaddress , 1 ); if ( Wire . available ()) rdata = Wire . read (); return rdata ; } // maybe let's not read more than 30 or 32 bytes at a time! void i2c_eeprom_read_buffer ( int deviceaddress , unsigned int eeaddress , byte * buffer , int length ) { Wire . beginTransmission ( deviceaddress ); Wire . write (( int )( eeaddress >> 8 )); // MSB Wire . write (( int )( eeaddress & 0xFF )); // LSB Wire . endTransmission (); Wire . requestFrom ( deviceaddress , length ); int c = 0 ; for ( c = 0 ; c < length ; c ++ ) if ( Wire . available ()) buffer [ c ] = Wire . read (); } void setup () { char somedata [] = \"hello world\" ; // data to write // start I2C on pins 4 and 15 Wire . begin ( 4 , 15 ); // start serial connection Serial . begin ( 115200 ); i2c_eeprom_write_page ( 0x50 , 0 , ( byte * ) somedata , sizeof ( somedata )); // write to EEPROM delay ( 100 ); //add a small delay Serial . println ( \"Memory written\" ); } void loop () { int addr = 0 ; //first address byte b = i2c_eeprom_read_byte ( 0x50 , 0 ); // access the first address from the memory while ( b != 0 ) { Serial . print (( char ) b ); //print content to serial port addr ++ ; //increase address b = i2c_eeprom_read_byte ( 0x50 , addr ); //access an address from the memory } Serial . println ( \" \" ); delay ( 2000 ); }","title":"EEPROM Module"},{"location":"kits/eduponics_mini/basic_sensors_usage/eeprom_module/#at24c02-eeprom-module","text":"The Atmel AT24C02 EEPROM is a memory chip that allows you to store data and retain it even when the power goes off. It is usually used to store user settings or other kind of configuration. This great chip allows us to write bytes of information and read them later, no matter if the device rebooted itself or not. the ESP32 has the capability to store files locally using Python but we thought that adding EEPROM could be very useful.","title":"AT24C02 EEPROM Module"},{"location":"kits/eduponics_mini/basic_sensors_usage/eeprom_module/#specifications","text":"The EEPROM includes many great features such as 1 million write cycles and data retention of 100 years, but also: Low voltage operation I2C-Compatible (2-wire) serial interface Bidirectional data transfer protocol (read and write) Write Protect pin for full array hardware data protection Ultra low active current (1mA max) and standby current (0.8\u03bcA max) 8-byte Page Write mode, partial page writes are also allowed View the complete datasheet: AT24C02 EEPROM datasheet from octopart.com 1,000,000 write lifecycle usage limit 1,000,000 writes might sound like a lot and it's definitely is. but, in order to keep the EEPROM healthy we do not recommend writing on it using while or for loops in milliseconds of interval which means you should keep data when it's necessary and read it when necessary, use it wisely and you should have years of possible great usage with the AT24C02 EEPROM chip! Reading is not limited as much as writing.","title":"Specifications"},{"location":"kits/eduponics_mini/basic_sensors_usage/eeprom_module/#possible-applications","text":"There could be many reasons to use EEPROM, such as: authentication, keep login information or unique data that you need to access on time when device is booting; things that you need to check if device rebooted (if it's rebooted, you'll lose variables that were in memory, that's where EEPROM is useful for); remember the last state of a variable; save settings; save how many times an appliance was activated; any other type of data that you need to have saved permanently.","title":"Possible applications"},{"location":"kits/eduponics_mini/basic_sensors_usage/eeprom_module/#software-explanation","text":"Make sure micropython-eduponics is installed through upip For our Python code, we will need to import eduponics library, make sure you followed the introduction guide on installing the library on the ESP32 Eduponics Mini board. The software library is written by Mike Causer, you can check the Github library here In micropython-eduponics we have a class called AT24C32N where there are multiple functions such as read and write. The first thing to do will be to initialize our EEPROM using the I2C protocol which has 2 pins SCL and SDA. The SCL pin would be pin 15 while the SDA pin would be pin number 4. Then, when we have our i2c object ready, we can initialize the EEPROM. First, we try to read 32 bytes which should be empty. Then, we'll write \"hello world\" which takes 11 bytes. finally, we'll read 11 bytes which is exactly the length of the string we've added which is \"hello world\". MicroPython ESP32-Arduino \"\"\" MicroPython TinyRTC I2C Module, DS1307 RTC + AT24C32N EEPROM https://github.com/mcauser/micropython-tinyrtc MIT License Copyright (c) 2018 Mike Causer 2021 STEMinds Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \"\"\" # AT24C32A, 32K (32768 kbit / 4 KB), 128 pages, 32 bytes per page, i2c addr 0x50 from Eduponics import at24c02 import machine import time # initialize i2c connection i2c = machine . I2C ( scl = machine . Pin ( 15 ), sda = machine . Pin ( 4 )) # define the EEPROM using the I2C eeprom = at24c02 . AT24C32N ( i2c ) # print 32 bytes print ( eeprom . read ( 0 , 32 )) # write \"hello world\" starting from sector 0 eeprom . write ( 0 , 'hello world' ) # read 11 bytes from the EEPROM print ( eeprom . read ( 0 , 11 )) /* * Use the I2C bus with EEPROM 24LC64 * Sketch: eeprom.ino * * Author: hkhijhe * Date: 01/10/2010 * * */ #include <Wire.h> void i2c_eeprom_write_byte ( int deviceaddress , unsigned int eeaddress , byte data ) { int rdata = data ; Wire . beginTransmission ( deviceaddress ); Wire . write (( int )( eeaddress >> 8 )); // MSB Wire . write (( int )( eeaddress & 0xFF )); // LSB Wire . write ( rdata ); Wire . endTransmission (); } // WARNING: address is a page address, 6-bit end will wrap around // also, data can be maximum of about 30 bytes, because the Wire library has a buffer of 32 bytes void i2c_eeprom_write_page ( int deviceaddress , unsigned int eeaddresspage , byte * data , byte length ) { Wire . beginTransmission ( deviceaddress ); Wire . write (( int )( eeaddresspage >> 8 )); // MSB Wire . write (( int )( eeaddresspage & 0xFF )); // LSB byte c ; for ( c = 0 ; c < length ; c ++ ) Wire . write ( data [ c ]); Wire . endTransmission (); } byte i2c_eeprom_read_byte ( int deviceaddress , unsigned int eeaddress ) { byte rdata = 0xFF ; Wire . beginTransmission ( deviceaddress ); Wire . write (( int )( eeaddress >> 8 )); // MSB Wire . write (( int )( eeaddress & 0xFF )); // LSB Wire . endTransmission (); Wire . requestFrom ( deviceaddress , 1 ); if ( Wire . available ()) rdata = Wire . read (); return rdata ; } // maybe let's not read more than 30 or 32 bytes at a time! void i2c_eeprom_read_buffer ( int deviceaddress , unsigned int eeaddress , byte * buffer , int length ) { Wire . beginTransmission ( deviceaddress ); Wire . write (( int )( eeaddress >> 8 )); // MSB Wire . write (( int )( eeaddress & 0xFF )); // LSB Wire . endTransmission (); Wire . requestFrom ( deviceaddress , length ); int c = 0 ; for ( c = 0 ; c < length ; c ++ ) if ( Wire . available ()) buffer [ c ] = Wire . read (); } void setup () { char somedata [] = \"hello world\" ; // data to write // start I2C on pins 4 and 15 Wire . begin ( 4 , 15 ); // start serial connection Serial . begin ( 115200 ); i2c_eeprom_write_page ( 0x50 , 0 , ( byte * ) somedata , sizeof ( somedata )); // write to EEPROM delay ( 100 ); //add a small delay Serial . println ( \"Memory written\" ); } void loop () { int addr = 0 ; //first address byte b = i2c_eeprom_read_byte ( 0x50 , 0 ); // access the first address from the memory while ( b != 0 ) { Serial . print (( char ) b ); //print content to serial port addr ++ ; //increase address b = i2c_eeprom_read_byte ( 0x50 , addr ); //access an address from the memory } Serial . println ( \" \" ); delay ( 2000 ); }","title":"Software explanation"},{"location":"kits/eduponics_mini/basic_sensors_usage/light_sensor/","text":"BH1750 Light sensor The BH1750 is integrated IC with photodiode that allows us to measure the intensity and Illuminance of light and understanding whenever our environment is sufficient for our plant to live or it won't be able to survive due to lack of sunlight. The BH1750 sensor is already integrated into the Eduponics Mini kit and we use I2C protocol to communicate with it. Sensor Specifications The BH1750 IC includes a lot of features, let's take a look at some of them: Spectral response speed is close to human eye response Illuminance analog to Digital Converter (Integrated ADC) Wide range and High resolution. ( 1 - 65535 lx ) Low consumption on \"power down\" mode. 50Hz / 60Hz Light noise rejection functionality Infrared influence is extremely minimal, no interference. The complete BH1750 datasheet can be found here: mouser.com BH1750 datasheet Possible applications There are a lot of applications for light sensors, not just in the field of smart agriculture, some of them are: Can be used as light sensor. In agriculture can let you know if a plant has enough light. Useful for measuring the intensity of light. Night light and photography light meters use similar sensors to \"sense\" the environment. Night lamp to turn it on when dark and turn it off when it's light Infrared astronomy and Infrared Spectroscopy also use similar sensors for measuring mid-infrared spectral region. Your laptop or phone use similar sensor to adjust LCD back-light intensity Photodiode explained From Wikipedia: A photodiode is a semiconductor device that converts light into an electrical current. The current is generated when photons are absorbed in the photodiode. Photodiodes may contain optical filters, built-in lenses, and may have large or small surface areas. A photodiode is a PIN structure or p\u2013n junction. When a photon of sufficient energy strikes the diode, it creates an electron\u2013hole pair. This mechanism is also known as the inner photoelectric effect. If the absorption occurs in the junction's depletion region, or one diffusion length away from it, these carriers are swept from the junction by the built-in electric field of the depletion region. Thus holes move toward the anode, and electrons toward the cathode, and a photocurrent is produced. The total current through the photodiode is the sum of the dark current (current that is generated in the absence of light) and the photocurrent, so the dark current must be minimized to maximize the sensitivity of the device\" Illustration borrowed from: ElectronicsCoach.com The BH1750 is a very sophisticated IC (integrated circuit) that includes multiple components. Let's walk through the data sheet shown in the picture below to understand the principles better. PD - Photo diode with approximate human eye response, this is the main component in the IC that allow us to detect the amount of light. AMP - Integration OPAMP for converting from PD current to Voltage as the current by itself is not much use for us. ADC - Analog to digital converter for obtaining Digital 16bit data. Logic + I2C Interface - Ambient Light Calculation and I2C BUS Interface, we read the lux value through the I2C interface. Internal Oscillator ( 320kHz ). It is CLK for internal logic. As we mentioned, our main component inside the IC is the PD which is photo-diode that allows us to read the amount of ambient light, the other components that are integrated in the IC allow us to convert the value and receive it in a convenient way through I2C interface. Software example Make sure micropython-eduponics is installed through upip For our Python code, we will need to import eduponics library, make sure you followed the introduction guide on installing the library on the ESP32 Eduponics Mini board. In the following code example, we'll use a class called \"LightSensor\" from the micropython-eduponics library, this class we define some of the main functions that we need in order to interact with our light sensor. The code is very straight forward: we'll create an object from the BH1750 library called \"light\" and execute a single \"readLight\" function on the object to recieve the light intensity in lux. MicroPython ESP32-Arduino \"\"\" MicroPython BH1750 light sensor module https://github.com/STEMinds/eduponics-mini MIT License Copyright (c) 2020 STEMinds Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \"\"\" from Eduponics import bh1750 import machine import time # initialize the bh1750 sensor light = bh1750 . BH1750 () # while true, print the light values in lux while True : print ( light . readLight ()) time . sleep ( 1 ) #include <Wire.h> #include <BH1750.h> BH1750 lightMeter ( 0x5C ); void setup (){ // start serial communication Serial . begin ( 115200 ); // start I2C on pins 4 and 15 Wire . begin ( 4 , 15 ); // initialize the bh1750 lightMeter . begin ( BH1750 :: CONTINUOUS_HIGH_RES_MODE , 0x5C , & Wire ); } void loop () { float lux = lightMeter . readLightLevel (); Serial . print ( \"Light: \" ); Serial . print ( lux ); Serial . println ( \" lx\" ); delay ( 3000 ); }","title":"BH1750 Light sensor"},{"location":"kits/eduponics_mini/basic_sensors_usage/light_sensor/#bh1750-light-sensor","text":"The BH1750 is integrated IC with photodiode that allows us to measure the intensity and Illuminance of light and understanding whenever our environment is sufficient for our plant to live or it won't be able to survive due to lack of sunlight. The BH1750 sensor is already integrated into the Eduponics Mini kit and we use I2C protocol to communicate with it.","title":"BH1750 Light sensor"},{"location":"kits/eduponics_mini/basic_sensors_usage/light_sensor/#sensor-specifications","text":"The BH1750 IC includes a lot of features, let's take a look at some of them: Spectral response speed is close to human eye response Illuminance analog to Digital Converter (Integrated ADC) Wide range and High resolution. ( 1 - 65535 lx ) Low consumption on \"power down\" mode. 50Hz / 60Hz Light noise rejection functionality Infrared influence is extremely minimal, no interference. The complete BH1750 datasheet can be found here: mouser.com BH1750 datasheet","title":"Sensor Specifications"},{"location":"kits/eduponics_mini/basic_sensors_usage/light_sensor/#possible-applications","text":"There are a lot of applications for light sensors, not just in the field of smart agriculture, some of them are: Can be used as light sensor. In agriculture can let you know if a plant has enough light. Useful for measuring the intensity of light. Night light and photography light meters use similar sensors to \"sense\" the environment. Night lamp to turn it on when dark and turn it off when it's light Infrared astronomy and Infrared Spectroscopy also use similar sensors for measuring mid-infrared spectral region. Your laptop or phone use similar sensor to adjust LCD back-light intensity","title":"Possible applications"},{"location":"kits/eduponics_mini/basic_sensors_usage/light_sensor/#photodiode-explained","text":"From Wikipedia: A photodiode is a semiconductor device that converts light into an electrical current. The current is generated when photons are absorbed in the photodiode. Photodiodes may contain optical filters, built-in lenses, and may have large or small surface areas. A photodiode is a PIN structure or p\u2013n junction. When a photon of sufficient energy strikes the diode, it creates an electron\u2013hole pair. This mechanism is also known as the inner photoelectric effect. If the absorption occurs in the junction's depletion region, or one diffusion length away from it, these carriers are swept from the junction by the built-in electric field of the depletion region. Thus holes move toward the anode, and electrons toward the cathode, and a photocurrent is produced. The total current through the photodiode is the sum of the dark current (current that is generated in the absence of light) and the photocurrent, so the dark current must be minimized to maximize the sensitivity of the device\" Illustration borrowed from: ElectronicsCoach.com The BH1750 is a very sophisticated IC (integrated circuit) that includes multiple components. Let's walk through the data sheet shown in the picture below to understand the principles better. PD - Photo diode with approximate human eye response, this is the main component in the IC that allow us to detect the amount of light. AMP - Integration OPAMP for converting from PD current to Voltage as the current by itself is not much use for us. ADC - Analog to digital converter for obtaining Digital 16bit data. Logic + I2C Interface - Ambient Light Calculation and I2C BUS Interface, we read the lux value through the I2C interface. Internal Oscillator ( 320kHz ). It is CLK for internal logic. As we mentioned, our main component inside the IC is the PD which is photo-diode that allows us to read the amount of ambient light, the other components that are integrated in the IC allow us to convert the value and receive it in a convenient way through I2C interface.","title":"Photodiode explained"},{"location":"kits/eduponics_mini/basic_sensors_usage/light_sensor/#software-example","text":"Make sure micropython-eduponics is installed through upip For our Python code, we will need to import eduponics library, make sure you followed the introduction guide on installing the library on the ESP32 Eduponics Mini board. In the following code example, we'll use a class called \"LightSensor\" from the micropython-eduponics library, this class we define some of the main functions that we need in order to interact with our light sensor. The code is very straight forward: we'll create an object from the BH1750 library called \"light\" and execute a single \"readLight\" function on the object to recieve the light intensity in lux. MicroPython ESP32-Arduino \"\"\" MicroPython BH1750 light sensor module https://github.com/STEMinds/eduponics-mini MIT License Copyright (c) 2020 STEMinds Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \"\"\" from Eduponics import bh1750 import machine import time # initialize the bh1750 sensor light = bh1750 . BH1750 () # while true, print the light values in lux while True : print ( light . readLight ()) time . sleep ( 1 ) #include <Wire.h> #include <BH1750.h> BH1750 lightMeter ( 0x5C ); void setup (){ // start serial communication Serial . begin ( 115200 ); // start I2C on pins 4 and 15 Wire . begin ( 4 , 15 ); // initialize the bh1750 lightMeter . begin ( BH1750 :: CONTINUOUS_HIGH_RES_MODE , 0x5C , & Wire ); } void loop () { float lux = lightMeter . readLightLevel (); Serial . print ( \"Light: \" ); Serial . print ( lux ); Serial . println ( \" lx\" ); delay ( 3000 ); }","title":"Software example"},{"location":"kits/eduponics_mini/basic_sensors_usage/pump/","text":"Submersible 12V external pump With the Eduponics mini kit you'll find a small 12V submersible external pump as an accessory In this topic we'll learn about the pump, it's usage and possible applications and why we need a piece of hardware called \"relay\" to operate it. At the end, we'll write a small Python code that will allow us to control the relay, activating the pump and delivering water from our water container to our plant. Submersible usage only The pump is a 12V submersible pump, do not try to power it when the pump is outside of the water. Only use the pump when it's fully submersed underwater in order to avoid damaging the pump. We've included water quantity sensor in the kit which you can use to check if there is enough water in the container or not. 12V DC is required for full operation while 5V USB Type-C might work for you, it won't have enough power to pump the water through the entire hose. make sure to use the DC 12V power supply when operation the kit on production work. Specifications The pump is top quality product designed to live long and operate well under any conditions. Pure cooper wired motor, stable and consistent. Long lasting working life. High resistance turbine produce stable water circulation Low power consumption, 2W equal to 5W (same current, more power) High temperature resistance Made from recycled plastic materials Complete waterproof and safe to use for long term submerged applications. Silent design, doesn't make too much noise. Possible applications Pumps have many useful applications, our pump particularly is a Submersible pump which means it can only operate under water. there are other pumps that can operate in air but cannot be submersed under water such as air pumps. Possible applications for pumps are: Watering plants and flowers Moving liquids from one location to another Filling a fish tank or other container with water or liquids To empty the water or liquids from a container / tank Interactive water fountain Circulating the water making sure it doesn't stand still (Hydroponics for example) Relay principle explained Illustration by omaron introduction The 12V pump is operated using a 5V relay, we use 5V output signal to activate (open) the relay or to deactivate (close) the relay. when the relay is open, the circuit of the pump will close and allow current to flow thus activating the pump and letting us pump water through it. when we close the relay, the pump circuit is interrupted result in inactivating or disabling the pump. A relay is an electrically operated switch. Many relays use an electromagnet to mechanically operate a switch, but other operating principles are also used, such as solid-state relays. Our relay is based on the electromagnet principle, Relays are used where it is necessary to control a circuit by a separate low-power signal, or where several circuits must be controlled by one signal. Without the relay, we won't be able to control the pump for the reason that our ESP32 development board IO pins can only supply 3.3v of output while our relay requires 12V of output. The relay we use is HFD3/5, you can find more information here: HFD3/5 datasheet Connecting the pump to the kit The pump interface is our standard XH2.54 interface with 2 pins. to connect it, we'll simply plug the pump into the right port at the board, that should be easy because the board only contains single 2 pin interface which is dedicated for the pump. Then, we'll need to take the hose and connect it directly to the top side of our pump, the water will go through it directly to our plant. Make sure to connect the hose to the top side of the pump, the left side is the water input direction while the top side is the output. Preparing the environment As our pump is submersible, we must put it inside of our water container. it can be anything, a plastic bottle or a box, make sure to fill it with water and don't worry about the pump - it's completely waterproof! The pump is waterproof, the Eduponics mini board is not Make sure not to accidentally water the development board or any sensors included with it, only the pump itself with the wire can be submerged underwater. Software explained If we want to control the pump, we need to control the relay. the relay will behave as a \"gate\" that we open or close to allow the pump take water from the container and pump it through to our plant. for this code we'll need to import 2 libraries: machine and time. The machine library will allow us to control the IO pins while the time library will allow us to use the sleep function to take a small break between opening and closing the relay. The relay is connected to ESP32 IO pin number 23, because we \"tell\" the relay to either close or open, we'll set the pin as OUTPUT. Then what left to do is turn on the pump (by opening the relay) using .value(1) command and closing it after a while using .value(0) The .value() function setting the IO output signal to either 1 which is \"open\" in our case or 0 which will be \"close\". Check the complete code below and try it for yourself, you can change the sleep_interval variable with different number to let the program sleep for longer or shorter during the opening and closing of the relay. MicroPython ESP32-Arduino import machine import time # define pump on pin IO23 as OUTPUT pump = machine . Pin ( 23 , machine . Pin . OUT ) # define sleep interval as 3 seconds sleep_interval = 1 # turn on the pump pump . value ( 1 ) # wait for the defined sleep interval time . sleep ( sleep_interval ) # turn off the pump pump . value ( 0 ) // set the pump on IO pin number 23 const int pump = 23 ; void setup () { Serial . begin ( 115200 ); // configure pump as output pinMode ( pump , OUTPUT ); } void loop () { // when pump on low the relay is closed, no water is going through digitalWrite ( pump , LOW ); Serial . println ( \"Relay is closed\" ); delay ( 1000 ); // if the pump is high, the relay is open, the water goes through digitalWrite ( pump , HIGH ); Serial . println ( \"Relay is open\" ); delay ( 1000 ); }","title":"Water pump"},{"location":"kits/eduponics_mini/basic_sensors_usage/pump/#submersible-12v-external-pump","text":"With the Eduponics mini kit you'll find a small 12V submersible external pump as an accessory In this topic we'll learn about the pump, it's usage and possible applications and why we need a piece of hardware called \"relay\" to operate it. At the end, we'll write a small Python code that will allow us to control the relay, activating the pump and delivering water from our water container to our plant. Submersible usage only The pump is a 12V submersible pump, do not try to power it when the pump is outside of the water. Only use the pump when it's fully submersed underwater in order to avoid damaging the pump. We've included water quantity sensor in the kit which you can use to check if there is enough water in the container or not. 12V DC is required for full operation while 5V USB Type-C might work for you, it won't have enough power to pump the water through the entire hose. make sure to use the DC 12V power supply when operation the kit on production work.","title":"Submersible 12V external pump"},{"location":"kits/eduponics_mini/basic_sensors_usage/pump/#specifications","text":"The pump is top quality product designed to live long and operate well under any conditions. Pure cooper wired motor, stable and consistent. Long lasting working life. High resistance turbine produce stable water circulation Low power consumption, 2W equal to 5W (same current, more power) High temperature resistance Made from recycled plastic materials Complete waterproof and safe to use for long term submerged applications. Silent design, doesn't make too much noise.","title":"Specifications"},{"location":"kits/eduponics_mini/basic_sensors_usage/pump/#possible-applications","text":"Pumps have many useful applications, our pump particularly is a Submersible pump which means it can only operate under water. there are other pumps that can operate in air but cannot be submersed under water such as air pumps. Possible applications for pumps are: Watering plants and flowers Moving liquids from one location to another Filling a fish tank or other container with water or liquids To empty the water or liquids from a container / tank Interactive water fountain Circulating the water making sure it doesn't stand still (Hydroponics for example)","title":"Possible applications"},{"location":"kits/eduponics_mini/basic_sensors_usage/pump/#relay-principle-explained","text":"Illustration by omaron introduction The 12V pump is operated using a 5V relay, we use 5V output signal to activate (open) the relay or to deactivate (close) the relay. when the relay is open, the circuit of the pump will close and allow current to flow thus activating the pump and letting us pump water through it. when we close the relay, the pump circuit is interrupted result in inactivating or disabling the pump. A relay is an electrically operated switch. Many relays use an electromagnet to mechanically operate a switch, but other operating principles are also used, such as solid-state relays. Our relay is based on the electromagnet principle, Relays are used where it is necessary to control a circuit by a separate low-power signal, or where several circuits must be controlled by one signal. Without the relay, we won't be able to control the pump for the reason that our ESP32 development board IO pins can only supply 3.3v of output while our relay requires 12V of output. The relay we use is HFD3/5, you can find more information here: HFD3/5 datasheet","title":"Relay principle explained"},{"location":"kits/eduponics_mini/basic_sensors_usage/pump/#connecting-the-pump-to-the-kit","text":"The pump interface is our standard XH2.54 interface with 2 pins. to connect it, we'll simply plug the pump into the right port at the board, that should be easy because the board only contains single 2 pin interface which is dedicated for the pump. Then, we'll need to take the hose and connect it directly to the top side of our pump, the water will go through it directly to our plant. Make sure to connect the hose to the top side of the pump, the left side is the water input direction while the top side is the output.","title":"Connecting the pump to the kit"},{"location":"kits/eduponics_mini/basic_sensors_usage/pump/#preparing-the-environment","text":"As our pump is submersible, we must put it inside of our water container. it can be anything, a plastic bottle or a box, make sure to fill it with water and don't worry about the pump - it's completely waterproof! The pump is waterproof, the Eduponics mini board is not Make sure not to accidentally water the development board or any sensors included with it, only the pump itself with the wire can be submerged underwater.","title":"Preparing the environment"},{"location":"kits/eduponics_mini/basic_sensors_usage/pump/#software-explained","text":"If we want to control the pump, we need to control the relay. the relay will behave as a \"gate\" that we open or close to allow the pump take water from the container and pump it through to our plant. for this code we'll need to import 2 libraries: machine and time. The machine library will allow us to control the IO pins while the time library will allow us to use the sleep function to take a small break between opening and closing the relay. The relay is connected to ESP32 IO pin number 23, because we \"tell\" the relay to either close or open, we'll set the pin as OUTPUT. Then what left to do is turn on the pump (by opening the relay) using .value(1) command and closing it after a while using .value(0) The .value() function setting the IO output signal to either 1 which is \"open\" in our case or 0 which will be \"close\". Check the complete code below and try it for yourself, you can change the sleep_interval variable with different number to let the program sleep for longer or shorter during the opening and closing of the relay. MicroPython ESP32-Arduino import machine import time # define pump on pin IO23 as OUTPUT pump = machine . Pin ( 23 , machine . Pin . OUT ) # define sleep interval as 3 seconds sleep_interval = 1 # turn on the pump pump . value ( 1 ) # wait for the defined sleep interval time . sleep ( sleep_interval ) # turn off the pump pump . value ( 0 ) // set the pump on IO pin number 23 const int pump = 23 ; void setup () { Serial . begin ( 115200 ); // configure pump as output pinMode ( pump , OUTPUT ); } void loop () { // when pump on low the relay is closed, no water is going through digitalWrite ( pump , LOW ); Serial . println ( \"Relay is closed\" ); delay ( 1000 ); // if the pump is high, the relay is open, the water goes through digitalWrite ( pump , HIGH ); Serial . println ( \"Relay is open\" ); delay ( 1000 ); }","title":"Software explained"},{"location":"kits/eduponics_mini/basic_sensors_usage/rgb_led/","text":"WS2812B RGB LED WS2812 is an intelligent control LED light source module with integrated RGB chip circuit at a 5050 size component package. Inside it includes intelligent digital port data latch and signal reshaping amplification drive circuit as well as a precision internal oscillator effectively ensuring the pixel point light color height will always be consistent. Specifications Control circuit and RGB chip are integrated in a 5050 size package. Built-in signal reshaping circuit, after wave reshaping to the next driver, ensure wave-form distortion not accumulate. Built-in electric reset circuit and power lost reset circuit. Each pixel (total of three primary colors) can achieve a 0 to 256 on scale of brightness, which results in 16777216 color display options, and scan frequency of no less than 400Hz/s. Cascading port transmission signal by single line. (one pin can control the LED and colors changes) Data transmission speed of 800Kbps, Very fast and very accurate. The complete data sheet of the WS2812B RGB can be viewed here: WS2812B RGB data sheet on parallax.com Possible applications You might think what does RGB LED has to do with Smart agriculture / automatic watering or anything regarding this kind of kit? Well, sometimes we could use an LED or two for indication purposes - why not use an RGB LED with thousands of colors possibility to indicate different state for each thing we do? for example: Alert indication if something goes wrong Connection status (MQTT / Wifi Connection) to show us the connection state Sensors state (i.e: red is bad, yellow warning, green is good) Blinking and animation for fun RGB LED can be very useful specially for debugging without connecting to the kit by itself. for example, what if the network goes down and we want to know about it? we can set the RGB to \"Red\" if the connection is good, we can set it to \"Green\". Hardware explanation The cool thing about the WS2812B RGB LED is it's not just an LED (to be exact, 3 LEDs) but it includes a tiny IC (integrated circuit) inside that allows us to control the LED state using a single IO pin. The RGB color can be manipulated using a simple PWN commands, if you'd like to connect multiple WS2812B LEDs that can also be archived and guess what? with just a single IO pin! We can add as many as we want and connect them together in series, in the protocol each one will have a location starting from 0 up to n (number of LED's we have) in our program, we will control the WS2812B that is soldered on board, if you'd like to connect more LED's you'd need to get a strip and connect them to the IO expansion. RGB LEDs are not suitable for plants growth You might think you can use WS2812B RGB LED strip as a light growth, the truth is you can't. the spectrum and the wavelength of the RGB LED's not suitable for plants however you can find suitable LED's strip with the right light spectrum and wavelength for plants growth - just not the WS2812B LED strip. Software explanation The MicroPython includes a built-in library called \"neopixel\" which we can use to control our WS2812B RGB LED, the syntax is fairly simple. First, we'll need to define to which IO pin the neopixel is connected - in our case it's pin 14, as a second argument (where we see 1) we need to define how many neopixels (RGB LEDs) do we have, our board only includes one so we write 1 as argument. Next, we'll define the color we want for pixel at place 0 which is the first (and in our case the only) LED we'll use. the colors are made from 3 arguments: red, green, blue. where the values goes from 0 to 255 which indicates the brightness of the color (0 empty and 255 is the brightest) We can use a website such as Rapidtables to find different RGB codes that we can use to change the color in our LED. The example below will turn the LED into red (full brightness) then green and then blue, finally we'll set all colors to 0 in order to turn the LED off. MicroPython ESP32-Arduino import machine , neopixel import time # Configure the RGB LED at IO pin 14 (1 indicates 1 LED) np = neopixel . NeoPixel ( machine . Pin ( 14 ), 1 ) np [ 0 ] = ( 255 , 0 , 0 ) # set to red, full brightness np . write () # save changes time . sleep ( 1 ) np [ 0 ] = ( 0 , 255 , 0 ) # set to green, full brightness np . write () # save changes time . sleep ( 1 ) np [ 0 ] = ( 0 , 0 , 255 ) # set to blue, full brightness np . write () # save changes time . sleep ( 1 ) np [ 0 ] = ( 0 , 0 , 0 ) # empty the LED colors (wipe) np . write () # save changes #include <Adafruit_NeoPixel.h> #define PIN 14 // When we setup the NeoPixel library, we tell it how many pixels, and which pin to use to send signals. // Note that for older NeoPixel strips you might need to change the third parameter--see the strandtest Adafruit_NeoPixel pixels = Adafruit_NeoPixel ( 1 , PIN , NEO_GRB + NEO_KHZ800 ); void setup () { pixels . begin (); // This initializes the NeoPixel library. } void loop () { pixels . setPixelColor ( 0 , pixels . Color ( 255 , 0 , 0 )); // set to red, full brightness pixels . show (); // This sends the updated pixel color to the hardware. delay ( 1000 ); pixels . setPixelColor ( 0 , pixels . Color ( 0 , 255 , 0 )); // set to green, full brightness pixels . show (); // This sends the updated pixel color to the hardware. delay ( 1000 ); pixels . setPixelColor ( 0 , pixels . Color ( 0 , 0 , 255 )); // set to blue, full brightness pixels . show (); // This sends the updated pixel color to the hardware. delay ( 1000 ); }","title":"RGB LED"},{"location":"kits/eduponics_mini/basic_sensors_usage/rgb_led/#ws2812b-rgb-led","text":"WS2812 is an intelligent control LED light source module with integrated RGB chip circuit at a 5050 size component package. Inside it includes intelligent digital port data latch and signal reshaping amplification drive circuit as well as a precision internal oscillator effectively ensuring the pixel point light color height will always be consistent.","title":"WS2812B RGB LED"},{"location":"kits/eduponics_mini/basic_sensors_usage/rgb_led/#specifications","text":"Control circuit and RGB chip are integrated in a 5050 size package. Built-in signal reshaping circuit, after wave reshaping to the next driver, ensure wave-form distortion not accumulate. Built-in electric reset circuit and power lost reset circuit. Each pixel (total of three primary colors) can achieve a 0 to 256 on scale of brightness, which results in 16777216 color display options, and scan frequency of no less than 400Hz/s. Cascading port transmission signal by single line. (one pin can control the LED and colors changes) Data transmission speed of 800Kbps, Very fast and very accurate. The complete data sheet of the WS2812B RGB can be viewed here: WS2812B RGB data sheet on parallax.com","title":"Specifications"},{"location":"kits/eduponics_mini/basic_sensors_usage/rgb_led/#possible-applications","text":"You might think what does RGB LED has to do with Smart agriculture / automatic watering or anything regarding this kind of kit? Well, sometimes we could use an LED or two for indication purposes - why not use an RGB LED with thousands of colors possibility to indicate different state for each thing we do? for example: Alert indication if something goes wrong Connection status (MQTT / Wifi Connection) to show us the connection state Sensors state (i.e: red is bad, yellow warning, green is good) Blinking and animation for fun RGB LED can be very useful specially for debugging without connecting to the kit by itself. for example, what if the network goes down and we want to know about it? we can set the RGB to \"Red\" if the connection is good, we can set it to \"Green\".","title":"Possible applications"},{"location":"kits/eduponics_mini/basic_sensors_usage/rgb_led/#hardware-explanation","text":"The cool thing about the WS2812B RGB LED is it's not just an LED (to be exact, 3 LEDs) but it includes a tiny IC (integrated circuit) inside that allows us to control the LED state using a single IO pin. The RGB color can be manipulated using a simple PWN commands, if you'd like to connect multiple WS2812B LEDs that can also be archived and guess what? with just a single IO pin! We can add as many as we want and connect them together in series, in the protocol each one will have a location starting from 0 up to n (number of LED's we have) in our program, we will control the WS2812B that is soldered on board, if you'd like to connect more LED's you'd need to get a strip and connect them to the IO expansion. RGB LEDs are not suitable for plants growth You might think you can use WS2812B RGB LED strip as a light growth, the truth is you can't. the spectrum and the wavelength of the RGB LED's not suitable for plants however you can find suitable LED's strip with the right light spectrum and wavelength for plants growth - just not the WS2812B LED strip.","title":"Hardware explanation"},{"location":"kits/eduponics_mini/basic_sensors_usage/rgb_led/#software-explanation","text":"The MicroPython includes a built-in library called \"neopixel\" which we can use to control our WS2812B RGB LED, the syntax is fairly simple. First, we'll need to define to which IO pin the neopixel is connected - in our case it's pin 14, as a second argument (where we see 1) we need to define how many neopixels (RGB LEDs) do we have, our board only includes one so we write 1 as argument. Next, we'll define the color we want for pixel at place 0 which is the first (and in our case the only) LED we'll use. the colors are made from 3 arguments: red, green, blue. where the values goes from 0 to 255 which indicates the brightness of the color (0 empty and 255 is the brightest) We can use a website such as Rapidtables to find different RGB codes that we can use to change the color in our LED. The example below will turn the LED into red (full brightness) then green and then blue, finally we'll set all colors to 0 in order to turn the LED off. MicroPython ESP32-Arduino import machine , neopixel import time # Configure the RGB LED at IO pin 14 (1 indicates 1 LED) np = neopixel . NeoPixel ( machine . Pin ( 14 ), 1 ) np [ 0 ] = ( 255 , 0 , 0 ) # set to red, full brightness np . write () # save changes time . sleep ( 1 ) np [ 0 ] = ( 0 , 255 , 0 ) # set to green, full brightness np . write () # save changes time . sleep ( 1 ) np [ 0 ] = ( 0 , 0 , 255 ) # set to blue, full brightness np . write () # save changes time . sleep ( 1 ) np [ 0 ] = ( 0 , 0 , 0 ) # empty the LED colors (wipe) np . write () # save changes #include <Adafruit_NeoPixel.h> #define PIN 14 // When we setup the NeoPixel library, we tell it how many pixels, and which pin to use to send signals. // Note that for older NeoPixel strips you might need to change the third parameter--see the strandtest Adafruit_NeoPixel pixels = Adafruit_NeoPixel ( 1 , PIN , NEO_GRB + NEO_KHZ800 ); void setup () { pixels . begin (); // This initializes the NeoPixel library. } void loop () { pixels . setPixelColor ( 0 , pixels . Color ( 255 , 0 , 0 )); // set to red, full brightness pixels . show (); // This sends the updated pixel color to the hardware. delay ( 1000 ); pixels . setPixelColor ( 0 , pixels . Color ( 0 , 255 , 0 )); // set to green, full brightness pixels . show (); // This sends the updated pixel color to the hardware. delay ( 1000 ); pixels . setPixelColor ( 0 , pixels . Color ( 0 , 0 , 255 )); // set to blue, full brightness pixels . show (); // This sends the updated pixel color to the hardware. delay ( 1000 ); }","title":"Software explanation"},{"location":"kits/eduponics_mini/basic_sensors_usage/rtc_module/","text":"DS1307Z RTC Module The DS1307 Serial Real-Time Clock is a low-power, full binary-coded decimal (BCD) clock/calendar plus 56 bytes of NV SRAM. Address and data are transferred serially via a 2-wire, bi-directional bus. The clock/calendar provides seconds, minutes, hours, day, date, month, and year information. The end of the month date is automatically adjusted for months with fewer than 31 days, including corrections for leap year. The clock operates in either the 24-hour or 12-hour format with AM/PM indicator. The DS1307 has a built-in power sense circuit that detects power failures and automatically switches to the battery supply. While the ESP32 have a built-in RTC inside, the RTC inside of the ESP32 is mostly used for counting (like a timer) but what if we need to know the exact time of the day or the date when our ESP32 wakeup in order to figure out if it's time to do something? for this purpose we've added extra component - our DS1307Z RTC module. The Internal ESP32 RTC can be connected to a battery but this coin battery will power the entire ESP32 board and not just the RTC functionality which will force the ESP32 to constantly be in sleep mode in order not to waste energy which is something unreasonable to do in case of our application. RTC Lithium coin cell battery not included in Eduponics Mini kit. Due to shipping regulations and policies we are not able to ship the lithium batteries inside the kit, the RTC module requires the coin cell battery to operate and save data even when the ESP32 is off. Specifications The DS1307Z RTC includes bunch of useful features, such as: Real-time clock (RTC) counts seconds, minutes, hours, date of the month, month, day of the week, and year with leap-year compensation valid up to 2100 56-byte, battery-backed, nonvolatile (NV) RAM for data storage Two-wire serial interface Programmable squarewave output signal Automatic power-fail detect and switch circuitry Consumes less than 500nA in battery backup mode with oscillator running For the complete data sheet check here: DS1307 data sheet from sparkfun.com Possible applications The RTC module is super useful, here are some of the possible applications you can archive using it: Store data and time to refer to without wireless connectivity Use the stored date and time to check if it's \"time\" to perform scheduled operation Use time and date for logging, if something happens you will know when it did. Any other application that require time or date to be pulled in no time. Hardware explanation The simple circuit the two inputs X1 and X2 are connected to a 32.768 kHz crystal oscillator as the source of the chip. VBAT is connected to positive culture of a 3V battery chip. VCC power to the I2C interface is 3.3V which is given by the ESP32 board. If the power supply VCC is not granted read and writes are inhibited. CN1 represents the IO connections for the I2C interfae which we use to control the module and read/write from it. On the Eduponics Mini board the RTC module and the crystal oscillator is at the front while the coin battery cell is mounted at the back. Connecting the battery to the RTC module The RTC coin battery is not included with the kit due to logistics concerns when shipping Lithium batteries, The battery type is CR1220 and can be found in probably any convenient shop near your home. The picture above is for illustration purpose only, there are many brands such as Panasonic, Murata, Cellewell etc ... all should work as long as it's 3V and same size (the model should be CR1220). The battery case can be found on the bottom side of the Eduponics Mini development board. Make sure to plug the battery in the right direction (ground bottom side, positive side up). Without the coin cell battery the RTC functionality will work but we won't be able to save any data after our device reboots or disconnect from power. Software explanation Make sure micropython-eduponics is installed through upip For our Python code, we will need to import eduponics library, make sure you followed the introduction guide on installing the library on the ESP32 Eduponics Mini board. The software library is written by Mike Causer, you can check the Github library here The RTC communicates through I2C protocol that has multiple address for multiple functions such as halt (power on/off) register time and date and read data (control register). First, we'll need to define the I2C device: The RTC connected to SCL IO PIN 15 and SDA IO PIN 4. After we've configured that successfully we can call the .halt() function with the argument \"False\" which means don't halt the device or in other words - turn it on. Then, we need to set the timestamp (current time and date for our device to remember) this can be done only once or if we need to change it later on to something different we can repeat it as many times as we want but that won't be necessary in most applications. A good resource to get exact time and date would be epochconverter.com the last 2 zeroes in the time and date format can be left zeroed. Finally, we can call .datetime() command to get the current time and date from the RTC module, it will update in real time even if we reboot or disconnect our device (as long as the coin battery lives) MicroPython ESP32-Arduino \"\"\" MicroPython DS1307 RTC module https://github.com/STEMinds/eduponics-mini MIT License Copyright (c) 2020 STEMinds Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \"\"\" import machine from Eduponics import ds1307 import time # configure i2c pin i2c = machine . I2C ( scl = machine . Pin ( 15 ), sda = machine . Pin ( 4 )) # configure the RTC using the i2c configuration ds = ds1307 . DS1307 ( i2c ) # power on the chip ds . halt ( False ) # set the current time (change it to the time you need) now = ( 2020 , 9 , 7 , 6 , 14 , 28 , 0 , 0 ) # print current date and time while True : print ( ds . datetime ()) time . sleep ( 1 ) #include \"Wire.h\" #define DS3231_I2C_ADDRESS 0x68 // Convert normal decimal numbers to binary coded decimal byte decToBcd ( byte val ) { return ( ( val / 10 * 16 ) + ( val % 10 ) ); } // Convert binary coded decimal to normal decimal numbers byte bcdToDec ( byte val ) { return ( ( val / 16 * 10 ) + ( val % 16 ) ); } void setup () { // start I2C on pins 4 and 15 Wire . begin ( 4 , 15 ); Serial . begin ( 115200 ); // set the initial time here: // DS3231 seconds, minutes, hours, day, date, month, year // setDS3231time(20,11,18,7,24,10,20); } void setDS3231time ( byte second , byte minute , byte hour , byte dayOfWeek , byte dayOfMonth , byte month , byte year ) { // sets time and date data to DS3231 Wire . beginTransmission ( DS3231_I2C_ADDRESS ); Wire . write ( 0 ); // set next input to start at the seconds register Wire . write ( decToBcd ( second )); // set seconds Wire . write ( decToBcd ( minute )); // set minutes Wire . write ( decToBcd ( hour )); // set hours Wire . write ( decToBcd ( dayOfWeek )); // set day of week (1=Sunday, 7=Saturday) Wire . write ( decToBcd ( dayOfMonth )); // set date (1 to 31) Wire . write ( decToBcd ( month )); // set month Wire . write ( decToBcd ( year )); // set year (0 to 99) Wire . endTransmission (); } void readDS3231time ( byte * second , byte * minute , byte * hour , byte * dayOfWeek , byte * dayOfMonth , byte * month , byte * year ) { Wire . beginTransmission ( DS3231_I2C_ADDRESS ); Wire . write ( 0 ); // set DS3231 register pointer to 00h Wire . endTransmission (); Wire . requestFrom ( DS3231_I2C_ADDRESS , 7 ); // request seven bytes of data from DS3231 starting from register 00h * second = bcdToDec ( Wire . read () & 0x7f ); * minute = bcdToDec ( Wire . read ()); * hour = bcdToDec ( Wire . read () & 0x3f ); * dayOfWeek = bcdToDec ( Wire . read ()); * dayOfMonth = bcdToDec ( Wire . read ()); * month = bcdToDec ( Wire . read ()); * year = bcdToDec ( Wire . read ()); } void displayTime () { byte second , minute , hour , dayOfWeek , dayOfMonth , month , year ; // retrieve data from DS3231 readDS3231time ( & second , & minute , & hour , & dayOfWeek , & dayOfMonth , & month , & year ); // send it to the serial monitor Serial . print ( hour , DEC ); // convert the byte variable to a decimal number when displayed Serial . print ( \":\" ); if ( minute < 10 ) { Serial . print ( \"0\" ); } Serial . print ( minute , DEC ); Serial . print ( \":\" ); if ( second < 10 ) { Serial . print ( \"0\" ); } Serial . print ( second , DEC ); Serial . print ( \" \" ); Serial . print ( dayOfMonth , DEC ); Serial . print ( \"/\" ); Serial . print ( month , DEC ); Serial . print ( \"/\" ); Serial . print ( year , DEC ); Serial . print ( \" Day of week: \" ); switch ( dayOfWeek ){ case 1 : Serial . println ( \"Sunday\" ); break ; case 2 : Serial . println ( \"Monday\" ); break ; case 3 : Serial . println ( \"Tuesday\" ); break ; case 4 : Serial . println ( \"Wednesday\" ); break ; case 5 : Serial . println ( \"Thursday\" ); break ; case 6 : Serial . println ( \"Friday\" ); break ; case 7 : Serial . println ( \"Saturday\" ); break ; } } void loop () { displayTime (); // display the real-time clock data on the Serial Monitor, delay ( 1000 ); // every second }","title":"RTC Module"},{"location":"kits/eduponics_mini/basic_sensors_usage/rtc_module/#ds1307z-rtc-module","text":"The DS1307 Serial Real-Time Clock is a low-power, full binary-coded decimal (BCD) clock/calendar plus 56 bytes of NV SRAM. Address and data are transferred serially via a 2-wire, bi-directional bus. The clock/calendar provides seconds, minutes, hours, day, date, month, and year information. The end of the month date is automatically adjusted for months with fewer than 31 days, including corrections for leap year. The clock operates in either the 24-hour or 12-hour format with AM/PM indicator. The DS1307 has a built-in power sense circuit that detects power failures and automatically switches to the battery supply. While the ESP32 have a built-in RTC inside, the RTC inside of the ESP32 is mostly used for counting (like a timer) but what if we need to know the exact time of the day or the date when our ESP32 wakeup in order to figure out if it's time to do something? for this purpose we've added extra component - our DS1307Z RTC module. The Internal ESP32 RTC can be connected to a battery but this coin battery will power the entire ESP32 board and not just the RTC functionality which will force the ESP32 to constantly be in sleep mode in order not to waste energy which is something unreasonable to do in case of our application. RTC Lithium coin cell battery not included in Eduponics Mini kit. Due to shipping regulations and policies we are not able to ship the lithium batteries inside the kit, the RTC module requires the coin cell battery to operate and save data even when the ESP32 is off.","title":"DS1307Z RTC Module"},{"location":"kits/eduponics_mini/basic_sensors_usage/rtc_module/#specifications","text":"The DS1307Z RTC includes bunch of useful features, such as: Real-time clock (RTC) counts seconds, minutes, hours, date of the month, month, day of the week, and year with leap-year compensation valid up to 2100 56-byte, battery-backed, nonvolatile (NV) RAM for data storage Two-wire serial interface Programmable squarewave output signal Automatic power-fail detect and switch circuitry Consumes less than 500nA in battery backup mode with oscillator running For the complete data sheet check here: DS1307 data sheet from sparkfun.com","title":"Specifications"},{"location":"kits/eduponics_mini/basic_sensors_usage/rtc_module/#possible-applications","text":"The RTC module is super useful, here are some of the possible applications you can archive using it: Store data and time to refer to without wireless connectivity Use the stored date and time to check if it's \"time\" to perform scheduled operation Use time and date for logging, if something happens you will know when it did. Any other application that require time or date to be pulled in no time.","title":"Possible applications"},{"location":"kits/eduponics_mini/basic_sensors_usage/rtc_module/#hardware-explanation","text":"The simple circuit the two inputs X1 and X2 are connected to a 32.768 kHz crystal oscillator as the source of the chip. VBAT is connected to positive culture of a 3V battery chip. VCC power to the I2C interface is 3.3V which is given by the ESP32 board. If the power supply VCC is not granted read and writes are inhibited. CN1 represents the IO connections for the I2C interfae which we use to control the module and read/write from it. On the Eduponics Mini board the RTC module and the crystal oscillator is at the front while the coin battery cell is mounted at the back.","title":"Hardware explanation"},{"location":"kits/eduponics_mini/basic_sensors_usage/rtc_module/#connecting-the-battery-to-the-rtc-module","text":"The RTC coin battery is not included with the kit due to logistics concerns when shipping Lithium batteries, The battery type is CR1220 and can be found in probably any convenient shop near your home. The picture above is for illustration purpose only, there are many brands such as Panasonic, Murata, Cellewell etc ... all should work as long as it's 3V and same size (the model should be CR1220). The battery case can be found on the bottom side of the Eduponics Mini development board. Make sure to plug the battery in the right direction (ground bottom side, positive side up). Without the coin cell battery the RTC functionality will work but we won't be able to save any data after our device reboots or disconnect from power.","title":"Connecting the battery to the RTC module"},{"location":"kits/eduponics_mini/basic_sensors_usage/rtc_module/#software-explanation","text":"Make sure micropython-eduponics is installed through upip For our Python code, we will need to import eduponics library, make sure you followed the introduction guide on installing the library on the ESP32 Eduponics Mini board. The software library is written by Mike Causer, you can check the Github library here The RTC communicates through I2C protocol that has multiple address for multiple functions such as halt (power on/off) register time and date and read data (control register). First, we'll need to define the I2C device: The RTC connected to SCL IO PIN 15 and SDA IO PIN 4. After we've configured that successfully we can call the .halt() function with the argument \"False\" which means don't halt the device or in other words - turn it on. Then, we need to set the timestamp (current time and date for our device to remember) this can be done only once or if we need to change it later on to something different we can repeat it as many times as we want but that won't be necessary in most applications. A good resource to get exact time and date would be epochconverter.com the last 2 zeroes in the time and date format can be left zeroed. Finally, we can call .datetime() command to get the current time and date from the RTC module, it will update in real time even if we reboot or disconnect our device (as long as the coin battery lives) MicroPython ESP32-Arduino \"\"\" MicroPython DS1307 RTC module https://github.com/STEMinds/eduponics-mini MIT License Copyright (c) 2020 STEMinds Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \"\"\" import machine from Eduponics import ds1307 import time # configure i2c pin i2c = machine . I2C ( scl = machine . Pin ( 15 ), sda = machine . Pin ( 4 )) # configure the RTC using the i2c configuration ds = ds1307 . DS1307 ( i2c ) # power on the chip ds . halt ( False ) # set the current time (change it to the time you need) now = ( 2020 , 9 , 7 , 6 , 14 , 28 , 0 , 0 ) # print current date and time while True : print ( ds . datetime ()) time . sleep ( 1 ) #include \"Wire.h\" #define DS3231_I2C_ADDRESS 0x68 // Convert normal decimal numbers to binary coded decimal byte decToBcd ( byte val ) { return ( ( val / 10 * 16 ) + ( val % 10 ) ); } // Convert binary coded decimal to normal decimal numbers byte bcdToDec ( byte val ) { return ( ( val / 16 * 10 ) + ( val % 16 ) ); } void setup () { // start I2C on pins 4 and 15 Wire . begin ( 4 , 15 ); Serial . begin ( 115200 ); // set the initial time here: // DS3231 seconds, minutes, hours, day, date, month, year // setDS3231time(20,11,18,7,24,10,20); } void setDS3231time ( byte second , byte minute , byte hour , byte dayOfWeek , byte dayOfMonth , byte month , byte year ) { // sets time and date data to DS3231 Wire . beginTransmission ( DS3231_I2C_ADDRESS ); Wire . write ( 0 ); // set next input to start at the seconds register Wire . write ( decToBcd ( second )); // set seconds Wire . write ( decToBcd ( minute )); // set minutes Wire . write ( decToBcd ( hour )); // set hours Wire . write ( decToBcd ( dayOfWeek )); // set day of week (1=Sunday, 7=Saturday) Wire . write ( decToBcd ( dayOfMonth )); // set date (1 to 31) Wire . write ( decToBcd ( month )); // set month Wire . write ( decToBcd ( year )); // set year (0 to 99) Wire . endTransmission (); } void readDS3231time ( byte * second , byte * minute , byte * hour , byte * dayOfWeek , byte * dayOfMonth , byte * month , byte * year ) { Wire . beginTransmission ( DS3231_I2C_ADDRESS ); Wire . write ( 0 ); // set DS3231 register pointer to 00h Wire . endTransmission (); Wire . requestFrom ( DS3231_I2C_ADDRESS , 7 ); // request seven bytes of data from DS3231 starting from register 00h * second = bcdToDec ( Wire . read () & 0x7f ); * minute = bcdToDec ( Wire . read ()); * hour = bcdToDec ( Wire . read () & 0x3f ); * dayOfWeek = bcdToDec ( Wire . read ()); * dayOfMonth = bcdToDec ( Wire . read ()); * month = bcdToDec ( Wire . read ()); * year = bcdToDec ( Wire . read ()); } void displayTime () { byte second , minute , hour , dayOfWeek , dayOfMonth , month , year ; // retrieve data from DS3231 readDS3231time ( & second , & minute , & hour , & dayOfWeek , & dayOfMonth , & month , & year ); // send it to the serial monitor Serial . print ( hour , DEC ); // convert the byte variable to a decimal number when displayed Serial . print ( \":\" ); if ( minute < 10 ) { Serial . print ( \"0\" ); } Serial . print ( minute , DEC ); Serial . print ( \":\" ); if ( second < 10 ) { Serial . print ( \"0\" ); } Serial . print ( second , DEC ); Serial . print ( \" \" ); Serial . print ( dayOfMonth , DEC ); Serial . print ( \"/\" ); Serial . print ( month , DEC ); Serial . print ( \"/\" ); Serial . print ( year , DEC ); Serial . print ( \" Day of week: \" ); switch ( dayOfWeek ){ case 1 : Serial . println ( \"Sunday\" ); break ; case 2 : Serial . println ( \"Monday\" ); break ; case 3 : Serial . println ( \"Tuesday\" ); break ; case 4 : Serial . println ( \"Wednesday\" ); break ; case 5 : Serial . println ( \"Thursday\" ); break ; case 6 : Serial . println ( \"Friday\" ); break ; case 7 : Serial . println ( \"Saturday\" ); break ; } } void loop () { displayTime (); // display the real-time clock data on the Serial Monitor, delay ( 1000 ); // every second }","title":"Software explanation"},{"location":"kits/eduponics_mini/basic_sensors_usage/soil_moisture_sensor/","text":"STEMinds Soil moisture sensor Our sensor is one of a kind, we truly love that sensor and hope other people can use it as much as we do. We've been looking for quite some time for a soil moisture stable sensor for smart agriculture / smart plants related projects but couldn't find any. We've tested over 10 sensors available in the market till we've decided to make our own. let's go through the information to understand why our sensor is different and why it's better than other alternatives. Specifications During the process of testing and finding the perfect soil moisture sensor for our Eduponics Mini kit we found out that other existing sensors and solution just don't work to our high expectation. here is some of the specification of our custom made sensor: Wide range of reading (about 1024 to 4060 in scale of analog reading) Water-proof and dust-proof, self-tested submerged for 24 hours. Powered by 5V input/output Highly accurate, useful for industrial and real life applications. Comparison to other sensors While looking for soil moisture sensors to use with our kit, we encountered a severe challenge - the sensors were just not good enough. We've purchased and tested multiple sensors till the decision was made to make our own. Take a look at the comparison below, our sensor has the highest voltage range and sensitivity between all the sensors we've tested, allowing you to create a stable and precise high resolution smart agriculture and IoT applications. STEMinds (Short) STEMinds (Long) DFRobot Grove Seeed studio Generic v1.2 Type of sensor Capacitive Capacitive Capacitive Capacitive Capacitive Operation voltage 5V 5V 3.3~5.5V 3.3~5V 3.3-5V Min voltage output 0.987V 0.561V 2.468V 2.378V 1.022V Max voltage output 3.3V 3.3V 3.112V 3.570V 2.300V Min output value 154 106 260 494 214 Max output value 668 683 517 745 480 Operation current 7mA 7mA 5mA 8mA 6mA Resolution (high-low) 514 577 257 251 266 Please note the following regarding the testing of the soil moisture sensors that belong to other brands and the comparison between different type of sensors: All the sensors tested with Genuine Arduino Uno device using the analog pins and 5V as input. Generic v1.2 refers to generic sensors without Manufacturer or brand produced in China. (some Chinese companies sell it under their brand) Maximum voltage and output stands for the voltage when the sensor is in the open air, minimum voltage and output stands for the voltage when the sensor is submersed under water. For comparison we've purchased the original sensors from the authorized distributers. Operation current measured using Fluke multimeter. Soil moisture test results are for Educational reference only and should not be taken AS IS, different environments might bring different results, this meant to say that we can't control over other branded sensors while we can guarantee that our sensors will be at top quality and affordable price. Hardware explanation The soil moisture sensor is based on a very important component called \"capacitor\", the capacitor consist of three pieces. A positive plate, a negative plate and the space in-between the plates, known as the dielectric. The physical form and construction of practical capacitors vary widely and many capacitor types are in common use. Most capacitors contain at least two electrical conductors often in the form of metallic plates or surfaces separated by a dielectric medium. A capacitive moisture sensor works by measuring the changes in capacitance caused by the changes in the dielectric. It does not measure moisture directly (pure water does not conduct electricity well), instead it measures the ions that are dissolved in the moisture. These ions and their concentration can be affected by a number of factors, for example adding fertilizer for instance will decrease the resistance of the soil. Capacitive measuring basically measures the dielectric that is formed by the soil and the water is the most important factor that affects the dielectric. Possible applications This sensor can be used in smart agriculture related projects such as: automatic watering plant monitoring moisture sensing flood detection Plugging-in the soil moisture sensor Plugging in the sensor is deadly easy. as we use the XH2.54 interface we can simply plug and play the sensor as shown in the picture above. The sensor itself includes 3 different wires: VCC, GND and SIG (signal which is the data cable), it's important to say that the sensor itself output 5V while the ESP32 or other boards usually accept only 3.3V, if you'd like to use it in some other applications with different development boards, make sure to include a step-down circuit from 5V to 3.3V for your electronics safety. Software explanation Our soil moisture sensor is analog sensor, there are some pins on the ESP32 board that can be converted from analog to digital (ADC) and we will need to work through the process of converting the pin to become analog pin so we could read the data from the sensor. The soil moisture sensor is connected to IO PIN 35, we'll call the ADC function from the machine library to set the PIN as analog input. then, we can run .read() function directly on the PIN after configuring it, that will give us the value of the pin. In order to get accurate reading, we must tell our ESP32 what kind of voltage should it expect to get during the analog input, is it 0-1V or 0-3.3V? as we've mentioned earlier, our sensor is 0-5V sensor but in order not to damage the ESP32 board that can accept only 3.3V input into it's own IO pins we've used a step-down converted going from 5V to 3.3V. As a result, we should tell the ESP32 that it should expect voltage range of roughly 0.0V - 3.6V by using the .atten(ADC.ATTN_11DB) function for configuration. Next the final step will be to print the reading out into the terminal, try to put the sensor into the air and water and see the changes in the values. MicroPython ESP32-Arduino from machine import ADC , Pin # set adc (analog to digital) on pin 35 adc = ADC ( Pin ( 35 )) # read analog input adc . read () # set 11dB input attenuation (voltage range roughly 0.0v - 3.6v) adc . atten ( ADC . ATTN_11DB ) # print the analog results (moisture) print ( adc . read ()) #define soilMoisturePin 35 void setup () { Serial . begin ( 115200 ); } void loop () { int value = analogRead ( soilMoisturePin ); // print sensor analog value Serial . print ( \"Sensor value: \" ); Serial . print ( value ); delay ( 1000 ); } After trying the example above you might ask yourself what does this analog numbers even means, some might consider them to be \"random generated numbers\". In the following example we are going to make a little more sense out of it. We'll take the maximum value of the analog sensor which can be determined by leaving the sensor dry in the air and the minimum value by submerging the sensor completely underwater, this should give us approximately 4095 for complete dryness and 710 when the sensor is submerged underwater. Calibration is required While each sensor is the same you might want to calibrate it manually by following the instructions above and changing the values based on the values you get when you run the program. The next will be to take the 2 values and change them to percentage (0% means the plant is completely dry while 100% means it's submerged in water) In reality, this will be impossible, the soil itself will have certain amount of resistance and capacitance. It is recommended to calibrate the sensor afterwards using real life application while plotting the sensor inside of a plant / pot in wet and dry conditions. MicroPython ESP32-Arduino from machine import ADC , Pin # set max val and min val of the sensor # this requires manual calibration # minVal get be recieved by putting the sensor submerged in the water # maxVal can be recieved by making sure the sensor is dry in the clear air minVal = 710 maxVal = 4095 def value_in_percentage ( val ): # scale the value based on maxVal and minVal scale = 100 / ( minVal - maxVal ) # get calculated scale normal_reading = ( \" %s%s \" % ( int (( val - maxVal ) * scale ), \"%\" )) # we can also get inverted value if needed inverted_reading = ( \" %s%s \" % ( int (( minVal - val ) * scale ), \"%\" )) # for this example we'll return only the normal reading return normal_reading # set adc (analog to digital) on pin 35 adc = ADC ( Pin ( 35 )) # read analog input adc . read () # set 11dB input attenuation (voltage range roughly 0.0v - 3.6v) adc . atten ( ADC . ATTN_11DB ) # get sensor value value = adc . read () # print the analog results (moisture) print ( \"sensor value: %s \" % value ) print ( \"sensor value in percentage: %s \" % value_in_percentage ( value )) #define soilMoisturePin 35 void setup () { Serial . begin ( 115200 ); } int value_in_percentage ( int value ){ // set max val and min val of the sensor // this requires manual calibration // minVal get be recieved by putting the sensor submerged in the water // maxVal can be recieved by making sure the sensor is dry in the clear air float minVal = 710 ; float maxVal = 4095 ; //scale the value based on maxVal and minVal float scale = 100.00 / ( minVal - maxVal ); //get calculated scale int normal_reading = ( value - maxVal ) * scale ; // we can also get inverted value if needed int inverted_reading = ( minVal - value ) * scale ; // for this example we'll return only the normal reading return normal_reading ; } void loop () { int value = analogRead ( soilMoisturePin ); int estimated = value_in_percentage ( value ); // print sensor analog value Serial . print ( \"Sensor value: \" ); Serial . print ( value ); // print sensor value in precentage Serial . print ( \"Sensor value in precentage: \" ); Serial . print ( estimated ); Serial . println ( \"%\" ); delay ( 1000 ); }","title":"Soil moisture sensor"},{"location":"kits/eduponics_mini/basic_sensors_usage/soil_moisture_sensor/#steminds-soil-moisture-sensor","text":"Our sensor is one of a kind, we truly love that sensor and hope other people can use it as much as we do. We've been looking for quite some time for a soil moisture stable sensor for smart agriculture / smart plants related projects but couldn't find any. We've tested over 10 sensors available in the market till we've decided to make our own. let's go through the information to understand why our sensor is different and why it's better than other alternatives.","title":"STEMinds Soil moisture sensor"},{"location":"kits/eduponics_mini/basic_sensors_usage/soil_moisture_sensor/#specifications","text":"During the process of testing and finding the perfect soil moisture sensor for our Eduponics Mini kit we found out that other existing sensors and solution just don't work to our high expectation. here is some of the specification of our custom made sensor: Wide range of reading (about 1024 to 4060 in scale of analog reading) Water-proof and dust-proof, self-tested submerged for 24 hours. Powered by 5V input/output Highly accurate, useful for industrial and real life applications.","title":"Specifications"},{"location":"kits/eduponics_mini/basic_sensors_usage/soil_moisture_sensor/#comparison-to-other-sensors","text":"While looking for soil moisture sensors to use with our kit, we encountered a severe challenge - the sensors were just not good enough. We've purchased and tested multiple sensors till the decision was made to make our own. Take a look at the comparison below, our sensor has the highest voltage range and sensitivity between all the sensors we've tested, allowing you to create a stable and precise high resolution smart agriculture and IoT applications. STEMinds (Short) STEMinds (Long) DFRobot Grove Seeed studio Generic v1.2 Type of sensor Capacitive Capacitive Capacitive Capacitive Capacitive Operation voltage 5V 5V 3.3~5.5V 3.3~5V 3.3-5V Min voltage output 0.987V 0.561V 2.468V 2.378V 1.022V Max voltage output 3.3V 3.3V 3.112V 3.570V 2.300V Min output value 154 106 260 494 214 Max output value 668 683 517 745 480 Operation current 7mA 7mA 5mA 8mA 6mA Resolution (high-low) 514 577 257 251 266 Please note the following regarding the testing of the soil moisture sensors that belong to other brands and the comparison between different type of sensors: All the sensors tested with Genuine Arduino Uno device using the analog pins and 5V as input. Generic v1.2 refers to generic sensors without Manufacturer or brand produced in China. (some Chinese companies sell it under their brand) Maximum voltage and output stands for the voltage when the sensor is in the open air, minimum voltage and output stands for the voltage when the sensor is submersed under water. For comparison we've purchased the original sensors from the authorized distributers. Operation current measured using Fluke multimeter. Soil moisture test results are for Educational reference only and should not be taken AS IS, different environments might bring different results, this meant to say that we can't control over other branded sensors while we can guarantee that our sensors will be at top quality and affordable price.","title":"Comparison to other sensors"},{"location":"kits/eduponics_mini/basic_sensors_usage/soil_moisture_sensor/#hardware-explanation","text":"The soil moisture sensor is based on a very important component called \"capacitor\", the capacitor consist of three pieces. A positive plate, a negative plate and the space in-between the plates, known as the dielectric. The physical form and construction of practical capacitors vary widely and many capacitor types are in common use. Most capacitors contain at least two electrical conductors often in the form of metallic plates or surfaces separated by a dielectric medium. A capacitive moisture sensor works by measuring the changes in capacitance caused by the changes in the dielectric. It does not measure moisture directly (pure water does not conduct electricity well), instead it measures the ions that are dissolved in the moisture. These ions and their concentration can be affected by a number of factors, for example adding fertilizer for instance will decrease the resistance of the soil. Capacitive measuring basically measures the dielectric that is formed by the soil and the water is the most important factor that affects the dielectric.","title":"Hardware explanation"},{"location":"kits/eduponics_mini/basic_sensors_usage/soil_moisture_sensor/#possible-applications","text":"This sensor can be used in smart agriculture related projects such as: automatic watering plant monitoring moisture sensing flood detection","title":"Possible applications"},{"location":"kits/eduponics_mini/basic_sensors_usage/soil_moisture_sensor/#plugging-in-the-soil-moisture-sensor","text":"Plugging in the sensor is deadly easy. as we use the XH2.54 interface we can simply plug and play the sensor as shown in the picture above. The sensor itself includes 3 different wires: VCC, GND and SIG (signal which is the data cable), it's important to say that the sensor itself output 5V while the ESP32 or other boards usually accept only 3.3V, if you'd like to use it in some other applications with different development boards, make sure to include a step-down circuit from 5V to 3.3V for your electronics safety.","title":"Plugging-in the soil moisture sensor"},{"location":"kits/eduponics_mini/basic_sensors_usage/soil_moisture_sensor/#software-explanation","text":"Our soil moisture sensor is analog sensor, there are some pins on the ESP32 board that can be converted from analog to digital (ADC) and we will need to work through the process of converting the pin to become analog pin so we could read the data from the sensor. The soil moisture sensor is connected to IO PIN 35, we'll call the ADC function from the machine library to set the PIN as analog input. then, we can run .read() function directly on the PIN after configuring it, that will give us the value of the pin. In order to get accurate reading, we must tell our ESP32 what kind of voltage should it expect to get during the analog input, is it 0-1V or 0-3.3V? as we've mentioned earlier, our sensor is 0-5V sensor but in order not to damage the ESP32 board that can accept only 3.3V input into it's own IO pins we've used a step-down converted going from 5V to 3.3V. As a result, we should tell the ESP32 that it should expect voltage range of roughly 0.0V - 3.6V by using the .atten(ADC.ATTN_11DB) function for configuration. Next the final step will be to print the reading out into the terminal, try to put the sensor into the air and water and see the changes in the values. MicroPython ESP32-Arduino from machine import ADC , Pin # set adc (analog to digital) on pin 35 adc = ADC ( Pin ( 35 )) # read analog input adc . read () # set 11dB input attenuation (voltage range roughly 0.0v - 3.6v) adc . atten ( ADC . ATTN_11DB ) # print the analog results (moisture) print ( adc . read ()) #define soilMoisturePin 35 void setup () { Serial . begin ( 115200 ); } void loop () { int value = analogRead ( soilMoisturePin ); // print sensor analog value Serial . print ( \"Sensor value: \" ); Serial . print ( value ); delay ( 1000 ); } After trying the example above you might ask yourself what does this analog numbers even means, some might consider them to be \"random generated numbers\". In the following example we are going to make a little more sense out of it. We'll take the maximum value of the analog sensor which can be determined by leaving the sensor dry in the air and the minimum value by submerging the sensor completely underwater, this should give us approximately 4095 for complete dryness and 710 when the sensor is submerged underwater. Calibration is required While each sensor is the same you might want to calibrate it manually by following the instructions above and changing the values based on the values you get when you run the program. The next will be to take the 2 values and change them to percentage (0% means the plant is completely dry while 100% means it's submerged in water) In reality, this will be impossible, the soil itself will have certain amount of resistance and capacitance. It is recommended to calibrate the sensor afterwards using real life application while plotting the sensor inside of a plant / pot in wet and dry conditions. MicroPython ESP32-Arduino from machine import ADC , Pin # set max val and min val of the sensor # this requires manual calibration # minVal get be recieved by putting the sensor submerged in the water # maxVal can be recieved by making sure the sensor is dry in the clear air minVal = 710 maxVal = 4095 def value_in_percentage ( val ): # scale the value based on maxVal and minVal scale = 100 / ( minVal - maxVal ) # get calculated scale normal_reading = ( \" %s%s \" % ( int (( val - maxVal ) * scale ), \"%\" )) # we can also get inverted value if needed inverted_reading = ( \" %s%s \" % ( int (( minVal - val ) * scale ), \"%\" )) # for this example we'll return only the normal reading return normal_reading # set adc (analog to digital) on pin 35 adc = ADC ( Pin ( 35 )) # read analog input adc . read () # set 11dB input attenuation (voltage range roughly 0.0v - 3.6v) adc . atten ( ADC . ATTN_11DB ) # get sensor value value = adc . read () # print the analog results (moisture) print ( \"sensor value: %s \" % value ) print ( \"sensor value in percentage: %s \" % value_in_percentage ( value )) #define soilMoisturePin 35 void setup () { Serial . begin ( 115200 ); } int value_in_percentage ( int value ){ // set max val and min val of the sensor // this requires manual calibration // minVal get be recieved by putting the sensor submerged in the water // maxVal can be recieved by making sure the sensor is dry in the clear air float minVal = 710 ; float maxVal = 4095 ; //scale the value based on maxVal and minVal float scale = 100.00 / ( minVal - maxVal ); //get calculated scale int normal_reading = ( value - maxVal ) * scale ; // we can also get inverted value if needed int inverted_reading = ( minVal - value ) * scale ; // for this example we'll return only the normal reading return normal_reading ; } void loop () { int value = analogRead ( soilMoisturePin ); int estimated = value_in_percentage ( value ); // print sensor analog value Serial . print ( \"Sensor value: \" ); Serial . print ( value ); // print sensor value in precentage Serial . print ( \"Sensor value in precentage: \" ); Serial . print ( estimated ); Serial . println ( \"%\" ); delay ( 1000 ); }","title":"Software explanation"},{"location":"kits/eduponics_mini/basic_sensors_usage/water_quantity_sensor/","text":"Water liquid level sensor No contact with liquid makes the module suitable for hazardous applications such as detecting toxic substances, strong acid, strong alkali and all kinds of liquid in an air tight container under high pressure. It's an industrial grade IP65 certified sensor that could be used for many industrial applications. Specifications Note that the sensor accepts 5V input and gives 5V output, in the Eduponics Mini kit we've added a voltage step-down from 5V to 3.3V, if you want to use the sensor for other applications that require microcontrollers you should consider adding a step-down circuit as well to prevent damage to your electronics. Some of the cool features the sensor has: Red LED Indicator (have water LED is on, no water LED is off) Intelligent liquid level sensitivity adjustment High stability, high sensitivity, strong interference ability, Protection from external electromagnetic interference Strong compatibility, through a variety of non-metallic containers Sensing distance of around 12mm; Ability to detect liquid, powder or particles. Possible applications Because the sensor is an external sensor, it allows us to monitor things without exposing the sensor to the water, some of the most useful applications could be: Monitor water level for general purpose Monitor if there is a flow of water in a pipe (water go through) Monitor drinking water in the coffee machine / pet bowl Monitor water level inside aquarium, refill if needed. Monitor dangerous chemicals (liquids) Connection diagram The sensor can be attached to any non-metal surface which means plastic, glass, ceramic, rubber and more ... The sensor sensitivity can be adjust so the sensor can both sense through thick and thin material, whatever your water container is - we got your back. our sensor should be able to sense beyond most common materials. Another option would be to attach a silicon or glue on the front side of the sensor to attach it with a distance or directly to the plastic surface where metal surface is present. In our kit, we've included a special glue circles that can be glued on the sensor itself so it can be attached with ease to any surface. Metal surfaces note Don't attach the sensor directly to metal surface, it won't work. it will work just fine with plastic, glass ceramic and more, for metal you'll need a plastic or other material connector between the two metal sides, look at the second picture for reference. Sensitivity adjustment In some cases, sensitivity adjustment might be required. this is due to different material or different thickness of the water container. don't you worry, this can be easily done but taking off the cover where the indication LED is and softly using a screw driver to adjust the sensitivity of the sensor. Rotate clockwise to reduce the sensitivity and to the opposite direction to increase it. you can use water inside of the container to see which one works best for you, when there is water the sensor LED should be turned on. Hardware explanation The Non-contact type liquid level sensor, utilizes advance signal processing technology by using a powerful chip with high-speed operation capacity to achieve non-contact liquid level detection. The sensor itself have 4 pins: GND, VCC, DATA and Natural that we don't connect. The sensor requires 5V input to operate and it will output 5V as well, as the ESP32 IO pins can only withstand 3.3V over the IO pins we added voltage step down from 5V to 3.3V, this is something you need to remember in case you want to use the sensor with different hardware and different applications. 5V to 3.3V step down is required for other usages If you want to use the sensor with Arduino or Raspberry Pi in different projects, make sure to step the voltage down from 5V output to 3.3V or lower to prevent damage to the IO pins of your micro-controller. This step down circuit already included in Eduponics mini development board so you don't need to worry about it. Plugging-in the water quantity sensor Plugging in the sensor is very straight forward, using the XH2.54 interface we can plug it right in. the sensor have 4 pins in total: GND, VCC, DATA and NO (natural pin that we connect to ground as well). If the Eduponics Mini board is powered on using either DC12V or USB Type-C or both and the sensor isn't connected to any surface the LED on top of the sensor should glow RED, once it touch a liquid surface such as bottle of water with water inside the LED will turn off. Software explanation The code is very straight forward, the water level sensor is connected to IO pin number 21. we'll set this pin as input and create a function called is_empty() the sensor will return 0 if he can detect water and 1 if there is no water detected. which means, the function is_empty() will return True if the water container is empty or False if the water container is full. Finally, we'll use the function to print into the console if the state of our water container. MicroPython ESP32-Arduino import machine # define water level sensor as INPUT on IO pin number 21 water_level = machine . Pin ( 21 , machine . Pin . IN ) # this function will return 0 if container have no water and 1 if it has water def is_empty (): return water_level . value () # check if the water container is empty is not if ( is_empty ()): print ( \"The water container is empty\" ) else : print ( \"The water container is full\" ) // set the water sensor on IO pin number 21 const int water_sensor = 21 ; void setup () { Serial . begin ( 115200 ); // configure pump as output pinMode ( water_sensor , INPUT ); } int is_empty (){ return digitalRead ( water_sensor ); } void loop () { // if digital read is 0 means no water // if digital read is 1 means there is water if ( is_empty ()){ Serial . println ( \"The water container is empty\" ); } else { Serial . println ( \"The water container is full\" ); } // wait 100 miliseconds and check again delay ( 100 ); }","title":"Water level sensor"},{"location":"kits/eduponics_mini/basic_sensors_usage/water_quantity_sensor/#water-liquid-level-sensor","text":"No contact with liquid makes the module suitable for hazardous applications such as detecting toxic substances, strong acid, strong alkali and all kinds of liquid in an air tight container under high pressure. It's an industrial grade IP65 certified sensor that could be used for many industrial applications.","title":"Water liquid level sensor"},{"location":"kits/eduponics_mini/basic_sensors_usage/water_quantity_sensor/#specifications","text":"Note that the sensor accepts 5V input and gives 5V output, in the Eduponics Mini kit we've added a voltage step-down from 5V to 3.3V, if you want to use the sensor for other applications that require microcontrollers you should consider adding a step-down circuit as well to prevent damage to your electronics. Some of the cool features the sensor has: Red LED Indicator (have water LED is on, no water LED is off) Intelligent liquid level sensitivity adjustment High stability, high sensitivity, strong interference ability, Protection from external electromagnetic interference Strong compatibility, through a variety of non-metallic containers Sensing distance of around 12mm; Ability to detect liquid, powder or particles.","title":"Specifications"},{"location":"kits/eduponics_mini/basic_sensors_usage/water_quantity_sensor/#possible-applications","text":"Because the sensor is an external sensor, it allows us to monitor things without exposing the sensor to the water, some of the most useful applications could be: Monitor water level for general purpose Monitor if there is a flow of water in a pipe (water go through) Monitor drinking water in the coffee machine / pet bowl Monitor water level inside aquarium, refill if needed. Monitor dangerous chemicals (liquids)","title":"Possible applications"},{"location":"kits/eduponics_mini/basic_sensors_usage/water_quantity_sensor/#connection-diagram","text":"The sensor can be attached to any non-metal surface which means plastic, glass, ceramic, rubber and more ... The sensor sensitivity can be adjust so the sensor can both sense through thick and thin material, whatever your water container is - we got your back. our sensor should be able to sense beyond most common materials. Another option would be to attach a silicon or glue on the front side of the sensor to attach it with a distance or directly to the plastic surface where metal surface is present. In our kit, we've included a special glue circles that can be glued on the sensor itself so it can be attached with ease to any surface. Metal surfaces note Don't attach the sensor directly to metal surface, it won't work. it will work just fine with plastic, glass ceramic and more, for metal you'll need a plastic or other material connector between the two metal sides, look at the second picture for reference.","title":"Connection diagram"},{"location":"kits/eduponics_mini/basic_sensors_usage/water_quantity_sensor/#sensitivity-adjustment","text":"In some cases, sensitivity adjustment might be required. this is due to different material or different thickness of the water container. don't you worry, this can be easily done but taking off the cover where the indication LED is and softly using a screw driver to adjust the sensitivity of the sensor. Rotate clockwise to reduce the sensitivity and to the opposite direction to increase it. you can use water inside of the container to see which one works best for you, when there is water the sensor LED should be turned on.","title":"Sensitivity adjustment"},{"location":"kits/eduponics_mini/basic_sensors_usage/water_quantity_sensor/#hardware-explanation","text":"The Non-contact type liquid level sensor, utilizes advance signal processing technology by using a powerful chip with high-speed operation capacity to achieve non-contact liquid level detection. The sensor itself have 4 pins: GND, VCC, DATA and Natural that we don't connect. The sensor requires 5V input to operate and it will output 5V as well, as the ESP32 IO pins can only withstand 3.3V over the IO pins we added voltage step down from 5V to 3.3V, this is something you need to remember in case you want to use the sensor with different hardware and different applications. 5V to 3.3V step down is required for other usages If you want to use the sensor with Arduino or Raspberry Pi in different projects, make sure to step the voltage down from 5V output to 3.3V or lower to prevent damage to the IO pins of your micro-controller. This step down circuit already included in Eduponics mini development board so you don't need to worry about it.","title":"Hardware explanation"},{"location":"kits/eduponics_mini/basic_sensors_usage/water_quantity_sensor/#plugging-in-the-water-quantity-sensor","text":"Plugging in the sensor is very straight forward, using the XH2.54 interface we can plug it right in. the sensor have 4 pins in total: GND, VCC, DATA and NO (natural pin that we connect to ground as well). If the Eduponics Mini board is powered on using either DC12V or USB Type-C or both and the sensor isn't connected to any surface the LED on top of the sensor should glow RED, once it touch a liquid surface such as bottle of water with water inside the LED will turn off.","title":"Plugging-in the water quantity sensor"},{"location":"kits/eduponics_mini/basic_sensors_usage/water_quantity_sensor/#software-explanation","text":"The code is very straight forward, the water level sensor is connected to IO pin number 21. we'll set this pin as input and create a function called is_empty() the sensor will return 0 if he can detect water and 1 if there is no water detected. which means, the function is_empty() will return True if the water container is empty or False if the water container is full. Finally, we'll use the function to print into the console if the state of our water container. MicroPython ESP32-Arduino import machine # define water level sensor as INPUT on IO pin number 21 water_level = machine . Pin ( 21 , machine . Pin . IN ) # this function will return 0 if container have no water and 1 if it has water def is_empty (): return water_level . value () # check if the water container is empty is not if ( is_empty ()): print ( \"The water container is empty\" ) else : print ( \"The water container is full\" ) // set the water sensor on IO pin number 21 const int water_sensor = 21 ; void setup () { Serial . begin ( 115200 ); // configure pump as output pinMode ( water_sensor , INPUT ); } int is_empty (){ return digitalRead ( water_sensor ); } void loop () { // if digital read is 0 means no water // if digital read is 1 means there is water if ( is_empty ()){ Serial . println ( \"The water container is empty\" ); } else { Serial . println ( \"The water container is full\" ); } // wait 100 miliseconds and check again delay ( 100 ); }","title":"Software explanation"},{"location":"kits/mindev_kit/3.3_5V_converter_breadboard_module/","text":"","title":"3.3 5V converter breadboard module"},{"location":"kits/mindev_kit/7_segment_led/","text":"7 Segment LED Features Hardware explained Raspberry Pi wiring diagram Arduino wiring diagram ESP32 / ESP8266 wiring diagram Software explained Python3 MicroPython ESP32-Arduino Arduino IDE","title":"STEMinds - 7 Segment LED"},{"location":"kits/mindev_kit/7_segment_led/#7-segment-led","text":"","title":"7 Segment LED"},{"location":"kits/mindev_kit/7_segment_led/#features","text":"","title":"Features"},{"location":"kits/mindev_kit/7_segment_led/#hardware-explained","text":"","title":"Hardware explained"},{"location":"kits/mindev_kit/7_segment_led/#raspberry-pi-wiring-diagram","text":"","title":"Raspberry Pi wiring diagram"},{"location":"kits/mindev_kit/7_segment_led/#arduino-wiring-diagram","text":"","title":"Arduino wiring diagram"},{"location":"kits/mindev_kit/7_segment_led/#esp32-esp8266-wiring-diagram","text":"","title":"ESP32 / ESP8266 wiring diagram"},{"location":"kits/mindev_kit/7_segment_led/#software-explained","text":"Python3 MicroPython ESP32-Arduino Arduino IDE","title":"Software explained"},{"location":"kits/mindev_kit/HC_SR04_ultrasonic_sensor/","text":"","title":"HC SR04 ultrasonic sensor"},{"location":"kits/mindev_kit/IR_sensors/","text":"","title":"IR sensors"},{"location":"kits/mindev_kit/LCD_IIC_1602_module/","text":"","title":"LCD IIC 1602 module"},{"location":"kits/mindev_kit/MCP3008_adc/","text":"","title":"MCP3008 adc"},{"location":"kits/mindev_kit/MPU6050_gyro_and_accelerometer/","text":"","title":"MPU6050 gyro and accelerometer"},{"location":"kits/mindev_kit/Methane_CH4_gas_sensor/","text":"","title":"Methane CH4 gas sensor"},{"location":"kits/mindev_kit/PIR_motion_sensor/","text":"","title":"PIR motion sensor"},{"location":"kits/mindev_kit/RC522_module/","text":"","title":"RC522 module"},{"location":"kits/mindev_kit/RGB_LED/","text":"","title":"RGB LED"},{"location":"kits/mindev_kit/SD_Card_module/","text":"","title":"SD Card module"},{"location":"kits/mindev_kit/TCS3200_color_recognition_sensor/","text":"","title":"TCS3200 color recognition sensor"},{"location":"kits/mindev_kit/alcohol_gas_sensor/","text":"Alcohol gas sensor Features Hardware explained Raspberry Pi wiring diagram Arduino wiring diagram ESP32 / ESP8266 wiring diagram Software explained Python3 MicroPython ESP32-Arduino Arduino IDE","title":"STEMinds - Alcohol gas sensor"},{"location":"kits/mindev_kit/alcohol_gas_sensor/#alcohol-gas-sensor","text":"","title":"Alcohol gas sensor"},{"location":"kits/mindev_kit/alcohol_gas_sensor/#features","text":"","title":"Features"},{"location":"kits/mindev_kit/alcohol_gas_sensor/#hardware-explained","text":"","title":"Hardware explained"},{"location":"kits/mindev_kit/alcohol_gas_sensor/#raspberry-pi-wiring-diagram","text":"","title":"Raspberry Pi wiring diagram"},{"location":"kits/mindev_kit/alcohol_gas_sensor/#arduino-wiring-diagram","text":"","title":"Arduino wiring diagram"},{"location":"kits/mindev_kit/alcohol_gas_sensor/#esp32-esp8266-wiring-diagram","text":"","title":"ESP32 / ESP8266 wiring diagram"},{"location":"kits/mindev_kit/alcohol_gas_sensor/#software-explained","text":"Python3 MicroPython ESP32-Arduino Arduino IDE","title":"Software explained"},{"location":"kits/mindev_kit/ball_switch/","text":"Ball Switch Features Hardware explained Raspberry Pi wiring diagram Arduino wiring diagram ESP32 / ESP8266 wiring diagram Software explained Python3 MicroPython ESP32-Arduino Arduino IDE","title":"STEMinds - Ball switch"},{"location":"kits/mindev_kit/ball_switch/#ball-switch","text":"","title":"Ball Switch"},{"location":"kits/mindev_kit/ball_switch/#features","text":"","title":"Features"},{"location":"kits/mindev_kit/ball_switch/#hardware-explained","text":"","title":"Hardware explained"},{"location":"kits/mindev_kit/ball_switch/#raspberry-pi-wiring-diagram","text":"","title":"Raspberry Pi wiring diagram"},{"location":"kits/mindev_kit/ball_switch/#arduino-wiring-diagram","text":"","title":"Arduino wiring diagram"},{"location":"kits/mindev_kit/ball_switch/#esp32-esp8266-wiring-diagram","text":"","title":"ESP32 / ESP8266 wiring diagram"},{"location":"kits/mindev_kit/ball_switch/#software-explained","text":"Python3 MicroPython ESP32-Arduino Arduino IDE","title":"Software explained"},{"location":"kits/mindev_kit/buttons/","text":"Buttons Features Hardware explained Raspberry Pi wiring diagram Arduino wiring diagram ESP32 / ESP8266 wiring diagram Software explained Python3 MicroPython ESP32-Arduino Arduino IDE","title":"STEMinds - Buttons"},{"location":"kits/mindev_kit/buttons/#buttons","text":"","title":"Buttons"},{"location":"kits/mindev_kit/buttons/#features","text":"","title":"Features"},{"location":"kits/mindev_kit/buttons/#hardware-explained","text":"","title":"Hardware explained"},{"location":"kits/mindev_kit/buttons/#raspberry-pi-wiring-diagram","text":"","title":"Raspberry Pi wiring diagram"},{"location":"kits/mindev_kit/buttons/#arduino-wiring-diagram","text":"","title":"Arduino wiring diagram"},{"location":"kits/mindev_kit/buttons/#esp32-esp8266-wiring-diagram","text":"","title":"ESP32 / ESP8266 wiring diagram"},{"location":"kits/mindev_kit/buttons/#software-explained","text":"Python3 MicroPython ESP32-Arduino Arduino IDE","title":"Software explained"},{"location":"kits/mindev_kit/buzzers/","text":"Buzzers In the Mindev kit we've attached 2 different buzzers that utilizes two main technologies. Each technology has specific advantages and tradeoffs that must be taken into consideration depending on the application requirements. In this lesson we'll learn how to use and control the buzzer and what's the electronic principles of the buzzer is working on, at the end you'll be able to use the active buzzer to play basic on/off buzzing noise and the passive buzzer to play a nice melody! Features There are 2 different buzzer types: Piezo buzzer and Magnetic buzzer, let's take a look at each of their features. Piezo buzzer (Active buzzer) Wide operating voltage: 3~250 V Lower current consumption: less than 30 mA higher rated frequency Larger footprint Higher sound pressure level Magnetic buzzer (Passive buzzer) Narrow operating voltage: 1~16 V Higher current consumption: 30~100 mA Lower rated frequency Smaller footprint Lower sound pressure level Hardware explained As we've mentioned we've included 2 different buzzers with the kit, let's walk on each buzzer principles to understand how it works and what drives it to make that buzzing noise we all like to hear. Piezo buzzer (Active buzzer) At the heart of the piezo-type buzzers there is the piezoelectric element. Piezoelectric element is composed of a piezoelectric ceramic and a metal plate held together with adhesive. Both sides of the piezoelectric ceramic plate contain an electrode for electrical conduction. Piezo materials exhibit a specific phenomenon known as the piezoelectric effect and the reverse piezoelectric effect. Exposure to mechanical strain will cause the material to develop an electric field, and vice versa. When an alternating voltage is applied to the piezoceramic element, the element extends and shrinks diametrically. This characteristic of piezoelectric material is utilized to make the ceramic plate vibrate rapidly to generate sound waves. There are two types of piezo buzzers - transducers and indicators. Transducers consist of a casing, a piezoceramic element and a terminal. In order to operate a transducer, the user must send a square wave signal to the buzzer. Indicators consist of a casing, a piezoceramic element, a circuit board and a terminal. In order to operate an indicator, the user must send the buzzer a specified dc voltage. Magnetic buzzer (Passive buzzer) The illustration below highlights the structure of a typical magnetic buzzer. Like piezo technology, magnetic buzzers are available in transducer and indicator configurations. In a magnetic buzzer, the transistor acts as the driving circuit. Indicators include the transistor, creating a tone when a dc voltage is applied. Transducers lack this transistor, requiring a square wave signal to operate properly. The vibrating disk in a magnetic buzzer is attracted to the pole by the magnetic field. When an oscillating signal is moved through the coil, it produces a fluctuating magnetic field which vibrates the disk at a frequency equal to that of the drive signal. Diagrams After we've learned about the buzzer types and elements, it's time to connect the buzzer to our microcontroller and get it going. depends on what controller you are using (such as Raspberry Pi, Arduino, ESP etc ..) you'll need different diagrams. below we'll show you how to attach the buzzer in different diagram to a different controller. Raspberry Pi wiring diagram As the Raspberry Pi diagram shows, our buzzer have 2 wires one is GND and one is VCC, the VCC can be controlled by 3.3V which means we can connect it to the GPIO pins directly. In our Diagram we choose to connect the VCC pin of the buzzer to the Raspberry Pi GPIO4 pin. The black wire (GND) from the buzzer go to the ground pin on the raspberry pi. Arduino wiring diagram Similar to the raspberry Pi diagram, in the Arduino diagram our buzzer also have 2 pins (obviously). For the Arduino we'll connect the positive (VCC) pin from the buzzer to the Digital Pin number 8 on the Arduino while the negative pin (GND) will go to the ground pin on the Arduino, that way we can output digital signal to the Arduino and control the buzzer similar to the Raspberry Pi GPIO principle. ESP32 / ESP8266 wiring diagram For the ESP we'll connect the positive wire from the buzzer to D5 (digital 5) pin on the ESP board while connecting the GND wire from the buzzer to the ground point in order to close the circuit, the same principle goes here and when controlling the buzzer we always use digital output pins. Software explained Let's show an example of the 2 different buzzers, one is the active buzzer to create a simple buzzing noise and the other one is the passive buzzer which we can use to play music with by playing it using a specific frequency. Piezo buzzer (Active buzzer) The piezo buzzer is fairly easy as we just need to supply 3.3-5V to it and it will work right away, we can use GPIO pins in raspberry pi or IO pins in ESP or just digital pins in Arduino, all will work perfectly fine. Example code The code is very straight forward and available for all the platforms Python3 MicroPython ESP32-Arduino Arduino IDE #!/usr/bin/python # -*- coding: utf-8 -*- import RPi.GPIO as GPIO import time buzzer_pin = 4 GPIO . setmode ( GPIO . BCM ) GPIO . setup ( buzzer_pin , GPIO . OUT ) # Make buzzer sound GPIO . output ( buzzer_pin , GPIO . HIGH ) time . sleep ( 0.5 ) # Stop buzzer sound GPIO . output ( buzzer_pin , GPIO . LOW ) GPIO . cleanup () import machine import time # define buzzer on pin IO5 (digital 5) as OUTPUT buzzer = machine . Pin ( 5 , machine . Pin . OUT ) # define sleep interval as 3 seconds sleep_interval = 1 # turn on the buzzer buzzer . value ( 1 ) # wait for the defined sleep interval time . sleep ( sleep_interval ) # turn off the buzzer buzzer . value ( 0 ) // define buzzer on pin IO5 (digital 5) as OUTPUT const int buzzer = 5 ; void setup () { pinMode ( buzzer , OUTPUT ); // Set buzzer - pin 5 as an output } void loop () { // turn on the buzzer digitalWrite ( buzzer , HIGH ); Serial . println ( \"Buzzer is HIGH\" ); delay ( 1000 ); // turn off the buzzer digitalWrite ( buzzer , LOW ); Serial . println ( \"Buzzer is LOW\" ); delay ( 1000 ); } const int buzzer = 8 ; //buzzer to arduino pin 8 void setup (){ pinMode ( buzzer , OUTPUT ); // Set buzzer - pin 8 as an output } void loop (){ tone ( buzzer , 1000 ); // Send 1KHz sound signal... delay ( 1000 ); // ...for 1 sec noTone ( buzzer ); // Stop sound... delay ( 1000 ); // ...for 1sec } Magnetic buzzer (Passive buzzer) For this example we'll be taking a .midi file and converting it to Arduino / Raspberry Pi code to allow us to play a song using the Magnetic buzzer. To do it, we'll download a custom midi file and we will use a website to convert the midi file to code. For the Raspberry Pi example we'll need to use the software PWN (not the normal GPIO we've used earlier with the active buzzer) this is due to the passive buzzer characteristic that requires square waves in order to operate it and not just a constant DC voltage. Finding midi file to play There are a lot of websites that offer free midi files, for our tutorial we'll be using the \"Harry Potter theme song\" midi file downloaded from here: Harry potter theme song midi file you can download any midi file you want and we will use it later in our conversion process for Arduino / Raspberry Pi code Example code below uses Harry potter theme midi The example code below uses the midi file we've downloaded from the link previously given, if you want other tunes you'll need to download your own midi file and convert it manually. Converting midi to code In order to convert the midi file to code we'll use the following free website: ExtraMaster MiDi to Arduino / Raspberry Pi this will allow us to convert any midi file into code in seconds. First step, download your midi file. once you have it go to the website and upload it, then click submit: Next step will be to select the midi file to extract, make sure you choose the one that doesn't say \"unknown\", most often you can leave it as default and there shouldn't be any troubles. Finally choose the format you want to convert to. do you want to use Raspberry Pi? Arduino? Unfortunately, the website does not offer support to ESP-Arduino or MicroPython but this can be easily solved by small modifications. For MicroPython modify the Raspberry Pi python code and for ESP-Arduino modify the Arduino C++ Code, this should be fairly easy. Example code Below is the example code based on the Harry Potter theme song midi file, if you'd like to use different tune - convert it yourself by using the steps we've explained above. Python3 MicroPython ESP32-Arduino Arduino IDE ## Credit: ## Midi to Raspberry Pi Converter ## - Andy Tran (extramaster), 2015 ## https://www.extramaster.net/tools/midiToArduino/ ## ## Process: ## Midi -> Midi tracks -> Note mappings -> Frequency ## ## CC0 import RPi.GPIO as GPIO import time # Set this to be the pin that your buzzer resides in. (Note that you can only have one buzzer actively using the PWM signal at a time). # GD = GND = Ground # RPI v1 GPIO Layout BCM # 5V 5V GD 14 15 18 GD 23 24 GD 25 08 07 # 3V 02 03 04 GD 17 27 22 3V 10 09 11 GD # RPI v2 GPIO Layout BCM # 5V 5V GD 14 15 18 GD 23 24 GD 25 08 07 SC GD 12 GD 16 20 21 # 3V 02 03 04 GD 17 27 22 3V 10 09 11 GD SD 05 06 13 19 26 GD # Note: Raspberry Pi 2 seems to handle software-PWM a lot better then the original Raspberry Pis. tonePin = 4 GPIO . setmode ( GPIO . BCM ) GPIO . setup ( tonePin , GPIO . IN ) GPIO . setup ( tonePin , GPIO . OUT ) p = GPIO . PWM ( tonePin , 100 ) # High-level abstraction of the Arduino's Delay function def delay ( times ): time . sleep ( times / 1000.0 ) # High-level abstraction of the Arduino's Tone function, though this version is blocking def tone ( pin , pitch , duration ): if pitch == 0 : delay ( duration ) return p = GPIO . PWM ( tonePin , pitch ) # Change the duty-cycle to 50 if you wish p . start ( 30 ) delay ( duration ) p . stop () # Delay used to discourage overlap of PWM cycles delay ( 2 ) def midi (): tone ( tonePin , 493 , 249.99975 ) tone ( tonePin , 659 , 374.999625 ) tone ( tonePin , 783 , 124.999875 ) tone ( tonePin , 739 , 249.99975 ) tone ( tonePin , 659 , 499.9995 ) tone ( tonePin , 987 , 249.99975 ) tone ( tonePin , 880 , 749.99925 ) tone ( tonePin , 739 , 749.99925 ) tone ( tonePin , 659 , 374.999625 ) tone ( tonePin , 783 , 124.999875 ) tone ( tonePin , 739 , 249.99975 ) tone ( tonePin , 587 , 499.9995 ) tone ( tonePin , 698 , 249.99975 ) tone ( tonePin , 493 , 1249.99875 ) tone ( tonePin , 493 , 249.99975 ) tone ( tonePin , 659 , 374.999625 ) tone ( tonePin , 783 , 124.999875 ) tone ( tonePin , 739 , 249.99975 ) tone ( tonePin , 659 , 499.9995 ) tone ( tonePin , 987 , 249.99975 ) tone ( tonePin , 1174 , 499.9995 ) tone ( tonePin , 1108 , 249.99975 ) tone ( tonePin , 1046 , 499.9995 ) tone ( tonePin , 830 , 249.99975 ) tone ( tonePin , 1046 , 374.999625 ) tone ( tonePin , 987 , 124.999875 ) tone ( tonePin , 932 , 249.99975 ) tone ( tonePin , 739 , 499.9995 ) tone ( tonePin , 783 , 249.99975 ) tone ( tonePin , 659 , 1249.99875 ) tone ( tonePin , 783 , 249.99975 ) tone ( tonePin , 987 , 499.9995 ) tone ( tonePin , 783 , 249.99975 ) tone ( tonePin , 987 , 499.9995 ) tone ( tonePin , 783 , 249.99975 ) tone ( tonePin , 1046 , 499.9995 ) tone ( tonePin , 987 , 249.99975 ) tone ( tonePin , 932 , 499.9995 ) tone ( tonePin , 739 , 249.99975 ) tone ( tonePin , 783 , 374.999625 ) tone ( tonePin , 987 , 124.999875 ) tone ( tonePin , 932 , 249.99975 ) tone ( tonePin , 466 , 499.9995 ) tone ( tonePin , 493 , 249.99975 ) tone ( tonePin , 987 , 1249.99875 ) tone ( tonePin , 783 , 249.99975 ) tone ( tonePin , 987 , 499.9995 ) tone ( tonePin , 783 , 249.99975 ) tone ( tonePin , 987 , 499.9995 ) tone ( tonePin , 783 , 249.99975 ) tone ( tonePin , 1174 , 499.9995 ) tone ( tonePin , 1108 , 249.99975 ) tone ( tonePin , 1046 , 499.9995 ) tone ( tonePin , 830 , 249.99975 ) tone ( tonePin , 1046 , 374.999625 ) tone ( tonePin , 987 , 124.999875 ) tone ( tonePin , 932 , 249.99975 ) tone ( tonePin , 739 , 499.9995 ) tone ( tonePin , 783 , 249.99975 ) tone ( tonePin , 659 , 1249.99875 ) while 1 : midi () GPIO . cleanup () // Credit: // Midi to Arduino Converter // - Andy Tran (extramaster), 2015 // https://www.extramaster.net/tools/midiToArduino/ // // Process: // Midi -> Midi tracks -> Note mappings -> Frequency // // CC0 // Set this to be the pin that your buzzer resides in. (Note that you can only have one buzzer actively using the PWM signal at a time). int tonePin = 11 ; void setup () { } void midi () { tone ( tonePin , 493 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 659 , 374.999625 ); delay ( 416.66625 ); tone ( tonePin , 783 , 124.999875 ); delay ( 138.88875 ); tone ( tonePin , 739 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 659 , 499.9995 ); delay ( 555.555 ); tone ( tonePin , 987 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 880 , 749.99925 ); delay ( 833.3325 ); tone ( tonePin , 739 , 749.99925 ); delay ( 833.3325 ); tone ( tonePin , 659 , 374.999625 ); delay ( 416.66625 ); tone ( tonePin , 783 , 124.999875 ); delay ( 138.88875 ); tone ( tonePin , 739 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 587 , 499.9995 ); delay ( 555.555 ); tone ( tonePin , 698 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 493 , 1249.99875 ); delay ( 1388.8875 ); tone ( tonePin , 493 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 659 , 374.999625 ); delay ( 416.66625 ); tone ( tonePin , 783 , 124.999875 ); delay ( 138.88875 ); tone ( tonePin , 739 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 659 , 499.9995 ); delay ( 555.555 ); tone ( tonePin , 987 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 1174 , 499.9995 ); delay ( 555.555 ); tone ( tonePin , 1108 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 1046 , 499.9995 ); delay ( 555.555 ); tone ( tonePin , 830 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 1046 , 374.999625 ); delay ( 416.66625 ); tone ( tonePin , 987 , 124.999875 ); delay ( 138.88875 ); tone ( tonePin , 932 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 739 , 499.9995 ); delay ( 555.555 ); tone ( tonePin , 783 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 659 , 1249.99875 ); delay ( 1388.8875 ); tone ( tonePin , 783 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 987 , 499.9995 ); delay ( 555.555 ); tone ( tonePin , 783 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 987 , 499.9995 ); delay ( 555.555 ); tone ( tonePin , 783 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 1046 , 499.9995 ); delay ( 555.555 ); tone ( tonePin , 987 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 932 , 499.9995 ); delay ( 555.555 ); tone ( tonePin , 739 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 783 , 374.999625 ); delay ( 416.66625 ); tone ( tonePin , 987 , 124.999875 ); delay ( 138.88875 ); tone ( tonePin , 932 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 466 , 499.9995 ); delay ( 555.555 ); tone ( tonePin , 493 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 987 , 1249.99875 ); delay ( 1388.8875 ); tone ( tonePin , 783 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 987 , 499.9995 ); delay ( 555.555 ); tone ( tonePin , 783 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 987 , 499.9995 ); delay ( 555.555 ); tone ( tonePin , 783 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 1174 , 499.9995 ); delay ( 555.555 ); tone ( tonePin , 1108 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 1046 , 499.9995 ); delay ( 555.555 ); tone ( tonePin , 830 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 1046 , 374.999625 ); delay ( 416.66625 ); tone ( tonePin , 987 , 124.999875 ); delay ( 138.88875 ); tone ( tonePin , 932 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 739 , 499.9995 ); delay ( 555.555 ); tone ( tonePin , 783 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 659 , 1249.99875 ); delay ( 1388.8875 ); } void loop () { // Play midi midi (); }","title":"STEMinds - Buzzers"},{"location":"kits/mindev_kit/buzzers/#buzzers","text":"In the Mindev kit we've attached 2 different buzzers that utilizes two main technologies. Each technology has specific advantages and tradeoffs that must be taken into consideration depending on the application requirements. In this lesson we'll learn how to use and control the buzzer and what's the electronic principles of the buzzer is working on, at the end you'll be able to use the active buzzer to play basic on/off buzzing noise and the passive buzzer to play a nice melody!","title":"Buzzers"},{"location":"kits/mindev_kit/buzzers/#features","text":"There are 2 different buzzer types: Piezo buzzer and Magnetic buzzer, let's take a look at each of their features.","title":"Features"},{"location":"kits/mindev_kit/buzzers/#piezo-buzzer-active-buzzer","text":"Wide operating voltage: 3~250 V Lower current consumption: less than 30 mA higher rated frequency Larger footprint Higher sound pressure level","title":"Piezo buzzer (Active buzzer)"},{"location":"kits/mindev_kit/buzzers/#magnetic-buzzer-passive-buzzer","text":"Narrow operating voltage: 1~16 V Higher current consumption: 30~100 mA Lower rated frequency Smaller footprint Lower sound pressure level","title":"Magnetic buzzer (Passive buzzer)"},{"location":"kits/mindev_kit/buzzers/#hardware-explained","text":"As we've mentioned we've included 2 different buzzers with the kit, let's walk on each buzzer principles to understand how it works and what drives it to make that buzzing noise we all like to hear.","title":"Hardware explained"},{"location":"kits/mindev_kit/buzzers/#piezo-buzzer-active-buzzer_1","text":"At the heart of the piezo-type buzzers there is the piezoelectric element. Piezoelectric element is composed of a piezoelectric ceramic and a metal plate held together with adhesive. Both sides of the piezoelectric ceramic plate contain an electrode for electrical conduction. Piezo materials exhibit a specific phenomenon known as the piezoelectric effect and the reverse piezoelectric effect. Exposure to mechanical strain will cause the material to develop an electric field, and vice versa. When an alternating voltage is applied to the piezoceramic element, the element extends and shrinks diametrically. This characteristic of piezoelectric material is utilized to make the ceramic plate vibrate rapidly to generate sound waves. There are two types of piezo buzzers - transducers and indicators. Transducers consist of a casing, a piezoceramic element and a terminal. In order to operate a transducer, the user must send a square wave signal to the buzzer. Indicators consist of a casing, a piezoceramic element, a circuit board and a terminal. In order to operate an indicator, the user must send the buzzer a specified dc voltage.","title":"Piezo buzzer (Active buzzer)"},{"location":"kits/mindev_kit/buzzers/#magnetic-buzzer-passive-buzzer_1","text":"The illustration below highlights the structure of a typical magnetic buzzer. Like piezo technology, magnetic buzzers are available in transducer and indicator configurations. In a magnetic buzzer, the transistor acts as the driving circuit. Indicators include the transistor, creating a tone when a dc voltage is applied. Transducers lack this transistor, requiring a square wave signal to operate properly. The vibrating disk in a magnetic buzzer is attracted to the pole by the magnetic field. When an oscillating signal is moved through the coil, it produces a fluctuating magnetic field which vibrates the disk at a frequency equal to that of the drive signal.","title":"Magnetic buzzer (Passive buzzer)"},{"location":"kits/mindev_kit/buzzers/#diagrams","text":"After we've learned about the buzzer types and elements, it's time to connect the buzzer to our microcontroller and get it going. depends on what controller you are using (such as Raspberry Pi, Arduino, ESP etc ..) you'll need different diagrams. below we'll show you how to attach the buzzer in different diagram to a different controller.","title":"Diagrams"},{"location":"kits/mindev_kit/buzzers/#raspberry-pi-wiring-diagram","text":"As the Raspberry Pi diagram shows, our buzzer have 2 wires one is GND and one is VCC, the VCC can be controlled by 3.3V which means we can connect it to the GPIO pins directly. In our Diagram we choose to connect the VCC pin of the buzzer to the Raspberry Pi GPIO4 pin. The black wire (GND) from the buzzer go to the ground pin on the raspberry pi.","title":"Raspberry Pi wiring diagram"},{"location":"kits/mindev_kit/buzzers/#arduino-wiring-diagram","text":"Similar to the raspberry Pi diagram, in the Arduino diagram our buzzer also have 2 pins (obviously). For the Arduino we'll connect the positive (VCC) pin from the buzzer to the Digital Pin number 8 on the Arduino while the negative pin (GND) will go to the ground pin on the Arduino, that way we can output digital signal to the Arduino and control the buzzer similar to the Raspberry Pi GPIO principle.","title":"Arduino wiring diagram"},{"location":"kits/mindev_kit/buzzers/#esp32-esp8266-wiring-diagram","text":"For the ESP we'll connect the positive wire from the buzzer to D5 (digital 5) pin on the ESP board while connecting the GND wire from the buzzer to the ground point in order to close the circuit, the same principle goes here and when controlling the buzzer we always use digital output pins.","title":"ESP32 / ESP8266 wiring diagram"},{"location":"kits/mindev_kit/buzzers/#software-explained","text":"Let's show an example of the 2 different buzzers, one is the active buzzer to create a simple buzzing noise and the other one is the passive buzzer which we can use to play music with by playing it using a specific frequency.","title":"Software explained"},{"location":"kits/mindev_kit/buzzers/#piezo-buzzer-active-buzzer_2","text":"The piezo buzzer is fairly easy as we just need to supply 3.3-5V to it and it will work right away, we can use GPIO pins in raspberry pi or IO pins in ESP or just digital pins in Arduino, all will work perfectly fine.","title":"Piezo buzzer (Active buzzer)"},{"location":"kits/mindev_kit/buzzers/#example-code","text":"The code is very straight forward and available for all the platforms Python3 MicroPython ESP32-Arduino Arduino IDE #!/usr/bin/python # -*- coding: utf-8 -*- import RPi.GPIO as GPIO import time buzzer_pin = 4 GPIO . setmode ( GPIO . BCM ) GPIO . setup ( buzzer_pin , GPIO . OUT ) # Make buzzer sound GPIO . output ( buzzer_pin , GPIO . HIGH ) time . sleep ( 0.5 ) # Stop buzzer sound GPIO . output ( buzzer_pin , GPIO . LOW ) GPIO . cleanup () import machine import time # define buzzer on pin IO5 (digital 5) as OUTPUT buzzer = machine . Pin ( 5 , machine . Pin . OUT ) # define sleep interval as 3 seconds sleep_interval = 1 # turn on the buzzer buzzer . value ( 1 ) # wait for the defined sleep interval time . sleep ( sleep_interval ) # turn off the buzzer buzzer . value ( 0 ) // define buzzer on pin IO5 (digital 5) as OUTPUT const int buzzer = 5 ; void setup () { pinMode ( buzzer , OUTPUT ); // Set buzzer - pin 5 as an output } void loop () { // turn on the buzzer digitalWrite ( buzzer , HIGH ); Serial . println ( \"Buzzer is HIGH\" ); delay ( 1000 ); // turn off the buzzer digitalWrite ( buzzer , LOW ); Serial . println ( \"Buzzer is LOW\" ); delay ( 1000 ); } const int buzzer = 8 ; //buzzer to arduino pin 8 void setup (){ pinMode ( buzzer , OUTPUT ); // Set buzzer - pin 8 as an output } void loop (){ tone ( buzzer , 1000 ); // Send 1KHz sound signal... delay ( 1000 ); // ...for 1 sec noTone ( buzzer ); // Stop sound... delay ( 1000 ); // ...for 1sec }","title":"Example code"},{"location":"kits/mindev_kit/buzzers/#magnetic-buzzer-passive-buzzer_2","text":"For this example we'll be taking a .midi file and converting it to Arduino / Raspberry Pi code to allow us to play a song using the Magnetic buzzer. To do it, we'll download a custom midi file and we will use a website to convert the midi file to code. For the Raspberry Pi example we'll need to use the software PWN (not the normal GPIO we've used earlier with the active buzzer) this is due to the passive buzzer characteristic that requires square waves in order to operate it and not just a constant DC voltage.","title":"Magnetic buzzer (Passive buzzer)"},{"location":"kits/mindev_kit/buzzers/#finding-midi-file-to-play","text":"There are a lot of websites that offer free midi files, for our tutorial we'll be using the \"Harry Potter theme song\" midi file downloaded from here: Harry potter theme song midi file you can download any midi file you want and we will use it later in our conversion process for Arduino / Raspberry Pi code Example code below uses Harry potter theme midi The example code below uses the midi file we've downloaded from the link previously given, if you want other tunes you'll need to download your own midi file and convert it manually.","title":"Finding midi file to play"},{"location":"kits/mindev_kit/buzzers/#converting-midi-to-code","text":"In order to convert the midi file to code we'll use the following free website: ExtraMaster MiDi to Arduino / Raspberry Pi this will allow us to convert any midi file into code in seconds. First step, download your midi file. once you have it go to the website and upload it, then click submit: Next step will be to select the midi file to extract, make sure you choose the one that doesn't say \"unknown\", most often you can leave it as default and there shouldn't be any troubles. Finally choose the format you want to convert to. do you want to use Raspberry Pi? Arduino? Unfortunately, the website does not offer support to ESP-Arduino or MicroPython but this can be easily solved by small modifications. For MicroPython modify the Raspberry Pi python code and for ESP-Arduino modify the Arduino C++ Code, this should be fairly easy.","title":"Converting midi to code"},{"location":"kits/mindev_kit/buzzers/#example-code_1","text":"Below is the example code based on the Harry Potter theme song midi file, if you'd like to use different tune - convert it yourself by using the steps we've explained above. Python3 MicroPython ESP32-Arduino Arduino IDE ## Credit: ## Midi to Raspberry Pi Converter ## - Andy Tran (extramaster), 2015 ## https://www.extramaster.net/tools/midiToArduino/ ## ## Process: ## Midi -> Midi tracks -> Note mappings -> Frequency ## ## CC0 import RPi.GPIO as GPIO import time # Set this to be the pin that your buzzer resides in. (Note that you can only have one buzzer actively using the PWM signal at a time). # GD = GND = Ground # RPI v1 GPIO Layout BCM # 5V 5V GD 14 15 18 GD 23 24 GD 25 08 07 # 3V 02 03 04 GD 17 27 22 3V 10 09 11 GD # RPI v2 GPIO Layout BCM # 5V 5V GD 14 15 18 GD 23 24 GD 25 08 07 SC GD 12 GD 16 20 21 # 3V 02 03 04 GD 17 27 22 3V 10 09 11 GD SD 05 06 13 19 26 GD # Note: Raspberry Pi 2 seems to handle software-PWM a lot better then the original Raspberry Pis. tonePin = 4 GPIO . setmode ( GPIO . BCM ) GPIO . setup ( tonePin , GPIO . IN ) GPIO . setup ( tonePin , GPIO . OUT ) p = GPIO . PWM ( tonePin , 100 ) # High-level abstraction of the Arduino's Delay function def delay ( times ): time . sleep ( times / 1000.0 ) # High-level abstraction of the Arduino's Tone function, though this version is blocking def tone ( pin , pitch , duration ): if pitch == 0 : delay ( duration ) return p = GPIO . PWM ( tonePin , pitch ) # Change the duty-cycle to 50 if you wish p . start ( 30 ) delay ( duration ) p . stop () # Delay used to discourage overlap of PWM cycles delay ( 2 ) def midi (): tone ( tonePin , 493 , 249.99975 ) tone ( tonePin , 659 , 374.999625 ) tone ( tonePin , 783 , 124.999875 ) tone ( tonePin , 739 , 249.99975 ) tone ( tonePin , 659 , 499.9995 ) tone ( tonePin , 987 , 249.99975 ) tone ( tonePin , 880 , 749.99925 ) tone ( tonePin , 739 , 749.99925 ) tone ( tonePin , 659 , 374.999625 ) tone ( tonePin , 783 , 124.999875 ) tone ( tonePin , 739 , 249.99975 ) tone ( tonePin , 587 , 499.9995 ) tone ( tonePin , 698 , 249.99975 ) tone ( tonePin , 493 , 1249.99875 ) tone ( tonePin , 493 , 249.99975 ) tone ( tonePin , 659 , 374.999625 ) tone ( tonePin , 783 , 124.999875 ) tone ( tonePin , 739 , 249.99975 ) tone ( tonePin , 659 , 499.9995 ) tone ( tonePin , 987 , 249.99975 ) tone ( tonePin , 1174 , 499.9995 ) tone ( tonePin , 1108 , 249.99975 ) tone ( tonePin , 1046 , 499.9995 ) tone ( tonePin , 830 , 249.99975 ) tone ( tonePin , 1046 , 374.999625 ) tone ( tonePin , 987 , 124.999875 ) tone ( tonePin , 932 , 249.99975 ) tone ( tonePin , 739 , 499.9995 ) tone ( tonePin , 783 , 249.99975 ) tone ( tonePin , 659 , 1249.99875 ) tone ( tonePin , 783 , 249.99975 ) tone ( tonePin , 987 , 499.9995 ) tone ( tonePin , 783 , 249.99975 ) tone ( tonePin , 987 , 499.9995 ) tone ( tonePin , 783 , 249.99975 ) tone ( tonePin , 1046 , 499.9995 ) tone ( tonePin , 987 , 249.99975 ) tone ( tonePin , 932 , 499.9995 ) tone ( tonePin , 739 , 249.99975 ) tone ( tonePin , 783 , 374.999625 ) tone ( tonePin , 987 , 124.999875 ) tone ( tonePin , 932 , 249.99975 ) tone ( tonePin , 466 , 499.9995 ) tone ( tonePin , 493 , 249.99975 ) tone ( tonePin , 987 , 1249.99875 ) tone ( tonePin , 783 , 249.99975 ) tone ( tonePin , 987 , 499.9995 ) tone ( tonePin , 783 , 249.99975 ) tone ( tonePin , 987 , 499.9995 ) tone ( tonePin , 783 , 249.99975 ) tone ( tonePin , 1174 , 499.9995 ) tone ( tonePin , 1108 , 249.99975 ) tone ( tonePin , 1046 , 499.9995 ) tone ( tonePin , 830 , 249.99975 ) tone ( tonePin , 1046 , 374.999625 ) tone ( tonePin , 987 , 124.999875 ) tone ( tonePin , 932 , 249.99975 ) tone ( tonePin , 739 , 499.9995 ) tone ( tonePin , 783 , 249.99975 ) tone ( tonePin , 659 , 1249.99875 ) while 1 : midi () GPIO . cleanup () // Credit: // Midi to Arduino Converter // - Andy Tran (extramaster), 2015 // https://www.extramaster.net/tools/midiToArduino/ // // Process: // Midi -> Midi tracks -> Note mappings -> Frequency // // CC0 // Set this to be the pin that your buzzer resides in. (Note that you can only have one buzzer actively using the PWM signal at a time). int tonePin = 11 ; void setup () { } void midi () { tone ( tonePin , 493 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 659 , 374.999625 ); delay ( 416.66625 ); tone ( tonePin , 783 , 124.999875 ); delay ( 138.88875 ); tone ( tonePin , 739 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 659 , 499.9995 ); delay ( 555.555 ); tone ( tonePin , 987 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 880 , 749.99925 ); delay ( 833.3325 ); tone ( tonePin , 739 , 749.99925 ); delay ( 833.3325 ); tone ( tonePin , 659 , 374.999625 ); delay ( 416.66625 ); tone ( tonePin , 783 , 124.999875 ); delay ( 138.88875 ); tone ( tonePin , 739 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 587 , 499.9995 ); delay ( 555.555 ); tone ( tonePin , 698 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 493 , 1249.99875 ); delay ( 1388.8875 ); tone ( tonePin , 493 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 659 , 374.999625 ); delay ( 416.66625 ); tone ( tonePin , 783 , 124.999875 ); delay ( 138.88875 ); tone ( tonePin , 739 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 659 , 499.9995 ); delay ( 555.555 ); tone ( tonePin , 987 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 1174 , 499.9995 ); delay ( 555.555 ); tone ( tonePin , 1108 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 1046 , 499.9995 ); delay ( 555.555 ); tone ( tonePin , 830 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 1046 , 374.999625 ); delay ( 416.66625 ); tone ( tonePin , 987 , 124.999875 ); delay ( 138.88875 ); tone ( tonePin , 932 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 739 , 499.9995 ); delay ( 555.555 ); tone ( tonePin , 783 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 659 , 1249.99875 ); delay ( 1388.8875 ); tone ( tonePin , 783 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 987 , 499.9995 ); delay ( 555.555 ); tone ( tonePin , 783 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 987 , 499.9995 ); delay ( 555.555 ); tone ( tonePin , 783 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 1046 , 499.9995 ); delay ( 555.555 ); tone ( tonePin , 987 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 932 , 499.9995 ); delay ( 555.555 ); tone ( tonePin , 739 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 783 , 374.999625 ); delay ( 416.66625 ); tone ( tonePin , 987 , 124.999875 ); delay ( 138.88875 ); tone ( tonePin , 932 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 466 , 499.9995 ); delay ( 555.555 ); tone ( tonePin , 493 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 987 , 1249.99875 ); delay ( 1388.8875 ); tone ( tonePin , 783 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 987 , 499.9995 ); delay ( 555.555 ); tone ( tonePin , 783 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 987 , 499.9995 ); delay ( 555.555 ); tone ( tonePin , 783 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 1174 , 499.9995 ); delay ( 555.555 ); tone ( tonePin , 1108 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 1046 , 499.9995 ); delay ( 555.555 ); tone ( tonePin , 830 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 1046 , 374.999625 ); delay ( 416.66625 ); tone ( tonePin , 987 , 124.999875 ); delay ( 138.88875 ); tone ( tonePin , 932 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 739 , 499.9995 ); delay ( 555.555 ); tone ( tonePin , 783 , 249.99975 ); delay ( 277.7775 ); tone ( tonePin , 659 , 1249.99875 ); delay ( 1388.8875 ); } void loop () { // Play midi midi (); }","title":"Example code"},{"location":"kits/mindev_kit/dht_sensors/","text":"DHT sensors The DHT22 Family sensors are low cost sensors that are very practical for quick prototyping or small project ideas. In this article we'll learn about the sensors, compare between them and finally write code to receive temperature and humidity input in real time. Only DHT11 included with the kit DHT11 and DHT22 are very similar and the kit only includes DH11 sensor, the article compare the sensors as well as shows how to write code that will work on both of them, keep in mind there is only one DHT11 sensor included with the kit. Type of sensors There are 2 main sensors in the DHTxx Family - The DHT11 and the DHT22. AM2302 is considered to be DHT22 with extension wires instead of direct pins. DHT11 DHT11 Temperature & Humidity Sensor features a temperature & humidity sensor complex with a calibrated digital signal output. By using the exclusive digital-signal-acquisition technique and temperature & humidity sensing technology, it ensures high reliability and excellent long-term stability. This sensor includes a resistive-type humidity measurement component and an NTC temperature measurement component, and connects to a high performance 8-bit microcontroller, offering excellent quality, fast response, anti-interference ability and cost-effectiveness The complete data sheet for DHT11 can be found here: Mouser.com DHT11 datasheet DHT22 / AM2302 DHT22 (as well as AM2302) output calibrated digital signal. It applys exclusive digital-signal-collecting-technique and humidity sensing technology, assuring its reliability and stability. Its sensing elements is connected with 8-bit single-chip computer. The DHT22 and AM2302 are basically the same sensor except the AM2302 have external wire that you can solder to the board as extension instead of soldering the sensor directly. The complete data sheet for DHT22 and AM2302 can be found here: adafruit.com DHT22/AM2302 datasheet Features The DHT11 and DHT22 features have small differences, which one is better? depends on the application. let's take a look at each sensor features so we'll know which one to apply to which project. DHT11 Each DHT11 sensor is calibrated in a special laboratory that is extremely accurate on humidity calibration. The calibration coefficients are stored in the program OTP memory, which is used by the sensor\u2019s internal signal detecting process. The single-wire serial interface makes system integration quick and easy. Its small size, low power consumption, and up-to-20 meter signal transmission making it the best choice for various applications, including those most demanding ones. The component is a 4-pin single row pin package. Ultra low cost 3 to 5V power and I/O 2.5mA max current use during conversion (while requesting data) Good for 20-80% humidity readings with 5% accuracy Good for 0-50\u00b0C temperature readings \u00b12\u00b0C accuracy No more than 1 Hz sampling rate (once every second) Body size 15.5mm x 12mm x 5.5mm 4 pins with 0.1\" spacing DHT22 / AM2302 Every sensor of this model is temperature compensated and calibrated in accurate calibration chamber and the calibration-coefficient is saved in type of program in OTP memory, when the sensor is detecting, it will cite coefficient from memory. Small size & low consumption & long transmission distance(100m) enable AM2302 to be suited in all kinds of harsh application occasions. Single-row packaged with four pins, making the connection very convenient. Low cost 3 to 5V power and I/O 2.5mA max current use during conversion (while requesting data) Good for 0-100% humidity readings with 2-5% accuracy Good for -40 to 80\u00b0C temperature readings \u00b10.5\u00b0C accuracy No more than 0.5 Hz sampling rate (once every 2 seconds) Body size 15.1mm x 25mm x 7.7mm 4 pins with 0.1\" spacing Scientific principle The humidity sensor used in the DHTxx series is a substance called as the \"Polymer resistance type\" and the sensor principle using this polymer membrane is described here. The Polymer membrane humidity sensor measures the relative humidity of the atmosphere from the electric permittivity change accompanying the absorption and emission of moisture of the polymer membrane. Basically, a condenser built as shown below can work as a humidity sensor and the electric permittivity change of the polymer membrane can be measured as the capacitance change of the condenser. The electrode is an extremely thin metal deposition film and the polymer membrane absorbs and emits moisture through the electrode. There are \"Capacitance type\" and \"Resistance type\" Polymer membrane humidity sensors. Capacitance Type: The cellulose type hydrophilic polymer uses the property that the capacitance of wet and dry materials changes according to the amount of moisture adsorbed. Its distinctive features are wide measurement range (0 - 100%RH), faster response speed and it gives a linear output for relative humidity. Resistance Type (used in PAU) : It uses the property that the resistance of quaternary ammonium salt and sulfonic acid group based wet and dry spherical materials reduces due to moisture absorption. The resistance type humidity sensor has a simple structure, can be mass produced and are relatively inexpensive. In addition, though it has a linear output, since it produces a straight line against the index the resolution is bad as compared to the capacitance type. In addition to that, they also consist of a NTC temperature sensor/Thermistor to measure temperature. A thermistor is a thermal resistor \u2013 a resistor that changes its resistance with temperature. Technically, all resistors are thermistors \u2013 their resistance changes slightly with temperature \u2013 but the change is usually very very small and difficult to measure. Thermistors are made so that the resistance changes drastically with temperature so that it can be 100 ohms or more of change per degree! The term \u201cNTC\u201d means \u201cNegative Temperature Coefficient\u201d, which means that the resistance decreases with increase of the temperature. Hardware explained Now when we know the differences between DHT11 and DHT22 as well as the scientific principles they work on, let's read some diagrams to understand how to connect the sensors to our micro-controllers and write some code to get it to work. In the diagram you'll see we have to use a resistor between 4.7K and 10K (resistors included in the kit) this is used in order to avoid disruption and stabilize the signal. The diagrams show DHT11 but will work both on DHT11 and DHT22 Because our kit only includes DHT11 we will use that sensor to show diagrams but keep in mind that both DHT11 and DHT22 can be connected in the same way using the same diagrams. Raspberry Pi wiring diagram The DHT11 has 4 pins: VCC, SIG (DATA), N and GND (N stands for natural, we don't connect it to anything). VCC goes to 3.3V or 5V output in the Raspberry Pi (we suggest to go with 3.3V), GND (black negative wire) goes to GND and SIG (data, the yellow wire) need to connect between a resistor of 4.7K to 10K (any number between will work, for our example we use 4.7K), one side of the resistor connects to SIG (data) the other side to VCC and the rest of the wire goes to GPIO PIN 25 (GPIO.BCM). Arduino wiring diagram For the Arduino we follow similar principle, the sensor is the same with 4 pins (VCC, GND, SIG, N). The VCC goes to 5V, GND goes to GND and SIG goes through resistor and then connects to digital pin 2, the natural we don't connect it to anything (third pin on the DHT sensor when it's facing us). ESP32 / ESP8266 wiring diagram For the ESP example in the picture above we can see NodeMCU which is based on ESP8266 but it will work both for ESP32 and ESP8266 the same way. As before, 4 pins (VCC, GND, SIG, N) VCC goes to 5V, GND goes to GND and SIG through resistor connects to digital pin number 4. Software explained The software is very straight forward, for the raspberry pi you'll need to install some extra libraries (the Adafruit DHT library) link can be found here: Adafruit DHT library Although it says it's deprecated it should work perfectly fine. the reason they deprecated the library is due to Adafruit preference to focus on their own framework instead of the official Python3 programing language. For the Arduino IDE we will use Adafruit library as well which is available from here: Adafruit DHT-sensor-library MicroPython is probably the easiest one as they include build in the DHT11 library so it's very easy to import and use it right away. DHT11 In the example below we can see MicroPython, Arduino, Python3 and ESP-Arduino examples for DHT11 Python3 MicroPython ESP32-Arduino Arduino IDE import sys import time import Adafruit_DHT now = time . strftime ( \" %c \" ) sensor = 11 pin = 25 humidity , temperature = Adafruit_DHT . read_retry ( sensor , pin ) # Un-comment the line below to convert the temperature to Fahrenheit. # temperature = temperature * 9/5.0 + 32 if humidity is not None and temperature is not None : print ( now + ' - ' + 'Temp= {0:0.1f} * Humidity= {1:0.1f} %' . format ( temperature , humidity )) else : print ( 'Failed to get reading. Try again!' ) sys . exit ( 1 ) import dht import machine # initialize dht object, DHT11 coonected to IO34 (ESP-32 / ESP-8266) d = dht . DHT11 ( machine . Pin ( 4 )) # measure sensor data d . measure () # get data temp = d . temperature () humidity = d . humidity () # uncomment for temperature in Fahrenheit #temp = (temp / 100) * (9/5) + 32 #temp = str(round(temp, 2)) # print temperature and humidity print ( \"temperature : %s \" % temp ) print ( \"humidity : %s \" % humidity ) #include \"DHT.h\" #define DHTPIN 4 // Digital pin connected to the DHT sensor // Uncomment whatever type you're using! #define DHTTYPE DHT11 // DHT 11 //#define DHTTYPE DHT22 // DHT 22 (AM2302), AM2321 //#define DHTTYPE DHT21 // DHT 21 (AM2301) // Initialize DHT sensor. // Note that older versions of this library took an optional third parameter to // tweak the timings for faster processors. This parameter is no longer needed // as the current DHT reading algorithm adjusts itself to work on faster procs. DHT dht ( DHTPIN , DHTTYPE ); void setup () { Serial . begin ( 115200 ); Serial . println ( F ( \"DHTxx test!\" )); dht . begin (); } void loop () { // Wait a few seconds between measurements. delay ( 2000 ); // Reading temperature or humidity takes about 250 milliseconds! // Sensor readings may also be up to 2 seconds 'old' (its a very slow sensor) float h = dht . readHumidity (); // Read temperature as Celsius (the default) float t = dht . readTemperature (); // Read temperature as Fahrenheit (isFahrenheit = true) float f = dht . readTemperature ( true ); // Check if any reads failed and exit early (to try again). if ( isnan ( h ) || isnan ( t ) || isnan ( f )) { Serial . println ( F ( \"Failed to read from DHT sensor!\" )); return ; } // Compute heat index in Fahrenheit (the default) float hif = dht . computeHeatIndex ( f , h ); // Compute heat index in Celsius (isFahreheit = false) float hic = dht . computeHeatIndex ( t , h , false ); Serial . print ( F ( \"Humidity: \" )); Serial . print ( h ); Serial . print ( F ( \"% Temperature: \" )); Serial . print ( t ); Serial . print ( F ( \"\u00b0C \" )); Serial . print ( f ); Serial . print ( F ( \"\u00b0F Heat index: \" )); Serial . print ( hic ); Serial . print ( F ( \"\u00b0C \" )); Serial . print ( hif ); Serial . println ( F ( \"\u00b0F\" )); } #include \"DHT.h\" #define DHTPIN 2 // Digital pin connected to the DHT sensor // Uncomment whatever type you're using! #define DHTTYPE DHT11 // DHT 11 //#define DHTTYPE DHT22 // DHT 22 (AM2302), AM2321 //#define DHTTYPE DHT21 // DHT 21 (AM2301) // Initialize DHT sensor. // Note that older versions of this library took an optional third parameter to // tweak the timings for faster processors. This parameter is no longer needed // as the current DHT reading algorithm adjusts itself to work on faster procs. DHT dht ( DHTPIN , DHTTYPE ); void setup () { Serial . begin ( 115200 ); Serial . println ( F ( \"DHTxx test!\" )); dht . begin (); } void loop () { // Wait a few seconds between measurements. delay ( 2000 ); // Reading temperature or humidity takes about 250 milliseconds! // Sensor readings may also be up to 2 seconds 'old' (its a very slow sensor) float h = dht . readHumidity (); // Read temperature as Celsius (the default) float t = dht . readTemperature (); // Read temperature as Fahrenheit (isFahrenheit = true) float f = dht . readTemperature ( true ); // Check if any reads failed and exit early (to try again). if ( isnan ( h ) || isnan ( t ) || isnan ( f )) { Serial . println ( F ( \"Failed to read from DHT sensor!\" )); return ; } // Compute heat index in Fahrenheit (the default) float hif = dht . computeHeatIndex ( f , h ); // Compute heat index in Celsius (isFahreheit = false) float hic = dht . computeHeatIndex ( t , h , false ); Serial . print ( F ( \"Humidity: \" )); Serial . print ( h ); Serial . print ( F ( \"% Temperature: \" )); Serial . print ( t ); Serial . print ( F ( \"\u00b0C \" )); Serial . print ( f ); Serial . print ( F ( \"\u00b0F Heat index: \" )); Serial . print ( hic ); Serial . print ( F ( \"\u00b0C \" )); Serial . print ( hif ); Serial . println ( F ( \"\u00b0F\" )); } DHT22 In the example below we can see MicroPython, Arduino, Python3 and ESP-Arduino examples for DHT22 Python3 MicroPython ESP32-Arduino Arduino IDE import sys import time import Adafruit_DHT now = time . strftime ( \" %c \" ) sensor = 22 pin = 25 humidity , temperature = Adafruit_DHT . read_retry ( sensor , pin ) # Un-comment the line below to convert the temperature to Fahrenheit. # temperature = temperature * 9/5.0 + 32 if humidity is not None and temperature is not None : print ( now + ' - ' + 'Temp= {0:0.1f} * Humidity= {1:0.1f} %' . format ( temperature , humidity )) else : print ( 'Failed to get reading. Try again!' ) sys . exit ( 1 ) import dht import machine # initialize dht object, DHT22 coonected to IO34 (ESP-32 / ESP-8266) d = dht . DHT22 ( machine . Pin ( 4 )) # measure sensor data d . measure () # get data temp = d . temperature () humidity = d . humidity () # uncomment for temperature in Fahrenheit #temp = (temp / 100) * (9/5) + 32 #temp = str(round(temp, 2)) # print temperature and humidity print ( \"temperature : %s \" % temp ) print ( \"humidity : %s \" % humidity ) #include \"DHT.h\" #define DHTPIN 4 // Digital pin connected to the DHT sensor // Uncomment whatever type you're using! //#define DHTTYPE DHT11 // DHT 11 #define DHTTYPE DHT22 // DHT 22 (AM2302), AM2321 //#define DHTTYPE DHT21 // DHT 21 (AM2301) // Initialize DHT sensor. // Note that older versions of this library took an optional third parameter to // tweak the timings for faster processors. This parameter is no longer needed // as the current DHT reading algorithm adjusts itself to work on faster procs. DHT dht ( DHTPIN , DHTTYPE ); void setup () { Serial . begin ( 115200 ); Serial . println ( F ( \"DHTxx test!\" )); dht . begin (); } void loop () { // Wait a few seconds between measurements. delay ( 2000 ); // Reading temperature or humidity takes about 250 milliseconds! // Sensor readings may also be up to 2 seconds 'old' (its a very slow sensor) float h = dht . readHumidity (); // Read temperature as Celsius (the default) float t = dht . readTemperature (); // Read temperature as Fahrenheit (isFahrenheit = true) float f = dht . readTemperature ( true ); // Check if any reads failed and exit early (to try again). if ( isnan ( h ) || isnan ( t ) || isnan ( f )) { Serial . println ( F ( \"Failed to read from DHT sensor!\" )); return ; } // Compute heat index in Fahrenheit (the default) float hif = dht . computeHeatIndex ( f , h ); // Compute heat index in Celsius (isFahreheit = false) float hic = dht . computeHeatIndex ( t , h , false ); Serial . print ( F ( \"Humidity: \" )); Serial . print ( h ); Serial . print ( F ( \"% Temperature: \" )); Serial . print ( t ); Serial . print ( F ( \"\u00b0C \" )); Serial . print ( f ); Serial . print ( F ( \"\u00b0F Heat index: \" )); Serial . print ( hic ); Serial . print ( F ( \"\u00b0C \" )); Serial . print ( hif ); Serial . println ( F ( \"\u00b0F\" )); } #include \"DHT.h\" #define DHTPIN 2 // Digital pin connected to the DHT sensor // Uncomment whatever type you're using! //#define DHTTYPE DHT11 // DHT 11 #define DHTTYPE DHT22 // DHT 22 (AM2302), AM2321 //#define DHTTYPE DHT21 // DHT 21 (AM2301) // Initialize DHT sensor. // Note that older versions of this library took an optional third parameter to // tweak the timings for faster processors. This parameter is no longer needed // as the current DHT reading algorithm adjusts itself to work on faster procs. DHT dht ( DHTPIN , DHTTYPE ); void setup () { Serial . begin ( 115200 ); Serial . println ( F ( \"DHTxx test!\" )); dht . begin (); } void loop () { // Wait a few seconds between measurements. delay ( 2000 ); // Reading temperature or humidity takes about 250 milliseconds! // Sensor readings may also be up to 2 seconds 'old' (its a very slow sensor) float h = dht . readHumidity (); // Read temperature as Celsius (the default) float t = dht . readTemperature (); // Read temperature as Fahrenheit (isFahrenheit = true) float f = dht . readTemperature ( true ); // Check if any reads failed and exit early (to try again). if ( isnan ( h ) || isnan ( t ) || isnan ( f )) { Serial . println ( F ( \"Failed to read from DHT sensor!\" )); return ; } // Compute heat index in Fahrenheit (the default) float hif = dht . computeHeatIndex ( f , h ); // Compute heat index in Celsius (isFahreheit = false) float hic = dht . computeHeatIndex ( t , h , false ); Serial . print ( F ( \"Humidity: \" )); Serial . print ( h ); Serial . print ( F ( \"% Temperature: \" )); Serial . print ( t ); Serial . print ( F ( \"\u00b0C \" )); Serial . print ( f ); Serial . print ( F ( \"\u00b0F Heat index: \" )); Serial . print ( hic ); Serial . print ( F ( \"\u00b0C \" )); Serial . print ( hif ); Serial . println ( F ( \"\u00b0F\" )); }","title":"STEMinds - DHT Family sensors"},{"location":"kits/mindev_kit/dht_sensors/#dht-sensors","text":"The DHT22 Family sensors are low cost sensors that are very practical for quick prototyping or small project ideas. In this article we'll learn about the sensors, compare between them and finally write code to receive temperature and humidity input in real time. Only DHT11 included with the kit DHT11 and DHT22 are very similar and the kit only includes DH11 sensor, the article compare the sensors as well as shows how to write code that will work on both of them, keep in mind there is only one DHT11 sensor included with the kit.","title":"DHT sensors"},{"location":"kits/mindev_kit/dht_sensors/#type-of-sensors","text":"There are 2 main sensors in the DHTxx Family - The DHT11 and the DHT22. AM2302 is considered to be DHT22 with extension wires instead of direct pins.","title":"Type of sensors"},{"location":"kits/mindev_kit/dht_sensors/#dht11","text":"DHT11 Temperature & Humidity Sensor features a temperature & humidity sensor complex with a calibrated digital signal output. By using the exclusive digital-signal-acquisition technique and temperature & humidity sensing technology, it ensures high reliability and excellent long-term stability. This sensor includes a resistive-type humidity measurement component and an NTC temperature measurement component, and connects to a high performance 8-bit microcontroller, offering excellent quality, fast response, anti-interference ability and cost-effectiveness The complete data sheet for DHT11 can be found here: Mouser.com DHT11 datasheet","title":"DHT11"},{"location":"kits/mindev_kit/dht_sensors/#dht22-am2302","text":"DHT22 (as well as AM2302) output calibrated digital signal. It applys exclusive digital-signal-collecting-technique and humidity sensing technology, assuring its reliability and stability. Its sensing elements is connected with 8-bit single-chip computer. The DHT22 and AM2302 are basically the same sensor except the AM2302 have external wire that you can solder to the board as extension instead of soldering the sensor directly. The complete data sheet for DHT22 and AM2302 can be found here: adafruit.com DHT22/AM2302 datasheet","title":"DHT22 / AM2302"},{"location":"kits/mindev_kit/dht_sensors/#features","text":"The DHT11 and DHT22 features have small differences, which one is better? depends on the application. let's take a look at each sensor features so we'll know which one to apply to which project.","title":"Features"},{"location":"kits/mindev_kit/dht_sensors/#dht11_1","text":"Each DHT11 sensor is calibrated in a special laboratory that is extremely accurate on humidity calibration. The calibration coefficients are stored in the program OTP memory, which is used by the sensor\u2019s internal signal detecting process. The single-wire serial interface makes system integration quick and easy. Its small size, low power consumption, and up-to-20 meter signal transmission making it the best choice for various applications, including those most demanding ones. The component is a 4-pin single row pin package. Ultra low cost 3 to 5V power and I/O 2.5mA max current use during conversion (while requesting data) Good for 20-80% humidity readings with 5% accuracy Good for 0-50\u00b0C temperature readings \u00b12\u00b0C accuracy No more than 1 Hz sampling rate (once every second) Body size 15.5mm x 12mm x 5.5mm 4 pins with 0.1\" spacing","title":"DHT11"},{"location":"kits/mindev_kit/dht_sensors/#dht22-am2302_1","text":"Every sensor of this model is temperature compensated and calibrated in accurate calibration chamber and the calibration-coefficient is saved in type of program in OTP memory, when the sensor is detecting, it will cite coefficient from memory. Small size & low consumption & long transmission distance(100m) enable AM2302 to be suited in all kinds of harsh application occasions. Single-row packaged with four pins, making the connection very convenient. Low cost 3 to 5V power and I/O 2.5mA max current use during conversion (while requesting data) Good for 0-100% humidity readings with 2-5% accuracy Good for -40 to 80\u00b0C temperature readings \u00b10.5\u00b0C accuracy No more than 0.5 Hz sampling rate (once every 2 seconds) Body size 15.1mm x 25mm x 7.7mm 4 pins with 0.1\" spacing","title":"DHT22 / AM2302"},{"location":"kits/mindev_kit/dht_sensors/#scientific-principle","text":"The humidity sensor used in the DHTxx series is a substance called as the \"Polymer resistance type\" and the sensor principle using this polymer membrane is described here. The Polymer membrane humidity sensor measures the relative humidity of the atmosphere from the electric permittivity change accompanying the absorption and emission of moisture of the polymer membrane. Basically, a condenser built as shown below can work as a humidity sensor and the electric permittivity change of the polymer membrane can be measured as the capacitance change of the condenser. The electrode is an extremely thin metal deposition film and the polymer membrane absorbs and emits moisture through the electrode. There are \"Capacitance type\" and \"Resistance type\" Polymer membrane humidity sensors. Capacitance Type: The cellulose type hydrophilic polymer uses the property that the capacitance of wet and dry materials changes according to the amount of moisture adsorbed. Its distinctive features are wide measurement range (0 - 100%RH), faster response speed and it gives a linear output for relative humidity. Resistance Type (used in PAU) : It uses the property that the resistance of quaternary ammonium salt and sulfonic acid group based wet and dry spherical materials reduces due to moisture absorption. The resistance type humidity sensor has a simple structure, can be mass produced and are relatively inexpensive. In addition, though it has a linear output, since it produces a straight line against the index the resolution is bad as compared to the capacitance type. In addition to that, they also consist of a NTC temperature sensor/Thermistor to measure temperature. A thermistor is a thermal resistor \u2013 a resistor that changes its resistance with temperature. Technically, all resistors are thermistors \u2013 their resistance changes slightly with temperature \u2013 but the change is usually very very small and difficult to measure. Thermistors are made so that the resistance changes drastically with temperature so that it can be 100 ohms or more of change per degree! The term \u201cNTC\u201d means \u201cNegative Temperature Coefficient\u201d, which means that the resistance decreases with increase of the temperature.","title":"Scientific principle"},{"location":"kits/mindev_kit/dht_sensors/#hardware-explained","text":"Now when we know the differences between DHT11 and DHT22 as well as the scientific principles they work on, let's read some diagrams to understand how to connect the sensors to our micro-controllers and write some code to get it to work. In the diagram you'll see we have to use a resistor between 4.7K and 10K (resistors included in the kit) this is used in order to avoid disruption and stabilize the signal. The diagrams show DHT11 but will work both on DHT11 and DHT22 Because our kit only includes DHT11 we will use that sensor to show diagrams but keep in mind that both DHT11 and DHT22 can be connected in the same way using the same diagrams.","title":"Hardware explained"},{"location":"kits/mindev_kit/dht_sensors/#raspberry-pi-wiring-diagram","text":"The DHT11 has 4 pins: VCC, SIG (DATA), N and GND (N stands for natural, we don't connect it to anything). VCC goes to 3.3V or 5V output in the Raspberry Pi (we suggest to go with 3.3V), GND (black negative wire) goes to GND and SIG (data, the yellow wire) need to connect between a resistor of 4.7K to 10K (any number between will work, for our example we use 4.7K), one side of the resistor connects to SIG (data) the other side to VCC and the rest of the wire goes to GPIO PIN 25 (GPIO.BCM).","title":"Raspberry Pi wiring diagram"},{"location":"kits/mindev_kit/dht_sensors/#arduino-wiring-diagram","text":"For the Arduino we follow similar principle, the sensor is the same with 4 pins (VCC, GND, SIG, N). The VCC goes to 5V, GND goes to GND and SIG goes through resistor and then connects to digital pin 2, the natural we don't connect it to anything (third pin on the DHT sensor when it's facing us).","title":"Arduino wiring diagram"},{"location":"kits/mindev_kit/dht_sensors/#esp32-esp8266-wiring-diagram","text":"For the ESP example in the picture above we can see NodeMCU which is based on ESP8266 but it will work both for ESP32 and ESP8266 the same way. As before, 4 pins (VCC, GND, SIG, N) VCC goes to 5V, GND goes to GND and SIG through resistor connects to digital pin number 4.","title":"ESP32 / ESP8266 wiring diagram"},{"location":"kits/mindev_kit/dht_sensors/#software-explained","text":"The software is very straight forward, for the raspberry pi you'll need to install some extra libraries (the Adafruit DHT library) link can be found here: Adafruit DHT library Although it says it's deprecated it should work perfectly fine. the reason they deprecated the library is due to Adafruit preference to focus on their own framework instead of the official Python3 programing language. For the Arduino IDE we will use Adafruit library as well which is available from here: Adafruit DHT-sensor-library MicroPython is probably the easiest one as they include build in the DHT11 library so it's very easy to import and use it right away.","title":"Software explained"},{"location":"kits/mindev_kit/dht_sensors/#dht11_2","text":"In the example below we can see MicroPython, Arduino, Python3 and ESP-Arduino examples for DHT11 Python3 MicroPython ESP32-Arduino Arduino IDE import sys import time import Adafruit_DHT now = time . strftime ( \" %c \" ) sensor = 11 pin = 25 humidity , temperature = Adafruit_DHT . read_retry ( sensor , pin ) # Un-comment the line below to convert the temperature to Fahrenheit. # temperature = temperature * 9/5.0 + 32 if humidity is not None and temperature is not None : print ( now + ' - ' + 'Temp= {0:0.1f} * Humidity= {1:0.1f} %' . format ( temperature , humidity )) else : print ( 'Failed to get reading. Try again!' ) sys . exit ( 1 ) import dht import machine # initialize dht object, DHT11 coonected to IO34 (ESP-32 / ESP-8266) d = dht . DHT11 ( machine . Pin ( 4 )) # measure sensor data d . measure () # get data temp = d . temperature () humidity = d . humidity () # uncomment for temperature in Fahrenheit #temp = (temp / 100) * (9/5) + 32 #temp = str(round(temp, 2)) # print temperature and humidity print ( \"temperature : %s \" % temp ) print ( \"humidity : %s \" % humidity ) #include \"DHT.h\" #define DHTPIN 4 // Digital pin connected to the DHT sensor // Uncomment whatever type you're using! #define DHTTYPE DHT11 // DHT 11 //#define DHTTYPE DHT22 // DHT 22 (AM2302), AM2321 //#define DHTTYPE DHT21 // DHT 21 (AM2301) // Initialize DHT sensor. // Note that older versions of this library took an optional third parameter to // tweak the timings for faster processors. This parameter is no longer needed // as the current DHT reading algorithm adjusts itself to work on faster procs. DHT dht ( DHTPIN , DHTTYPE ); void setup () { Serial . begin ( 115200 ); Serial . println ( F ( \"DHTxx test!\" )); dht . begin (); } void loop () { // Wait a few seconds between measurements. delay ( 2000 ); // Reading temperature or humidity takes about 250 milliseconds! // Sensor readings may also be up to 2 seconds 'old' (its a very slow sensor) float h = dht . readHumidity (); // Read temperature as Celsius (the default) float t = dht . readTemperature (); // Read temperature as Fahrenheit (isFahrenheit = true) float f = dht . readTemperature ( true ); // Check if any reads failed and exit early (to try again). if ( isnan ( h ) || isnan ( t ) || isnan ( f )) { Serial . println ( F ( \"Failed to read from DHT sensor!\" )); return ; } // Compute heat index in Fahrenheit (the default) float hif = dht . computeHeatIndex ( f , h ); // Compute heat index in Celsius (isFahreheit = false) float hic = dht . computeHeatIndex ( t , h , false ); Serial . print ( F ( \"Humidity: \" )); Serial . print ( h ); Serial . print ( F ( \"% Temperature: \" )); Serial . print ( t ); Serial . print ( F ( \"\u00b0C \" )); Serial . print ( f ); Serial . print ( F ( \"\u00b0F Heat index: \" )); Serial . print ( hic ); Serial . print ( F ( \"\u00b0C \" )); Serial . print ( hif ); Serial . println ( F ( \"\u00b0F\" )); } #include \"DHT.h\" #define DHTPIN 2 // Digital pin connected to the DHT sensor // Uncomment whatever type you're using! #define DHTTYPE DHT11 // DHT 11 //#define DHTTYPE DHT22 // DHT 22 (AM2302), AM2321 //#define DHTTYPE DHT21 // DHT 21 (AM2301) // Initialize DHT sensor. // Note that older versions of this library took an optional third parameter to // tweak the timings for faster processors. This parameter is no longer needed // as the current DHT reading algorithm adjusts itself to work on faster procs. DHT dht ( DHTPIN , DHTTYPE ); void setup () { Serial . begin ( 115200 ); Serial . println ( F ( \"DHTxx test!\" )); dht . begin (); } void loop () { // Wait a few seconds between measurements. delay ( 2000 ); // Reading temperature or humidity takes about 250 milliseconds! // Sensor readings may also be up to 2 seconds 'old' (its a very slow sensor) float h = dht . readHumidity (); // Read temperature as Celsius (the default) float t = dht . readTemperature (); // Read temperature as Fahrenheit (isFahrenheit = true) float f = dht . readTemperature ( true ); // Check if any reads failed and exit early (to try again). if ( isnan ( h ) || isnan ( t ) || isnan ( f )) { Serial . println ( F ( \"Failed to read from DHT sensor!\" )); return ; } // Compute heat index in Fahrenheit (the default) float hif = dht . computeHeatIndex ( f , h ); // Compute heat index in Celsius (isFahreheit = false) float hic = dht . computeHeatIndex ( t , h , false ); Serial . print ( F ( \"Humidity: \" )); Serial . print ( h ); Serial . print ( F ( \"% Temperature: \" )); Serial . print ( t ); Serial . print ( F ( \"\u00b0C \" )); Serial . print ( f ); Serial . print ( F ( \"\u00b0F Heat index: \" )); Serial . print ( hic ); Serial . print ( F ( \"\u00b0C \" )); Serial . print ( hif ); Serial . println ( F ( \"\u00b0F\" )); }","title":"DHT11"},{"location":"kits/mindev_kit/dht_sensors/#dht22","text":"In the example below we can see MicroPython, Arduino, Python3 and ESP-Arduino examples for DHT22 Python3 MicroPython ESP32-Arduino Arduino IDE import sys import time import Adafruit_DHT now = time . strftime ( \" %c \" ) sensor = 22 pin = 25 humidity , temperature = Adafruit_DHT . read_retry ( sensor , pin ) # Un-comment the line below to convert the temperature to Fahrenheit. # temperature = temperature * 9/5.0 + 32 if humidity is not None and temperature is not None : print ( now + ' - ' + 'Temp= {0:0.1f} * Humidity= {1:0.1f} %' . format ( temperature , humidity )) else : print ( 'Failed to get reading. Try again!' ) sys . exit ( 1 ) import dht import machine # initialize dht object, DHT22 coonected to IO34 (ESP-32 / ESP-8266) d = dht . DHT22 ( machine . Pin ( 4 )) # measure sensor data d . measure () # get data temp = d . temperature () humidity = d . humidity () # uncomment for temperature in Fahrenheit #temp = (temp / 100) * (9/5) + 32 #temp = str(round(temp, 2)) # print temperature and humidity print ( \"temperature : %s \" % temp ) print ( \"humidity : %s \" % humidity ) #include \"DHT.h\" #define DHTPIN 4 // Digital pin connected to the DHT sensor // Uncomment whatever type you're using! //#define DHTTYPE DHT11 // DHT 11 #define DHTTYPE DHT22 // DHT 22 (AM2302), AM2321 //#define DHTTYPE DHT21 // DHT 21 (AM2301) // Initialize DHT sensor. // Note that older versions of this library took an optional third parameter to // tweak the timings for faster processors. This parameter is no longer needed // as the current DHT reading algorithm adjusts itself to work on faster procs. DHT dht ( DHTPIN , DHTTYPE ); void setup () { Serial . begin ( 115200 ); Serial . println ( F ( \"DHTxx test!\" )); dht . begin (); } void loop () { // Wait a few seconds between measurements. delay ( 2000 ); // Reading temperature or humidity takes about 250 milliseconds! // Sensor readings may also be up to 2 seconds 'old' (its a very slow sensor) float h = dht . readHumidity (); // Read temperature as Celsius (the default) float t = dht . readTemperature (); // Read temperature as Fahrenheit (isFahrenheit = true) float f = dht . readTemperature ( true ); // Check if any reads failed and exit early (to try again). if ( isnan ( h ) || isnan ( t ) || isnan ( f )) { Serial . println ( F ( \"Failed to read from DHT sensor!\" )); return ; } // Compute heat index in Fahrenheit (the default) float hif = dht . computeHeatIndex ( f , h ); // Compute heat index in Celsius (isFahreheit = false) float hic = dht . computeHeatIndex ( t , h , false ); Serial . print ( F ( \"Humidity: \" )); Serial . print ( h ); Serial . print ( F ( \"% Temperature: \" )); Serial . print ( t ); Serial . print ( F ( \"\u00b0C \" )); Serial . print ( f ); Serial . print ( F ( \"\u00b0F Heat index: \" )); Serial . print ( hic ); Serial . print ( F ( \"\u00b0C \" )); Serial . print ( hif ); Serial . println ( F ( \"\u00b0F\" )); } #include \"DHT.h\" #define DHTPIN 2 // Digital pin connected to the DHT sensor // Uncomment whatever type you're using! //#define DHTTYPE DHT11 // DHT 11 #define DHTTYPE DHT22 // DHT 22 (AM2302), AM2321 //#define DHTTYPE DHT21 // DHT 21 (AM2301) // Initialize DHT sensor. // Note that older versions of this library took an optional third parameter to // tweak the timings for faster processors. This parameter is no longer needed // as the current DHT reading algorithm adjusts itself to work on faster procs. DHT dht ( DHTPIN , DHTTYPE ); void setup () { Serial . begin ( 115200 ); Serial . println ( F ( \"DHTxx test!\" )); dht . begin (); } void loop () { // Wait a few seconds between measurements. delay ( 2000 ); // Reading temperature or humidity takes about 250 milliseconds! // Sensor readings may also be up to 2 seconds 'old' (its a very slow sensor) float h = dht . readHumidity (); // Read temperature as Celsius (the default) float t = dht . readTemperature (); // Read temperature as Fahrenheit (isFahrenheit = true) float f = dht . readTemperature ( true ); // Check if any reads failed and exit early (to try again). if ( isnan ( h ) || isnan ( t ) || isnan ( f )) { Serial . println ( F ( \"Failed to read from DHT sensor!\" )); return ; } // Compute heat index in Fahrenheit (the default) float hif = dht . computeHeatIndex ( f , h ); // Compute heat index in Celsius (isFahreheit = false) float hic = dht . computeHeatIndex ( t , h , false ); Serial . print ( F ( \"Humidity: \" )); Serial . print ( h ); Serial . print ( F ( \"% Temperature: \" )); Serial . print ( t ); Serial . print ( F ( \"\u00b0C \" )); Serial . print ( f ); Serial . print ( F ( \"\u00b0F Heat index: \" )); Serial . print ( hic ); Serial . print ( F ( \"\u00b0C \" )); Serial . print ( hif ); Serial . println ( F ( \"\u00b0F\" )); }","title":"DHT22"},{"location":"kits/mindev_kit/flame_sensor/","text":"","title":"Flame sensor"},{"location":"kits/mindev_kit/hall_sensors/","text":"","title":"Hall sensors"},{"location":"kits/mindev_kit/heart_beat_sensor/","text":"","title":"Heart beat sensor"},{"location":"kits/mindev_kit/introduction/","text":"","title":"Introduction"},{"location":"kits/mindev_kit/joystick/","text":"","title":"Joystick"},{"location":"kits/mindev_kit/laser_emitter_and_breaker/","text":"","title":"Laser emitter and breaker"},{"location":"kits/mindev_kit/light_barrier_sensor/","text":"","title":"Light barrier sensor"},{"location":"kits/mindev_kit/line_tracking_sensor/","text":"","title":"Line tracking sensor"},{"location":"kits/mindev_kit/matrix_LED/","text":"","title":"matrix LED"},{"location":"kits/mindev_kit/photoresistors/","text":"","title":"Photoresistors"},{"location":"kits/mindev_kit/relay_module/","text":"","title":"Relay module"},{"location":"kits/mindev_kit/rtc_module/","text":"","title":"Rtc module"},{"location":"kits/mindev_kit/servo/","text":"","title":"Servo"},{"location":"kits/mindev_kit/shock_sensor/","text":"","title":"Shock sensor"},{"location":"kits/mindev_kit/soil_moisture_sensors/","text":"","title":"Soil moisture sensors"},{"location":"kits/mindev_kit/sound_sensor/","text":"","title":"Sound sensor"},{"location":"kits/mindev_kit/step_motor/","text":"","title":"Step motor"},{"location":"kits/mindev_kit/tap_module/","text":"","title":"Tap module"},{"location":"kits/mindev_kit/tilt_switch/","text":"","title":"Tilt switch"},{"location":"kits/mindev_kit/touch_sensor/","text":"","title":"Touch sensor"},{"location":"kits/mindev_kit/vibration_sensor/","text":"","title":"Vibration sensor"},{"location":"kits/mindev_kit/water_sensor/","text":"","title":"Water sensor"},{"location":"platforms/arduino/","text":"Eduponics Wiki This wiki is under constructions. The entire Eduponics learning course and materials can be seen on the left menu of this wiki","title":"Eduponics Wiki"},{"location":"platforms/arduino/#eduponics-wiki","text":"This wiki is under constructions. The entire Eduponics learning course and materials can be seen on the left menu of this wiki","title":"Eduponics Wiki"},{"location":"platforms/esp32/","text":"Eduponics Wiki This wiki is under constructions. The entire Eduponics learning course and materials can be seen on the left menu of this wiki","title":"Eduponics Wiki"},{"location":"platforms/esp32/#eduponics-wiki","text":"This wiki is under constructions. The entire Eduponics learning course and materials can be seen on the left menu of this wiki","title":"Eduponics Wiki"},{"location":"platforms/esp32/analog_input_output/","text":"","title":"Analog input output"},{"location":"platforms/esp32/connecting_to_wifi/","text":"","title":"Connecting to wifi"},{"location":"platforms/esp32/digital_input_output/","text":"","title":"Digital input output"},{"location":"platforms/esp32/getting_started_with_micropython/","text":"","title":"Getting started with micropython"},{"location":"platforms/raspberry_pi/","text":"This wiki is under constructions. The entire Eduponics learning course and materials can be seen on the left menu of this wiki","title":"Index"},{"location":"platforms/raspberry_pi/flashing_image/","text":"Flashing image into the RPi SD card In this short guide we'll teach you how to download an image, download burner software and flash the image into your raspberry pi. Pre-requirements For this short tutorial you'll need the following: Windows, Mac or Ubuntu computer Micro SD card (if you are not sure which one to buy, keep reading) Micro SD card reader (MicroSD to USB adapter) Using your computer we'll download the image and the raspberry pi imager software to burn the image into your SD card If you use laptop, you might have a built-in SD card reader, if that's not the case you might need a micro SD reader. Using the right SD card There are many possibilities and options to choose from when you decide what SD card is best for your raspberry pi. from our perspective, it's best to choose between SanDisk Ultra or SanDisk Extreme series. When it comes to the size, we recommend at least 16GB but you might find 32GB cheaper and more useful. The SanDisk ultra and extreme series offer high data read and write speed, making your general Raspberry Pi experience smooth and convenient. you'll definitely feel the difference when you first boot your raspberry pi into the image, almost as you run it on SSD and normal mechanical HDD. Best for you: SanDisk Ultra / SanDisk Extreme series, 16GB and up. Downloading the right image When it comes to the image, we don't offer our own custom images. why? The main reason is because Raspberry Pi Foundation keep the images up to date all the time, which will require a lot of effort from us creating new images to catch up on their updates. instead, we create a custom installer to allow you to install all the drivers with one press of a button and make sure your custom installation that is required by different setups and kits that we offer! To get the best experience, we suggest to download the latest Raspbian OS from the raspberry Pi Foundation website. There are multiple versions, some including recommend software and some don't, as we use Raspberry Pi Zero for this course we suggest to either get the Desktop version without the software or with the software if you are just getting started. Download Raspbian OS from Raspberry Pi Official website Downloading raspberry pi imager Let's get the raspberry pi imager to burn the actual image into our SD card. Choosing the right imager is crucial, that depends on your operation system. Click The following links to download the latest version of the imager for Windows, macOS and Ubuntu Linux. Only download the owe that fits your OS. Raspberry Pi Imager for Windows Raspberry Pi Imager for macOS Raspberry Pi Imager for Ubuntu Version: 1.4 If you already have the image installed and you would like to install the imager inside your raspberry pi for copying or backup purposes of the current image, you can do so by running the following command in the terminal window: sudo apt install rpi-imager Flashing the image Now to our final step, once you have the image on your computer (should be .img file or .iso file) and the raspberry pi imager downloaded and installed, you are ready to go! open the imager software and it will ask you to choose a file, choose the image you've just downloaded from the raspberry pi website (Raspbian OS) and when selecting drive, make sure to choose the SD card reader that is connected to your computer with the micro SD card. Once you are all set and made sure you are burning the image on the right card, press \"WRITE\" to start the writing process, make sure not to quit the software in the middle! let it work it through and in few minutes you'll be ready with a brand new image of Raspbian OS.","title":"Flashing image into the RPi SD card"},{"location":"platforms/raspberry_pi/flashing_image/#flashing-image-into-the-rpi-sd-card","text":"In this short guide we'll teach you how to download an image, download burner software and flash the image into your raspberry pi.","title":"Flashing image into the RPi SD card"},{"location":"platforms/raspberry_pi/flashing_image/#pre-requirements","text":"For this short tutorial you'll need the following: Windows, Mac or Ubuntu computer Micro SD card (if you are not sure which one to buy, keep reading) Micro SD card reader (MicroSD to USB adapter) Using your computer we'll download the image and the raspberry pi imager software to burn the image into your SD card If you use laptop, you might have a built-in SD card reader, if that's not the case you might need a micro SD reader.","title":"Pre-requirements"},{"location":"platforms/raspberry_pi/flashing_image/#using-the-right-sd-card","text":"There are many possibilities and options to choose from when you decide what SD card is best for your raspberry pi. from our perspective, it's best to choose between SanDisk Ultra or SanDisk Extreme series. When it comes to the size, we recommend at least 16GB but you might find 32GB cheaper and more useful. The SanDisk ultra and extreme series offer high data read and write speed, making your general Raspberry Pi experience smooth and convenient. you'll definitely feel the difference when you first boot your raspberry pi into the image, almost as you run it on SSD and normal mechanical HDD. Best for you: SanDisk Ultra / SanDisk Extreme series, 16GB and up.","title":"Using the right SD card"},{"location":"platforms/raspberry_pi/flashing_image/#downloading-the-right-image","text":"When it comes to the image, we don't offer our own custom images. why? The main reason is because Raspberry Pi Foundation keep the images up to date all the time, which will require a lot of effort from us creating new images to catch up on their updates. instead, we create a custom installer to allow you to install all the drivers with one press of a button and make sure your custom installation that is required by different setups and kits that we offer! To get the best experience, we suggest to download the latest Raspbian OS from the raspberry Pi Foundation website. There are multiple versions, some including recommend software and some don't, as we use Raspberry Pi Zero for this course we suggest to either get the Desktop version without the software or with the software if you are just getting started. Download Raspbian OS from Raspberry Pi Official website","title":"Downloading the right image"},{"location":"platforms/raspberry_pi/flashing_image/#downloading-raspberry-pi-imager","text":"Let's get the raspberry pi imager to burn the actual image into our SD card. Choosing the right imager is crucial, that depends on your operation system. Click The following links to download the latest version of the imager for Windows, macOS and Ubuntu Linux. Only download the owe that fits your OS. Raspberry Pi Imager for Windows Raspberry Pi Imager for macOS Raspberry Pi Imager for Ubuntu Version: 1.4 If you already have the image installed and you would like to install the imager inside your raspberry pi for copying or backup purposes of the current image, you can do so by running the following command in the terminal window: sudo apt install rpi-imager","title":"Downloading raspberry pi imager"},{"location":"platforms/raspberry_pi/flashing_image/#flashing-the-image","text":"Now to our final step, once you have the image on your computer (should be .img file or .iso file) and the raspberry pi imager downloaded and installed, you are ready to go! open the imager software and it will ask you to choose a file, choose the image you've just downloaded from the raspberry pi website (Raspbian OS) and when selecting drive, make sure to choose the SD card reader that is connected to your computer with the micro SD card. Once you are all set and made sure you are burning the image on the right card, press \"WRITE\" to start the writing process, make sure not to quit the software in the middle! let it work it through and in few minutes you'll be ready with a brand new image of Raspbian OS.","title":"Flashing the image"},{"location":"platforms/raspberry_pi/initial_setup/","text":"Initial setup Pre-requirements At this stage, we assume you've followed all the instructions and have a fresh Raspbian OS image installed into your Micro SD card. Connecting to your Pi The first thing towards your Eduponics learning journey will be to setup your pi and kit to work. at this stage, you have a fresh SD card with Raspbian OS image on it, let's plug that SD card into the raspberry pi zero TODO: picture of the raspberry pi zero and SD card plugging into the eduponics kit by 40p header Once you've got that sorted out, connect the 12V power adapter to the DC input of the hardware kit TODO: picture of plugging 12V DC adapter into the eduponics kit Now you should see the Eduponics kit turn on together with the RPi zero blinking LEDs. There are two possible ways you could connect to your Eduponics kit, one would be using a wireless mouse and keyboard which if you have at home can be very useful. another one would be using SSH protocol which is a little more advanced. if you are up for a challenge and you are familiar with some unix commands and using CLI - we definitely recommend the SSH method. Keyboard, Mouse & Monitor With our kit we've included an HDMI to Micro HDMI adapter and a mini USB to USB Female adapter. those adapters will allow you to connect an HDMI supported monitor and a wireless keyboard and mouse to your raspberry pi zero and be able to control it with ease. once you've connected them properly, you should see the Raspbian OS Desktop right away. TODO: picture of eduponics kit with wireless mouse and keyboard connected to monitor SSH (advanced) Raspi-config preperation Expand file system Enable I2C Enable SPI Enable camera (optional) Driver installation","title":"Initial setup"},{"location":"platforms/raspberry_pi/initial_setup/#initial-setup","text":"","title":"Initial setup"},{"location":"platforms/raspberry_pi/initial_setup/#pre-requirements","text":"At this stage, we assume you've followed all the instructions and have a fresh Raspbian OS image installed into your Micro SD card.","title":"Pre-requirements"},{"location":"platforms/raspberry_pi/initial_setup/#connecting-to-your-pi","text":"The first thing towards your Eduponics learning journey will be to setup your pi and kit to work. at this stage, you have a fresh SD card with Raspbian OS image on it, let's plug that SD card into the raspberry pi zero TODO: picture of the raspberry pi zero and SD card plugging into the eduponics kit by 40p header Once you've got that sorted out, connect the 12V power adapter to the DC input of the hardware kit TODO: picture of plugging 12V DC adapter into the eduponics kit Now you should see the Eduponics kit turn on together with the RPi zero blinking LEDs. There are two possible ways you could connect to your Eduponics kit, one would be using a wireless mouse and keyboard which if you have at home can be very useful. another one would be using SSH protocol which is a little more advanced. if you are up for a challenge and you are familiar with some unix commands and using CLI - we definitely recommend the SSH method.","title":"Connecting to your Pi"},{"location":"platforms/raspberry_pi/initial_setup/#keyboard-mouse-monitor","text":"With our kit we've included an HDMI to Micro HDMI adapter and a mini USB to USB Female adapter. those adapters will allow you to connect an HDMI supported monitor and a wireless keyboard and mouse to your raspberry pi zero and be able to control it with ease. once you've connected them properly, you should see the Raspbian OS Desktop right away. TODO: picture of eduponics kit with wireless mouse and keyboard connected to monitor","title":"Keyboard, Mouse &amp; Monitor"},{"location":"platforms/raspberry_pi/initial_setup/#ssh-advanced","text":"","title":"SSH (advanced)"},{"location":"platforms/raspberry_pi/initial_setup/#raspi-config-preperation","text":"","title":"Raspi-config preperation"},{"location":"platforms/raspberry_pi/initial_setup/#expand-file-system","text":"","title":"Expand file system"},{"location":"platforms/raspberry_pi/initial_setup/#enable-i2c","text":"","title":"Enable I2C"},{"location":"platforms/raspberry_pi/initial_setup/#enable-spi","text":"","title":"Enable SPI"},{"location":"platforms/raspberry_pi/initial_setup/#enable-camera-optional","text":"","title":"Enable camera (optional)"},{"location":"platforms/raspberry_pi/initial_setup/#driver-installation","text":"","title":"Driver installation"},{"location":"products/eduponics_mini_extension_board/","text":"Eduponics Mini Extension board The Eduponics mini extension board designed using ADS1115 for ADC support and MCP23017 for GPIO control with some advance functionalities such as interrupt on change and precise analog data reading, the board allows to connect extra 4 analog data sensors and 4 digital output devices with 12V support. While the Eduponics Mini ESP32 board allows to connect only one pump and one soil moisture sensor, we've decided to develop a custom HAT (Hardware Attached on Top) to enhance the Eduponics Mini functionalities by adding extra 4 soil moisture sensors and extra 4 pumps. Features If we use simple words: the extension board allows us to control extra 4 plants (total of 5 plants) at the same time. If we go with deeper explanation, the sensors aren't necessary need to be soil moisture sensors or pumps, it can be any analog or digital sensors that needs to be controlled using the Eduponics Mini (or any other micro-controller), giving you access to extra 4 relays and another 4 open IOs (input / output) and extra 4 analog sensors control. This is really great addition not just to the Eduponics Mini ESP32 board but also to other microcontrollers such as Raspberry Pi that needs extra IO pins or analog reading which it's lack of. Here is the detailed features that the Eduponics Mini extension board can offer you: ADS1115 16 bit ADC chipset, precise analog data reading MCP23017 IO chipset, allows to control extra 8 IO (input or output) devices External interrupt pins on data change for MCP23017 External interrupt alert on analog data changes for ADS1115 4 Relay modules with XH2.54 connectors, 5V-24V support I2C interface - only 2 pins required 12-24V output for the relay modules MOSFETs to control the main power and the power for each analog input Arduino, Raspberry Pi & ESP32 and other controllers compatible 12V-24V are not the same as 5V input The Eduponics mini has 2 pins one is used as 12V pin goes from the DC adapter to the relay directly allows the relay to control pumps that rated higher than 5V, the other pin is 5V which gives power to the ESP32 and other ICs. DO NOT connect voltage higher than 5V to the pin rated as 5V as this WILL damage your Eduponics extension board and/or your Eduponics mini. The 12V-24V are designed to be isolated and wired through the relays ONLY and are meant to control external sensors and modules that require such voltage. Default address might be wrong for first batch (CrowdSupply) If you purchased the product through CrowdSupply on the first batch, your extension board might state \"MCP23017 default address: 0x20\" in fact, the default address is 0x27. But don't you worry! this have no effect on your product at all, just make sure to note the default address if you haven't played around with the switches is 0x27 instead of 0x20. ADS1115 16-Bit ADC The Eduponics Mini Built-in ADC works pretty well but for the extension board we've decided to use ADS1115 to increase the precision, the ADS1115 provides 16-bit precision at 860 samples/second over the I2C protocol, the ADC includes a programmable gain amplifier, up to x16, to help boost up smaller single/differential signals to the full range A micro-computer like Raspberry Pi for example doesn't have built-in ADC (analog to digital converter) as well as the pins might be occupied or limited, by using I2C we only need 2 pins and using the ADS1115 we can add analog capabilities to boards that lack of it. Features Here are some of the specific features of the ADS1115: Wide supply range: 2.0V to 5.5V Low current consumption: Continuous Mode: Only 150\u00b5A Single-Shot Mode: Auto Shut-Down Internal oscillator Internal PGA I2C Interface For the complete information, check the ADS1115 data sheet: ADS1115 datasheet ADS1X15 library Make sure micropython-eduponics is installed through upip For our Python code, we will need to import eduponics library, make sure you followed the introduction guide on installing the library on the ESP32 Eduponics Mini board. Below is the MicroPython library to control and configure the ADS1115 functionalities using the Eduponics Mini board and micropython-eduponics library, in the following example we are going to use a single soil moisture input in ADC(0). let's use it to to get the analog sensors data (both raw and voltage), voltage can be sometimes useful to create some other conversion techniques or use it for data collection purposes. We will configure I2C address on SCL pin 33 and SDA pin 32 as this is the pins the extension board connected to, then we will use the default 0x48 I2C address and set gain to 1 (default) When reading analog, current will flow. When not reading - current will not flow a cool feature we have built-in inside the ADS1X15 library is to auto-control the MOSFETs, when we test data through the ADS the MOSFETs will open, when we finish testing the MOSFETs will close. this allows us to both save power and use sensors together that otherwise might have a conflict. We will read the analog data from the sensors every second and print them into the terminal screen. For the Arduino code, we need to download and install the following library: ADS1115 Arduino Library MicroPython Arduino \"\"\" MicroPython BMCP23017 Eduponics mini extension board - Soil moisture demo https://github.com/STEMinds/eduponics-mini MIT License Copyright (c) 2020 STEMinds Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \"\"\" from eduponics import mcp23017 , ads1x15 from machine import I2C , Pin import time # IO12 reserved for powering the board, define it power = Pin ( 12 , Pin . OUT ) # activate the board power . value ( 1 ) # make sure to wait enough time for the board to wakeup time . sleep ( 0.1 ) # define i2c connection to the extension board i2c = I2C ( scl = Pin ( 33 ), sda = Pin ( 32 )) # setup adc for the extension board (default address for MCP might be 0x20) ads_address = 0x48 mcp_address = 0x27 gain = 1 adc = ads1x15 . ADS1115 ( i2c = i2c , address = ads_address , mcp_address = mcp_address , gain = gain ) # set max val and min val of the sensor # this requires manual calibration # minVal get be recieved by putting the sensor submerged in the water # maxVal can be recieved by making sure the sensor is dry in the clear air minVal = 710 maxVal = 4095 def value_in_percentage ( val ): # scale the value based on maxVal and minVal scale = 100 / ( minVal - maxVal ) # get calculated scale normal_reading = ( \" %s%s \" % ( int (( val - maxVal ) * scale ), \"%\" )) # we can also get inverted value if needed inverted_reading = ( \" %s%s \" % ( int (( minVal - val ) * scale ), \"%\" )) # for this example we'll return only the normal reading return normal_reading # get voltage adc_read = adc . read ( 0 ) # get sensor value voltage = adc_read [ \"voltage\" ] value = adc_read [ \"raw\" ] # print the analog results (moisture) print ( \"sensor value: %s \" % value ) print ( \"sensor value in percentage: %s \" % value_in_percentage ( value )) // I2C device class (I2Cdev) demonstration Arduino sketch for ADS1115 class // Example of reading two differential inputs of the ADS1115 and showing the value in mV // 2016-03-22 by Eadf (https://github.com/eadf) // Updates should (hopefully) always be available at https://github.com/jrowberg/i2cdevlib // // Changelog: // 2016-03-22 - initial release /* ============================================ I2Cdev device library code is placed under the MIT license Copyright (c) 2011 Jeff Rowberg Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. =============================================== Wiring the ADS1115 Module to an Arduino UNO ADS1115 --> UNO VDD 5V GND GND SCL A5 (or SCL) SDA A4 (or SDA) ALRT 2 */ #include \"ADS1115.h\" ADS1115 adc0 ( 0x48 ); // Wire ADS1115 ALERT/RDY pin to pin 25 const int alertReadyPin = 25 ; void setup () { //I2Cdev::begin(); // join I2C bus Wire . begin ( 33 , 32 ); Serial . begin ( 115200 ); // initialize serial communication Serial . println ( \"Testing device connections...\" ); Serial . println ( adc0 . testConnection () ? \"ADS1115 connection successful\" : \"ADS1115 connection failed\" ); adc0 . initialize (); // initialize ADS1115 16 bit A/D chip // We're going to do single shot sampling adc0 . setMode ( ADS1115_MODE_SINGLESHOT ); // Slow things down so that we can see that the \"poll for conversion\" code works adc0 . setRate ( ADS1115_RATE_8 ); // Set the gain (PGA) +/- 4.096V // Note that any analog input must be higher than \u20130.3V and less than VDD +0.3 adc0 . setGain ( ADS1115_PGA_4P096 ); // ALERT/RDY pin will indicate when conversion is ready pinMode ( alertReadyPin , INPUT_PULLUP ); adc0 . setConversionReadyPinMode (); // To get output from this method, you'll need to turn on the //#define ADS1115_SERIAL_DEBUG // in the ADS1115.h file #ifdef ADS1115_SERIAL_DEBUG adc0 . showConfigRegister (); Serial . print ( \"HighThreshold=\" ); Serial . println ( adc0 . getHighThreshold (), BIN ); Serial . print ( \"LowThreshold=\" ); Serial . println ( adc0 . getLowThreshold (), BIN ); #endif } /** Poll the assigned pin for conversion status */ void pollAlertReadyPin () { for ( uint32_t i = 0 ; i < 100000 ; i ++ ) if ( ! digitalRead ( alertReadyPin )) return ; Serial . println ( \"Failed to wait for AlertReadyPin, it's stuck high!\" ); } void loop () { // The below method sets the mux and gets a reading. adc0 . setMultiplexer ( ADS1115_MUX_P0_NG ); adc0 . triggerConversion (); pollAlertReadyPin (); Serial . print ( \"A0: \" ); Serial . print ( adc0 . getMilliVolts ( false )); Serial . print ( \"mV \\t \" ); adc0 . setMultiplexer ( ADS1115_MUX_P1_NG ); adc0 . triggerConversion (); pollAlertReadyPin (); Serial . print ( \"A1: \" ); Serial . print ( adc0 . getMilliVolts ( false )); Serial . print ( \"mV \\t \" ); adc0 . setMultiplexer ( ADS1115_MUX_P2_NG ); adc0 . triggerConversion (); pollAlertReadyPin (); Serial . print ( \"A2: \" ); Serial . print ( adc0 . getMilliVolts ( false )); Serial . print ( \"mV \\t \" ); adc0 . setMultiplexer ( ADS1115_MUX_P3_NG ); // Do conversion polling via I2C on this last reading: Serial . print ( \"A3: \" ); Serial . print ( adc0 . getMilliVolts ( true )); Serial . print ( \"mV\" ); Serial . println ( digitalRead ( alertReadyPin )); delay ( 500 ); } MCP23017 16-bit I/O Expander How can we control 4 relays without taking up 4 pins (excluding GND and VCC pins)? Simply use the MCP23017 I/O expander that uses I2C for communication (just 2 pins!) the MCP23017 can control up to 8 IO ports: 4 of the IO pins are reserved for the relays those cannot be re-wired as input or any other purposes, for the other 4 IO pins we've made pins available to connect any other extra sensors. Except that, the Eduponics Mini also has available IO ports for use which are not taken by any other application. Features All the MCP23017 pins can be used for either input or output and they even offer some advance features such as external interrupt on I/O changes, the complete feature list includes: 16-Bit Bidirectional I/O Ports High-Speed I2C Interface Control up to eight IO devices Configurable interrupt output pins To learn more, feel free to refer to the data sheet: MCP23017 data sheet MCP23017 library Make sure micropython-eduponics is installed through upip For our Python code, we will need to import eduponics library, make sure you followed the introduction guide on installing the library on the ESP32 Eduponics Mini board. For the Arduino demo - you'll need to install the arduino-mcp23017 library: arduino-mcp23017 In order to test the following example, make sure you have micropython-eduponics library installed through uPip: MicroPython Arduino #Copyright (c) 2020 Roni Gorodetsky for STEMinds #Website: https://steminds.com #Permission is hereby granted, free of charge, to any person obtaining a copy #of self software and associated documentation files (the \"Software\"), to deal #in the Software without restriction, including without limitation the rights #to use, copy, modify, merge, publish, distribute, sublicense, and/or sell #copies of the Software, and to permit persons to whom the Software is #furnished to do so, subject to the following conditions: #The above copyright notice and self permission notice shall be included in #all copies or substantial portions of the Software. #THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR #IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, #FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE #AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER #LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, #OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN #THE SOFTWARE. from eduponics import mcp23017 from machine import I2C , Pin import time # IO12 reserved for powering the board, define it power = Pin ( 12 , Pin . OUT ) # activate the board power . value ( 1 ) # make sure to wait enough time for the board to wakeup time . sleep ( 0.1 ) # define i2c connection to the extension board i2c = I2C ( scl = Pin ( 33 ), sda = Pin ( 32 )) # initialize relay object (default address might be 0x20) relays = mcp23017 . Relays ( i2c , address = 0x27 ) # open relays one by one for i in range ( 0 , 4 ): relays . open ( i ) time . sleep ( 1 ) # close all relays one by one for i in range ( 0 , 4 ): relays . close ( i ) time . sleep ( 1 ) # open all relays relays . open_all () time . sleep ( 3 ) # close all relays relays . close_all () /** * On every loop, the state of the port B is copied to port A. * * Use active low inputs on port A. Internal pullups are enabled by default by the library so there is no need for external resistors. * Place LEDS on port B for instance. * When pressing a button, the corresponding led is shut down. * * You can also uncomment one line to invert the input (when pressing a button the corresponding led is lit) */ #include <Wire.h> #include <MCP23017.h> #define MCP23017_ADDR 0x20 MCP23017 mcp = MCP23017 ( MCP23017_ADDR ); void setup () { Wire . begin ( 33 , 32 ); Serial . begin ( 115200 ); mcp . init (); mcp . portMode ( MCP23017Port :: A , 0 ); //Port A as output mcp . portMode ( MCP23017Port :: B , 0 ); //Port B as output mcp . portMode ( MCP23017Port :: C , 0 ); //Port C as output mcp . portMode ( MCP23017Port :: D , 0 ); //Port D as output mcp . writeRegister ( MCP23017Register :: GPIO_A , 0x00 ); //Reset port A mcp . writeRegister ( MCP23017Register :: GPIO_B , 0x00 ); //Reset port B mcp . writeRegister ( MCP23017Register :: GPIO_C , 0x00 ); //Reset port C mcp . writeRegister ( MCP23017Register :: GPIO_D , 0x00 ); //Reset port D } void loop () { // open relay A mcp . writePort ( MCP23017Port :: A , 1 ); delay ( 500 ); // open relay B mcp . writePort ( MCP23017Port :: B , 1 ); delay ( 500 ); // open relay C mcp . writePort ( MCP23017Port :: C , 1 ); delay ( 500 ); // open relay D mcp . writePort ( MCP23017Port :: D , 1 ); delay ( 500 ); // close relay A mcp . writePort ( MCP23017Port :: A , 0 ); delay ( 500 ); // close relay B mcp . writePort ( MCP23017Port :: B , 0 ); delay ( 500 ); // close relay C mcp . writePort ( MCP23017Port :: C , 0 ); delay ( 500 ); // close relay D mcp . writePort ( MCP23017Port :: D , 0 ); delay ( 500 ); }","title":"Extension board for Eduponics Mini"},{"location":"products/eduponics_mini_extension_board/#eduponics-mini-extension-board","text":"The Eduponics mini extension board designed using ADS1115 for ADC support and MCP23017 for GPIO control with some advance functionalities such as interrupt on change and precise analog data reading, the board allows to connect extra 4 analog data sensors and 4 digital output devices with 12V support. While the Eduponics Mini ESP32 board allows to connect only one pump and one soil moisture sensor, we've decided to develop a custom HAT (Hardware Attached on Top) to enhance the Eduponics Mini functionalities by adding extra 4 soil moisture sensors and extra 4 pumps.","title":"Eduponics Mini Extension board"},{"location":"products/eduponics_mini_extension_board/#features","text":"If we use simple words: the extension board allows us to control extra 4 plants (total of 5 plants) at the same time. If we go with deeper explanation, the sensors aren't necessary need to be soil moisture sensors or pumps, it can be any analog or digital sensors that needs to be controlled using the Eduponics Mini (or any other micro-controller), giving you access to extra 4 relays and another 4 open IOs (input / output) and extra 4 analog sensors control. This is really great addition not just to the Eduponics Mini ESP32 board but also to other microcontrollers such as Raspberry Pi that needs extra IO pins or analog reading which it's lack of. Here is the detailed features that the Eduponics Mini extension board can offer you: ADS1115 16 bit ADC chipset, precise analog data reading MCP23017 IO chipset, allows to control extra 8 IO (input or output) devices External interrupt pins on data change for MCP23017 External interrupt alert on analog data changes for ADS1115 4 Relay modules with XH2.54 connectors, 5V-24V support I2C interface - only 2 pins required 12-24V output for the relay modules MOSFETs to control the main power and the power for each analog input Arduino, Raspberry Pi & ESP32 and other controllers compatible 12V-24V are not the same as 5V input The Eduponics mini has 2 pins one is used as 12V pin goes from the DC adapter to the relay directly allows the relay to control pumps that rated higher than 5V, the other pin is 5V which gives power to the ESP32 and other ICs. DO NOT connect voltage higher than 5V to the pin rated as 5V as this WILL damage your Eduponics extension board and/or your Eduponics mini. The 12V-24V are designed to be isolated and wired through the relays ONLY and are meant to control external sensors and modules that require such voltage. Default address might be wrong for first batch (CrowdSupply) If you purchased the product through CrowdSupply on the first batch, your extension board might state \"MCP23017 default address: 0x20\" in fact, the default address is 0x27. But don't you worry! this have no effect on your product at all, just make sure to note the default address if you haven't played around with the switches is 0x27 instead of 0x20.","title":"Features"},{"location":"products/eduponics_mini_extension_board/#ads1115-16-bit-adc","text":"The Eduponics Mini Built-in ADC works pretty well but for the extension board we've decided to use ADS1115 to increase the precision, the ADS1115 provides 16-bit precision at 860 samples/second over the I2C protocol, the ADC includes a programmable gain amplifier, up to x16, to help boost up smaller single/differential signals to the full range A micro-computer like Raspberry Pi for example doesn't have built-in ADC (analog to digital converter) as well as the pins might be occupied or limited, by using I2C we only need 2 pins and using the ADS1115 we can add analog capabilities to boards that lack of it.","title":"ADS1115 16-Bit ADC"},{"location":"products/eduponics_mini_extension_board/#features_1","text":"Here are some of the specific features of the ADS1115: Wide supply range: 2.0V to 5.5V Low current consumption: Continuous Mode: Only 150\u00b5A Single-Shot Mode: Auto Shut-Down Internal oscillator Internal PGA I2C Interface For the complete information, check the ADS1115 data sheet: ADS1115 datasheet","title":"Features"},{"location":"products/eduponics_mini_extension_board/#ads1x15-library","text":"Make sure micropython-eduponics is installed through upip For our Python code, we will need to import eduponics library, make sure you followed the introduction guide on installing the library on the ESP32 Eduponics Mini board. Below is the MicroPython library to control and configure the ADS1115 functionalities using the Eduponics Mini board and micropython-eduponics library, in the following example we are going to use a single soil moisture input in ADC(0). let's use it to to get the analog sensors data (both raw and voltage), voltage can be sometimes useful to create some other conversion techniques or use it for data collection purposes. We will configure I2C address on SCL pin 33 and SDA pin 32 as this is the pins the extension board connected to, then we will use the default 0x48 I2C address and set gain to 1 (default) When reading analog, current will flow. When not reading - current will not flow a cool feature we have built-in inside the ADS1X15 library is to auto-control the MOSFETs, when we test data through the ADS the MOSFETs will open, when we finish testing the MOSFETs will close. this allows us to both save power and use sensors together that otherwise might have a conflict. We will read the analog data from the sensors every second and print them into the terminal screen. For the Arduino code, we need to download and install the following library: ADS1115 Arduino Library MicroPython Arduino \"\"\" MicroPython BMCP23017 Eduponics mini extension board - Soil moisture demo https://github.com/STEMinds/eduponics-mini MIT License Copyright (c) 2020 STEMinds Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \"\"\" from eduponics import mcp23017 , ads1x15 from machine import I2C , Pin import time # IO12 reserved for powering the board, define it power = Pin ( 12 , Pin . OUT ) # activate the board power . value ( 1 ) # make sure to wait enough time for the board to wakeup time . sleep ( 0.1 ) # define i2c connection to the extension board i2c = I2C ( scl = Pin ( 33 ), sda = Pin ( 32 )) # setup adc for the extension board (default address for MCP might be 0x20) ads_address = 0x48 mcp_address = 0x27 gain = 1 adc = ads1x15 . ADS1115 ( i2c = i2c , address = ads_address , mcp_address = mcp_address , gain = gain ) # set max val and min val of the sensor # this requires manual calibration # minVal get be recieved by putting the sensor submerged in the water # maxVal can be recieved by making sure the sensor is dry in the clear air minVal = 710 maxVal = 4095 def value_in_percentage ( val ): # scale the value based on maxVal and minVal scale = 100 / ( minVal - maxVal ) # get calculated scale normal_reading = ( \" %s%s \" % ( int (( val - maxVal ) * scale ), \"%\" )) # we can also get inverted value if needed inverted_reading = ( \" %s%s \" % ( int (( minVal - val ) * scale ), \"%\" )) # for this example we'll return only the normal reading return normal_reading # get voltage adc_read = adc . read ( 0 ) # get sensor value voltage = adc_read [ \"voltage\" ] value = adc_read [ \"raw\" ] # print the analog results (moisture) print ( \"sensor value: %s \" % value ) print ( \"sensor value in percentage: %s \" % value_in_percentage ( value )) // I2C device class (I2Cdev) demonstration Arduino sketch for ADS1115 class // Example of reading two differential inputs of the ADS1115 and showing the value in mV // 2016-03-22 by Eadf (https://github.com/eadf) // Updates should (hopefully) always be available at https://github.com/jrowberg/i2cdevlib // // Changelog: // 2016-03-22 - initial release /* ============================================ I2Cdev device library code is placed under the MIT license Copyright (c) 2011 Jeff Rowberg Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. =============================================== Wiring the ADS1115 Module to an Arduino UNO ADS1115 --> UNO VDD 5V GND GND SCL A5 (or SCL) SDA A4 (or SDA) ALRT 2 */ #include \"ADS1115.h\" ADS1115 adc0 ( 0x48 ); // Wire ADS1115 ALERT/RDY pin to pin 25 const int alertReadyPin = 25 ; void setup () { //I2Cdev::begin(); // join I2C bus Wire . begin ( 33 , 32 ); Serial . begin ( 115200 ); // initialize serial communication Serial . println ( \"Testing device connections...\" ); Serial . println ( adc0 . testConnection () ? \"ADS1115 connection successful\" : \"ADS1115 connection failed\" ); adc0 . initialize (); // initialize ADS1115 16 bit A/D chip // We're going to do single shot sampling adc0 . setMode ( ADS1115_MODE_SINGLESHOT ); // Slow things down so that we can see that the \"poll for conversion\" code works adc0 . setRate ( ADS1115_RATE_8 ); // Set the gain (PGA) +/- 4.096V // Note that any analog input must be higher than \u20130.3V and less than VDD +0.3 adc0 . setGain ( ADS1115_PGA_4P096 ); // ALERT/RDY pin will indicate when conversion is ready pinMode ( alertReadyPin , INPUT_PULLUP ); adc0 . setConversionReadyPinMode (); // To get output from this method, you'll need to turn on the //#define ADS1115_SERIAL_DEBUG // in the ADS1115.h file #ifdef ADS1115_SERIAL_DEBUG adc0 . showConfigRegister (); Serial . print ( \"HighThreshold=\" ); Serial . println ( adc0 . getHighThreshold (), BIN ); Serial . print ( \"LowThreshold=\" ); Serial . println ( adc0 . getLowThreshold (), BIN ); #endif } /** Poll the assigned pin for conversion status */ void pollAlertReadyPin () { for ( uint32_t i = 0 ; i < 100000 ; i ++ ) if ( ! digitalRead ( alertReadyPin )) return ; Serial . println ( \"Failed to wait for AlertReadyPin, it's stuck high!\" ); } void loop () { // The below method sets the mux and gets a reading. adc0 . setMultiplexer ( ADS1115_MUX_P0_NG ); adc0 . triggerConversion (); pollAlertReadyPin (); Serial . print ( \"A0: \" ); Serial . print ( adc0 . getMilliVolts ( false )); Serial . print ( \"mV \\t \" ); adc0 . setMultiplexer ( ADS1115_MUX_P1_NG ); adc0 . triggerConversion (); pollAlertReadyPin (); Serial . print ( \"A1: \" ); Serial . print ( adc0 . getMilliVolts ( false )); Serial . print ( \"mV \\t \" ); adc0 . setMultiplexer ( ADS1115_MUX_P2_NG ); adc0 . triggerConversion (); pollAlertReadyPin (); Serial . print ( \"A2: \" ); Serial . print ( adc0 . getMilliVolts ( false )); Serial . print ( \"mV \\t \" ); adc0 . setMultiplexer ( ADS1115_MUX_P3_NG ); // Do conversion polling via I2C on this last reading: Serial . print ( \"A3: \" ); Serial . print ( adc0 . getMilliVolts ( true )); Serial . print ( \"mV\" ); Serial . println ( digitalRead ( alertReadyPin )); delay ( 500 ); }","title":"ADS1X15 library"},{"location":"products/eduponics_mini_extension_board/#mcp23017-16-bit-io-expander","text":"How can we control 4 relays without taking up 4 pins (excluding GND and VCC pins)? Simply use the MCP23017 I/O expander that uses I2C for communication (just 2 pins!) the MCP23017 can control up to 8 IO ports: 4 of the IO pins are reserved for the relays those cannot be re-wired as input or any other purposes, for the other 4 IO pins we've made pins available to connect any other extra sensors. Except that, the Eduponics Mini also has available IO ports for use which are not taken by any other application.","title":"MCP23017 16-bit I/O Expander"},{"location":"products/eduponics_mini_extension_board/#features_2","text":"All the MCP23017 pins can be used for either input or output and they even offer some advance features such as external interrupt on I/O changes, the complete feature list includes: 16-Bit Bidirectional I/O Ports High-Speed I2C Interface Control up to eight IO devices Configurable interrupt output pins To learn more, feel free to refer to the data sheet: MCP23017 data sheet","title":"Features"},{"location":"products/eduponics_mini_extension_board/#mcp23017-library","text":"Make sure micropython-eduponics is installed through upip For our Python code, we will need to import eduponics library, make sure you followed the introduction guide on installing the library on the ESP32 Eduponics Mini board. For the Arduino demo - you'll need to install the arduino-mcp23017 library: arduino-mcp23017 In order to test the following example, make sure you have micropython-eduponics library installed through uPip: MicroPython Arduino #Copyright (c) 2020 Roni Gorodetsky for STEMinds #Website: https://steminds.com #Permission is hereby granted, free of charge, to any person obtaining a copy #of self software and associated documentation files (the \"Software\"), to deal #in the Software without restriction, including without limitation the rights #to use, copy, modify, merge, publish, distribute, sublicense, and/or sell #copies of the Software, and to permit persons to whom the Software is #furnished to do so, subject to the following conditions: #The above copyright notice and self permission notice shall be included in #all copies or substantial portions of the Software. #THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR #IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, #FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE #AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER #LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, #OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN #THE SOFTWARE. from eduponics import mcp23017 from machine import I2C , Pin import time # IO12 reserved for powering the board, define it power = Pin ( 12 , Pin . OUT ) # activate the board power . value ( 1 ) # make sure to wait enough time for the board to wakeup time . sleep ( 0.1 ) # define i2c connection to the extension board i2c = I2C ( scl = Pin ( 33 ), sda = Pin ( 32 )) # initialize relay object (default address might be 0x20) relays = mcp23017 . Relays ( i2c , address = 0x27 ) # open relays one by one for i in range ( 0 , 4 ): relays . open ( i ) time . sleep ( 1 ) # close all relays one by one for i in range ( 0 , 4 ): relays . close ( i ) time . sleep ( 1 ) # open all relays relays . open_all () time . sleep ( 3 ) # close all relays relays . close_all () /** * On every loop, the state of the port B is copied to port A. * * Use active low inputs on port A. Internal pullups are enabled by default by the library so there is no need for external resistors. * Place LEDS on port B for instance. * When pressing a button, the corresponding led is shut down. * * You can also uncomment one line to invert the input (when pressing a button the corresponding led is lit) */ #include <Wire.h> #include <MCP23017.h> #define MCP23017_ADDR 0x20 MCP23017 mcp = MCP23017 ( MCP23017_ADDR ); void setup () { Wire . begin ( 33 , 32 ); Serial . begin ( 115200 ); mcp . init (); mcp . portMode ( MCP23017Port :: A , 0 ); //Port A as output mcp . portMode ( MCP23017Port :: B , 0 ); //Port B as output mcp . portMode ( MCP23017Port :: C , 0 ); //Port C as output mcp . portMode ( MCP23017Port :: D , 0 ); //Port D as output mcp . writeRegister ( MCP23017Register :: GPIO_A , 0x00 ); //Reset port A mcp . writeRegister ( MCP23017Register :: GPIO_B , 0x00 ); //Reset port B mcp . writeRegister ( MCP23017Register :: GPIO_C , 0x00 ); //Reset port C mcp . writeRegister ( MCP23017Register :: GPIO_D , 0x00 ); //Reset port D } void loop () { // open relay A mcp . writePort ( MCP23017Port :: A , 1 ); delay ( 500 ); // open relay B mcp . writePort ( MCP23017Port :: B , 1 ); delay ( 500 ); // open relay C mcp . writePort ( MCP23017Port :: C , 1 ); delay ( 500 ); // open relay D mcp . writePort ( MCP23017Port :: D , 1 ); delay ( 500 ); // close relay A mcp . writePort ( MCP23017Port :: A , 0 ); delay ( 500 ); // close relay B mcp . writePort ( MCP23017Port :: B , 0 ); delay ( 500 ); // close relay C mcp . writePort ( MCP23017Port :: C , 0 ); delay ( 500 ); // close relay D mcp . writePort ( MCP23017Port :: D , 0 ); delay ( 500 ); }","title":"MCP23017 library"},{"location":"products/minduino_uno/","text":"Minduino Uno - Arduino compatible board About Arduino Minduino Uno Features Arduino Uno compatible design (Amtel 328P Chipset) 12 NeoPixels integrated RGB LED ring Integrated SD card for data logging USB Type-C power & data input Can be powered by 3.7V Lithium Battery Lithium battery charging circuit & LED indicator Differences between Minduino and Arduino","title":"Minduino uno"},{"location":"products/minduino_uno/#minduino-uno-arduino-compatible-board","text":"","title":"Minduino Uno - Arduino compatible board"},{"location":"products/minduino_uno/#about-arduino","text":"","title":"About Arduino"},{"location":"products/minduino_uno/#minduino-uno-features","text":"Arduino Uno compatible design (Amtel 328P Chipset) 12 NeoPixels integrated RGB LED ring Integrated SD card for data logging USB Type-C power & data input Can be powered by 3.7V Lithium Battery Lithium battery charging circuit & LED indicator","title":"Minduino Uno Features"},{"location":"products/minduino_uno/#differences-between-minduino-and-arduino","text":"","title":"Differences between Minduino and Arduino"}]}